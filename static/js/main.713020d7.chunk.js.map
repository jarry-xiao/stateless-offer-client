{"version":3,"sources":["contexts/AccountContext.tsx","utils/programIds.ts","actions/accept_offer.ts","utils/notifications.tsx","components/ExplorerLink/index.tsx","utils/eventEmitter.ts","components/Settings/index.tsx","components/DefaultModal/index.tsx","utils/account.ts","utils/borsh.ts","components/TransferBox/index.tsx","contexts/WalletContext/wallet.less","contexts/WalletContext/WalletContext.tsx","contexts/ModalContext.tsx","contexts/ColorModeContext.tsx","utils/ids.ts","components/ConnectButton.tsx","components/Header/Header.tsx","App.tsx","reportWebVitals.ts","index.tsx","constants/math.ts","utils/utils.ts","contexts/ConnectionContext.tsx"],"names":["AccountsContext","React","createContext","pendingCalls","Map","genericCache","pendingMintCalls","mintCache","getMintInfo","connection","pubKey","a","getAccountInfo","info","Error","data","Buffer","from","deserializeMint","TokenAccountParser","length","buffer","deserializeAccount","pubkey","account","keyToAccountParser","cache","emitter","EventEmitter","query","parser","id","PublicKey","address","toBase58","get","then","add","set","obj","isActive","deserialize","registerParser","delete","undefined","Function","isNew","has","raiseCacheUpdated","key","raiseCacheDeleted","byParser","result","keys","push","queryMint","mint","getMint","addMint","UseNativeAccount","useConnection","publicKey","useWallet","useState","nativeAccount","setNativeAccount","updateCache","useCallback","wrapped","WRAPPED_SOL_MINT","owner","amount","u64","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","wrapNativeAccount","useEffect","subId","updateAccount","onAccountChange","removeAccountChangeListener","PRECACHED_OWNERS","Set","precacheUserTokenAccounts","getTokenAccountsByOwner","programId","programIds","token","value","forEach","AccountsProvider","children","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","walletKey","selectUserAccounts","map","filter","accounts","subs","onCache","args","tokenSubID","onProgramAccountChange","accountId","accountInfo","AccountLayout","span","removeProgramAccountChangeListener","Provider","decode","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","MintLayout","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority","TOKEN_PROGRAM_ID","associatedToken","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","bpf_upgrade_loader","BPF_UPGRADE_LOADER_ID","system","SYSTEM","memo","MEMO_ID","PROGRAM_ID","AcceptOfferArgs","instruction","makerSize","takerSize","bumpSeed","this","schema","kind","fields","acceptOfferInstruction","makerWallet","takerWallet","makerSrc","makerDst","takerSrc","takerDst","makerSrcMint","takerSrcMint","transferAuthority","settings","serialize","isSigner","isWritable","NATIVE_MINT","SystemProgram","ix","TransactionInstruction","consolidateTokenAccounts","mintA","wallet","nonATAs","setNonATAs","notify","message","signers","instructions","findProgramAddress","toBuffer","tokenAccountMintA","createAssociatedTokenAccountInstruction","size","transferIx","Token","createTransferInstruction","closeIx","createCloseAccountInstruction","Conn","sendTransactionWithRetry","changeOffer","mintB","sizeA","sizeB","approve","ataIx","tokenAccountMintB","Uint8Array","toArray","authIx","createApproveInstruction","toNumber","createRevokeInstruction","trade","maker","makerAccountMintA","makerAccountMintB","takerAccountMintA","takerAccountMintB","hasATAMintB","console","log","bump","tradeIx","description","txid","type","placement","notification","style","color","opacity","backgroundColor","ExplorerLink","props","code","href","target","rel","title","Text","shortenAddress","CacheUpdateEvent","CacheDeleteEvent","MarketUpdateEvent","ids","Emitter","callback","on","removeListener","emit","Settings","additionalSettings","connected","disconnect","useConnectionConfig","setEndpoint","env","setVisible","useWalletModal","open","setModal","useModal","theme","useTheme","colorModeCtx","useColorMode","handleConnect","ModalEnum","WALLET","sx","display","minWidth","marginBottom","onChange","e","ENDPOINTS","name","endpoint","variant","onClick","marginLeft","navigator","clipboard","writeText","catch","ml","toggleColorMode","palette","mode","DefaultModal","bodyStyle","closeIcon","rest","background","borderRadius","flexDirection","alignItems","footer","width","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","SYSVAR_RENT_PUBKEY","BinaryReader","prototype","readPubkey","array","readFixedArray","BinaryWriter","writePubkey","writeFixedArray","readPubkeyAsString","base58","encode","writePubkeyAsString","MINTS","getSize","n","dec","decimals","Math","floor","parseFloat","pow","Number","isNaN","getDelegate","formState","BN","getExplorerLink","url","window","displayActions","isSeller","hasDelegate","hasValidDelegate","validAmount","mintEntered","marginRight","TransferBox","URL","location","params","URLSearchParams","search","slice","defaultState","getDefaultFormState","setFormState","accountState","setAccountState","setMintCache","setIsSeller","setValidAmount","setHasDelegate","setHasValidDelegate","openA","setOpenA","openB","setOpenB","tokenMap","setTokenMap","TokenListProvider","resolve","tokens","tokenList","filterByChainId","ENV","Devnet","getList","MainnetBeta","Testnet","reduce","item","symbol","validate","tokenAccount","totalAmount","fetchAccountState","sellerWallet","sellerMint","sellerTokenAccount","sellerTokenAccounts","badAccounts","fetchMintState","mintString","mintData","setField","escape","newUrl","protocol","host","pathname","toString","history","pushState","path","getField","handleEnter","getTokenKeys","mintStr","onKeyPress","inputProps","placeholder","fullWidth","fontStyle","component","m","justifyContent","noValidate","autoComplete","w","focus","onMouseOver","onMouseOut","disabled","required","label","textAlign","labelId","input","onClose","onOpen","renderValue","selected","InputLabelProps","shrink","marginTop","WalletModalContext","useContext","WalletModal","wallets","select","visible","close","onCancel","height","verticalAlign","fontWeight","fontSize","lineHeight","icon","alt","src","float","WalletModalProvider","setConnected","keyToDisplay","substring","WalletProvider","useMemo","getPhantomWallet","getSolflareWallet","getTorusWallet","options","clientId","getLedgerWallet","getSolongWallet","getMathWallet","getSolletWallet","onError","error","autoConnect","ModalContext","removeModal","context","ColorModeContext","ColorModeContextProvider","setMode","prevMode","ConnectButton","isConnected","onClickConnect","onClickChange","restProps","ButtonGroup","Header","handleChange","Box","bgcolor","flexGrow","getWindowDimensions","innerWidth","innerHeight","App","windowDimensions","setWindowDimensions","handleResize","addEventListener","removeEventListener","useWindowDimensions","createTheme","className","ThemeProvider","CssBaseline","mt","px","alignSelf","alignContent","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","TEN","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","useLocalStorageState","storedState","localStorage","getItem","JSON","parse","setState","setLocalStorageState","newState","removeItem","setItem","stringify","chars","chunks","Array","apply","ceil","_","index","currency","sleep","ms","Promise","setTimeout","ChainId","DEFAULT","ConnectionContext","Connection","ConnectionProvider","find","end","setTokens","container","list","excludeByTag","knownMints","Keypair","generate","onSlotChange","removeSlotChangeListener","SequenceType","getErrorForTransaction","confirmTransaction","getParsedConfirmedTransaction","tx","errors","meta","logMessages","regex","exec","lastIndex","sendTransactionsWithManualRetry","stopPoint","tries","lastInstructionsLength","toRemoveSigners","instr","i","filteredSigners","sendTransactions","StopOnFailure","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","transaction","Transaction","recentBlockhash","blockhash","setSigners","s","partialSign","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","signedTxnPromise","sendSignedTransaction","signedTransaction","slot","reason","all","sendTransaction","awaitConfirmation","includesFeePayer","signTransaction","rawTransaction","skipPreflight","sendRawTransaction","awaitTransactionSignatureConfirmation","DEFAULT_TIMEOUT","confirmation","err","beforeSend","getUnixTs","Date","getTime","timeout","startTime","done","simulateResult","simulateTransaction","logs","line","startsWith","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","encoding","_rpcRequest","res","queryStatus","status","confirmations","reject","onSignature","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener"],"mappings":"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","file":"static/js/main.713020d7.chunk.js","sourcesContent":["import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n} from 'react';\nimport { useConnection } from './ConnectionContext';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\nimport { AccountLayout, MintInfo, MintLayout, u64 } from '@solana/spl-token';\nimport { TokenAccount } from '../models';\nimport { chunks } from '../utils/utils';\nimport { EventEmitter } from '../utils/eventEmitter';\nimport { StringPublicKey, WRAPPED_SOL_MINT } from '../utils/ids';\nimport { programIds } from '../utils/programIds';\n\nconst AccountsContext = React.createContext<any>(null);\n\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\nconst genericCache = new Map<string, ParsedAccountBase>();\nconst pendingMintCalls = new Map<string, Promise<MintInfo>>();\nconst mintCache = new Map<string, MintInfo>();\n\nexport interface ParsedAccountBase {\n  pubkey: StringPublicKey;\n  account: AccountInfo<Buffer>;\n  info: any; // TODO: change to unknown\n}\n\nexport type AccountParser = (\n  pubkey: StringPublicKey,\n  data: AccountInfo<Buffer>,\n) => ParsedAccountBase | undefined;\n\nexport interface ParsedAccount<T> extends ParsedAccountBase {\n  info: T;\n}\n\nconst getMintInfo = async (connection: Connection, pubKey: PublicKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n  if (info === null) {\n    throw new Error('Failed to find mint account');\n  }\n\n  const data = Buffer.from(info.data);\n\n  return deserializeMint(data);\n};\n\nexport const MintParser = (pubKey: string, info: AccountInfo<Buffer>) => {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeMint(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const TokenAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  // Sometimes a wrapped sol account gets closed, goes to 0 length,\n  // triggers an update over wss which triggers this guy to get called\n  // since your UI already logged that pubkey as a token account. Check for length.\n  if (info.data.length > 0) {\n    const buffer = Buffer.from(info.data);\n    const data = deserializeAccount(buffer);\n\n    const details = {\n      pubkey: pubKey,\n      account: {\n        ...info,\n      },\n      info: data,\n    } as TokenAccount;\n\n    return details;\n  }\n};\n\nexport const GenericAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  const buffer = Buffer.from(info.data);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: buffer,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const keyToAccountParser = new Map<string, AccountParser>();\n\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (\n    connection: Connection,\n    pubKey: string | PublicKey,\n    parser?: AccountParser,\n  ) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = genericCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    // TODO: refactor to use multiple accounts query with flush like behavior\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error('Account not found');\n      }\n\n      return cache.add(id, data, parser);\n    }) as Promise<TokenAccount>;\n    pendingCalls.set(address, query as any);\n\n    return query;\n  },\n  add: (\n    id: PublicKey | string,\n    obj: AccountInfo<Buffer>,\n    parser?: AccountParser,\n    isActive?: boolean | undefined | ((parsed: any) => boolean),\n  ) => {\n    const address = typeof id === 'string' ? id : id?.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n    if (!deserialize) {\n      throw new Error(\n        'Deserializer needs to be registered or passed as a parameter',\n      );\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(address, obj);\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;\n    else if (isActive instanceof Function) isActive = isActive(account);\n\n    const isNew = !genericCache.has(address);\n\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n    return false;\n  },\n\n  byParser: (parser: AccountParser) => {\n    const result: string[] = [];\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey: PublicKey | string, parser: AccountParser) => {\n    if (pubkey) {\n      const address = typeof pubkey === 'string' ? pubkey : pubkey?.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: async (connection: Connection, pubKey: string | PublicKey) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let mint = mintCache.get(address);\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingMintCalls.delete(address);\n\n      mintCache.set(address, data);\n      return data;\n    }) as Promise<MintInfo>;\n    pendingMintCalls.set(address, query as any);\n\n    return query;\n  },\n  getMint: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\n    const mint = deserializeMint(obj.data);\n    const id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  },\n};\n\nexport const useAccountsContext = () => {\n  const context = useContext(AccountsContext);\n\n  return context;\n};\n\nfunction wrapNativeAccount(\n  pubkey: string,\n  account?: AccountInfo<Buffer>,\n): TokenAccount | undefined {\n  if (!account) {\n    return undefined;\n  }\n\n  const key = new PublicKey(pubkey);\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: key,\n      mint: WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null,\n    },\n  };\n}\n\nexport const getCachedAccount = (\n  predicate: (account: TokenAccount) => boolean,\n) => {\n  for (const account of genericCache.values()) {\n    if (predicate(account)) {\n      return account as TokenAccount;\n    }\n  }\n};\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\n\n  const updateCache = useCallback(\n    account => {\n      if (publicKey) {\n        const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n        if (wrapped !== undefined) {\n          const id = publicKey.toBase58();\n          cache.registerParser(id, TokenAccountParser);\n          genericCache.set(id, wrapped as TokenAccount);\n          cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser, true);\n        }\n      }\n    },\n    [publicKey],\n  );\n\n  useEffect(() => {\n    let subId = 0;\n    const updateAccount = (account: AccountInfo<Buffer> | null) => {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    (async () => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      try {\n        const account = await connection.getAccountInfo(publicKey);\n        updateAccount(account);\n      } catch {\n        return;\n      }\n\n      subId = connection.onAccountChange(publicKey, updateAccount);\n    })();\n\n    return () => {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n\n  return { nativeAccount };\n};\n\nconst PRECACHED_OWNERS = new Set<string>();\nconst precacheUserTokenAccounts = async (\n  connection: Connection,\n  owner?: PublicKey,\n) => {\n  if (!owner) {\n    return;\n  }\n\n  // used for filtering account updates over websocket\n  PRECACHED_OWNERS.add(owner.toBase58());\n\n  // user accounts are updated via ws subscription\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token,\n  });\n\n  accounts.value.forEach(info => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({ children = null as any }) {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\n  const { nativeAccount } = UseNativeAccount();\n  const walletKey = publicKey?.toBase58();\n\n  const selectUserAccounts = useCallback(() => {\n    return cache\n      .byParser(TokenAccountParser)\n      .map(id => cache.get(id))\n      .filter(a => a && a.info.owner.toBase58() === walletKey)\n      .map(a => a as TokenAccount);\n  }, [walletKey]);\n\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(\n      a => a !== undefined,\n    ) as TokenAccount[];\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n\n  useEffect(() => {\n    const subs: number[] = [];\n    cache.emitter.onCache(args => {\n      if (args.isNew && args.isActive) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), info => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      });\n\n      // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n      const tokenSubID = connection.onProgramAccountChange(\n        programIds().token,\n        info => {\n          // TODO: fix type in web3.js\n          const id = info.accountId as unknown as string;\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n          if (info.accountInfo.data.length === AccountLayout.span) {\n            const data = deserializeAccount(info.accountInfo.data);\n\n            if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n              cache.add(id, info.accountInfo, TokenAccountParser);\n              setTokenAccounts(selectUserAccounts());\n            }\n          }\n        },\n        'singleGossip',\n      );\n\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n\n  return (\n    <AccountsContext.Provider\n      value={{\n        userAccounts,\n        nativeAccount,\n      }}\n    >\n      {children}\n    </AccountsContext.Provider>\n  );\n}\n\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount as AccountInfo<Buffer>,\n  };\n}\n\nexport const getMultipleAccounts = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const result = await Promise.all(\n    chunks(keys, 99).map(chunk =>\n      getMultipleAccountsCore(connection, chunk, commitment),\n    ),\n  );\n\n  const array = result\n    .map(\n      a =>\n        a.array.map(acc => {\n          if (!acc) {\n            return undefined;\n          }\n\n          const { data, ...rest } = acc;\n          const obj = {\n            ...rest,\n            data: Buffer.from(data[0], 'base64'),\n          } as AccountInfo<Buffer>;\n          return obj;\n        }) as AccountInfo<Buffer>[],\n    )\n    .flat();\n  return { keys, array };\n};\n\nconst getMultipleAccountsCore = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const args = connection._buildArgs([keys], commitment, 'base64');\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  if (unsafeRes.error) {\n    throw new Error(\n      'failed to get info about account ' + unsafeRes.error.message,\n    );\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\n    return { keys, array };\n  }\n\n  // TODO: fix\n  throw new Error();\n};\n\nexport function useMint(key?: string | PublicKey) {\n  const connection = useConnection();\n  const [mint, setMint] = useState<MintInfo>();\n\n  const id = typeof key === 'string' ? key : key?.toBase58();\n\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache\n      .query(connection, id, MintParser)\n      .then(acc => setMint(acc.info as any))\n      .catch(err => console.log(err));\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === id) {\n        cache\n          .query(connection, id, MintParser)\n          .then(mint => setMint(mint.info as any));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n\n  return mint;\n}\n\nexport function useAccount(pubKey?: PublicKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState<TokenAccount>();\n\n  const key = pubKey?.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache\n          .query(connection, key, TokenAccountParser)\n          .catch(err => console.log(err));\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n\n  return account;\n}\n\n// TODO: expose in spl package\nexport const deserializeAccount = (data: Buffer) => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n\n// TODO: expose in spl package\nexport const deserializeMint = (data: Buffer) => {\n  if (data.length !== MintLayout.span) {\n    throw new Error('Not a valid Mint');\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as MintInfo;\n};\n","import {\n  TOKEN_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  BPF_UPGRADE_LOADER_ID,\n  SYSTEM,\n  MEMO_ID,\n} from './ids';\n\nexport const setProgramIds = async () => {};\n\nexport const programIds = () => {\n  return {\n    token: TOKEN_PROGRAM_ID,\n    associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    bpf_upgrade_loader: BPF_UPGRADE_LOADER_ID,\n    system: SYSTEM,\n    memo: MEMO_ID,\n    // store: STORE,\n  };\n};\n","import {\n  SystemProgram,\n  TransactionInstruction,\n  PublicKey,\n  Keypair,\n} from \"@solana/web3.js\";\nimport { Connection as Conn } from \"../contexts\";\nimport BN from \"bn.js\";\nimport {\n  notify,\n  createAssociatedTokenAccountInstruction,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from \"../utils\";\nimport { Schema, serialize } from \"borsh\";\nimport { TOKEN_PROGRAM_ID, Token, NATIVE_MINT } from \"@solana/spl-token\";\n\n// Hard-coded devnet key for now\nexport const PROGRAM_ID = new PublicKey(\n  \"SAtnofysr9Uxk7m9YphxwfL5E3wyZJWUzjwA29Gw3tQ\"\n);\n\nexport class AcceptOfferArgs {\n  instruction: number = 0;\n  makerSize: BN;\n  takerSize: BN;\n  bumpSeed: number;\n\n  static schema: Schema = new Map([\n    [\n      AcceptOfferArgs,\n      {\n        kind: \"struct\",\n        fields: [\n          [\"instruction\", \"u8\"],\n          [\"makerSize\", \"u64\"],\n          [\"takerSize\", \"u64\"],\n          [\"bumpSeed\", \"u8\"],\n        ],\n      },\n    ],\n  ]);\n\n  constructor(args: { makerSize: BN; takerSize: BN; bumpSeed: number }) {\n    this.makerSize = args.makerSize;\n    this.takerSize = args.takerSize;\n    this.bumpSeed = args.bumpSeed;\n  }\n}\n\nexport const acceptOfferInstruction = async (\n  makerWallet: PublicKey,\n  takerWallet: PublicKey,\n  makerSrc: PublicKey,\n  makerDst: PublicKey,\n  takerSrc: PublicKey,\n  takerDst: PublicKey,\n  makerSrcMint: PublicKey,\n  takerSrcMint: PublicKey,\n  transferAuthority: PublicKey,\n  makerSize: BN,\n  takerSize: BN,\n  bumpSeed: number\n) => {\n  let settings = new AcceptOfferArgs({ makerSize, takerSize, bumpSeed });\n  const data = Buffer.from(serialize(AcceptOfferArgs.schema, settings));\n  let keys = [\n    {\n      pubkey: makerWallet,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: takerWallet,\n      isSigner: true,\n      isWritable: false,\n    },\n    {\n      pubkey: makerSrc,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: makerDst,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: takerSrc,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: takerDst,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: makerSrcMint,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: takerSrcMint,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: transferAuthority,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  if (takerSrcMint.toBase58() === NATIVE_MINT.toBase58()) {\n    keys.push({\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    });\n  }\n  return {\n    ix: [\n      new TransactionInstruction({\n        keys,\n        programId: PROGRAM_ID,\n        data,\n      }),\n    ],\n  };\n};\n\nexport const consolidateTokenAccounts = async (\n  connection,\n  mintA: PublicKey,\n  wallet: any,\n  nonATAs: any[],\n  setNonATAs: any,\n) => {\n  if (!wallet.publicKey) {\n    notify({ message: \"Wallet not connected!\" });\n    return false;\n  }\n  let signers: Keypair[] = [];\n  let instructions: TransactionInstruction[] = [];\n  const tokenAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintA.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n  createAssociatedTokenAccountInstruction(\n    instructions,\n    tokenAccountMintA,\n    wallet.publicKey,\n    wallet.publicKey,\n    mintA\n  );\n  for (const {pubkey, size} of nonATAs) {\n    const transferIx = Token.createTransferInstruction(\n      TOKEN_PROGRAM_ID,\n      pubkey,\n      tokenAccountMintA,\n      wallet.publicKey,\n      [],\n      size,\n    );\n    const closeIx = Token.createCloseAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      pubkey,\n      wallet.publicKey,\n      wallet.publicKey,\n      [],\n    );\n    instructions.push(...[transferIx, closeIx]);\n  }\n  const response = await Conn.sendTransactionWithRetry(\n    connection,\n    wallet,\n    [...instructions],\n    signers,\n    \"max\"\n  );\n  if (!response) {\n    notify({ message: \"Consolidation Failed\" });\n    return false;\n  } else {\n    notify({ message: \"Successfully merged all token accounts into 1 Assoicated Token Account\" });\n    setNonATAs([]);\n    return true;\n  }\n\n};\n\nexport const changeOffer = async (\n  connection,\n  mintA: PublicKey,\n  mintB: PublicKey,\n  sizeA: BN,\n  sizeB: BN,\n  wallet: any,\n  approve = true\n) => {\n  if (!wallet.publicKey) {\n    notify({ message: \"Wallet not connected!\" });\n    return false;\n  }\n  let signers: Keypair[] = [];\n  let ataIx: TransactionInstruction[] = [];\n  const tokenAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintA.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintA = await connection.getAccountInfo(tokenAccountMintA);\n  if (!hasATAMintA) {\n    notify({ message: \"User must have ATA to create offer\" });\n    return false;\n  }\n\n  let tokenAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintB.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintB = await connection.getAccountInfo(tokenAccountMintB);\n  if (!hasATAMintB) {\n    createAssociatedTokenAccountInstruction(\n      ataIx,\n      tokenAccountMintB,\n      wallet.publicKey,\n      wallet.publicKey,\n      mintB\n    );\n  }\n  tokenAccountMintB =\n    mintB.toBase58() === NATIVE_MINT.toBase58()\n      ? wallet.publicKey\n      : tokenAccountMintB;\n  const transferAuthority = (await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"stateless_offer\"),\n      wallet.publicKey.toBuffer(),\n      mintA.toBuffer(),\n      mintB.toBuffer(),\n      new Uint8Array(sizeA.toArray(\"le\", 8)),\n      new Uint8Array(sizeB.toArray(\"le\", 8)),\n    ],\n    PROGRAM_ID\n  ))[0];\n  let authIx;\n  if (approve) {\n    authIx = Token.createApproveInstruction(\n      TOKEN_PROGRAM_ID,\n      tokenAccountMintA,\n      transferAuthority,\n      wallet.publicKey,\n      [],\n      sizeA.toNumber()\n    );\n  } else {\n    authIx = Token.createRevokeInstruction(\n      TOKEN_PROGRAM_ID,\n      tokenAccountMintA,\n      wallet.publicKey,\n      []\n    );\n  }\n  const response = await Conn.sendTransactionWithRetry(\n    connection,\n    wallet,\n    [...ataIx, authIx],\n    signers,\n    \"max\"\n  );\n  if (!response) {\n    notify({ message: \"Delegation transaction failed\" });\n    return false;\n  } else {\n    if (approve) {\n      notify({ message: `Successfully assigned delegate (${transferAuthority.toBase58()})` });\n    } else {\n      notify({ message: `Successfully removed delegate (${transferAuthority.toBase58()})` });\n    }\n    return true;\n  }\n};\n\nexport const trade = async (\n  connection,\n  maker: PublicKey,\n  mintA: PublicKey,\n  mintB: PublicKey,\n  sizeA: BN,\n  sizeB: BN,\n  wallet: any\n) => {\n  if (!wallet.publicKey) {\n    notify({ message: \"Wallet not connected!\" });\n    return false;\n  }\n  let signers: Keypair[] = [];\n  let ataIx: TransactionInstruction[] = [];\n\n  const makerAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [maker.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintA.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  if (!(await connection.getAccountInfo(makerAccountMintA))) {\n    notify({ message: \"Maker must have ATA for mint A\" });\n    return false;\n  }\n\n  let makerAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [maker.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintB.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  if (!(await connection.getAccountInfo(makerAccountMintB))) {\n    notify({ message: \"Maker must have ATA for mint B\" });\n    return false;\n  }\n\n  const takerAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintA.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintA = await connection.getAccountInfo(takerAccountMintA);\n  if (!hasATAMintA) {\n    createAssociatedTokenAccountInstruction(\n      ataIx,\n      takerAccountMintA,\n      wallet.publicKey,\n      wallet.publicKey,\n      mintA\n    );\n  }\n\n  let takerAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintB.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintB = await connection.getAccountInfo(\n    new PublicKey(takerAccountMintB)\n  );\n  console.log(mintB.toBase58());\n  console.log(NATIVE_MINT);\n  if (!hasATAMintB && mintB.toBase58() !== NATIVE_MINT.toBase58()) {\n    notify({ message: \"Taker must have ATA for mint B\" });\n    return false;\n  }\n\n  makerAccountMintB =\n    mintB.toBase58() === NATIVE_MINT.toBase58() ? maker : makerAccountMintB;\n  takerAccountMintB =\n    mintB.toBase58() === NATIVE_MINT.toBase58()\n      ? wallet.publicKey\n      : takerAccountMintB;\n  const [transferAuthority, bump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"stateless_offer\"),\n      maker.toBuffer(),\n      mintA.toBuffer(),\n      mintB.toBuffer(),\n      new Uint8Array(sizeA.toArray(\"le\", 8)),\n      new Uint8Array(sizeB.toArray(\"le\", 8)),\n    ],\n    PROGRAM_ID\n  );\n\n  let { ix } = await acceptOfferInstruction(\n    maker,\n    wallet.publicKey,\n    makerAccountMintA,\n    makerAccountMintB,\n    takerAccountMintB,\n    takerAccountMintA,\n    mintA,\n    mintB,\n    transferAuthority,\n    sizeA,\n    sizeB,\n    bump\n  );\n  const tradeIx = ix;\n\n  const response = await Conn.sendTransactionWithRetry(\n    connection,\n    wallet,\n    [...ataIx, ...tradeIx],\n    signers,\n    \"max\"\n  );\n  if (!response) {\n    notify({ message: \"Trade transaction failed\" });\n    return false;\n  } else {\n    notify({ message: \"Trade successful\" });\n    return true;\n  }\n};\n","import React from 'react';\nimport { notification } from 'antd';\n// import Link from '../components/Link';\n\nexport function notify({\n  message = '',\n  description = undefined as any,\n  txid = '',\n  type = 'info',\n  placement = 'bottomLeft',\n}) {\n  if (txid) {\n    //   <Link\n    //     external\n    //     to={'https://explorer.solana.com/tx/' + txid}\n    //     style={{ color: '#0000ff' }}\n    //   >\n    //     View transaction {txid.slice(0, 8)}...{txid.slice(txid.length - 8)}\n    //   </Link>\n\n    description = <></>;\n  }\n  (notification as any)[type]({\n    message: <span style={{ color: 'black' }}>{message}</span>,\n    description: (\n      <span style={{ color: 'black', opacity: 0.5 }}>{description}</span>\n    ),\n    placement,\n    style: {\n      backgroundColor: 'white',\n    },\n  });\n}\n","import React from 'react';\nimport { Typography } from 'antd';\nimport { shortenAddress } from '../../utils/utils';\nimport { PublicKey } from '@solana/web3.js';\n\nexport const ExplorerLink = (props: {\n  address: string | PublicKey;\n  type: string;\n  code?: boolean;\n  style?: React.CSSProperties;\n  length?: number;\n}) => {\n  const { type, code } = props;\n\n  const address =\n    typeof props.address === 'string'\n      ? props.address\n      : props.address?.toBase58();\n\n  if (!address) {\n    return null;\n  }\n\n  const length = props.length ?? 9;\n\n  return (\n    <a\n      href={`https://explorer.solana.com/${type}/${address}`}\n      target=\"_blank\"\n      rel=\"noreferrer\"\n      title={address}\n      style={props.style}\n    >\n      {code ? (\n        <Typography.Text style={props.style} code>\n          {shortenAddress(address, length)}\n        </Typography.Text>\n      ) : (\n        shortenAddress(address, length)\n      )}\n    </a>\n  );\n};\n","import { EventEmitter as Emitter } from 'eventemitter3';\n\nexport class CacheUpdateEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  parser: any;\n  isNew: boolean;\n  isActive: boolean;\n  constructor(id: string, isNew: boolean, parser: any, isActive: boolean) {\n    this.id = id;\n    this.parser = parser;\n    this.isNew = isNew;\n    this.isActive = isActive;\n  }\n}\n\nexport class CacheDeleteEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n\nexport class MarketUpdateEvent {\n  static type = 'MarketUpdate';\n  ids: Set<string>;\n  constructor(ids: Set<string>) {\n    this.ids = ids;\n  }\n}\n\nexport class EventEmitter {\n  private emitter = new Emitter();\n\n  onMarket(callback: (args: MarketUpdateEvent) => void) {\n    this.emitter.on(MarketUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(MarketUpdateEvent.type, callback);\n  }\n\n  onCache(callback: (args: CacheUpdateEvent) => void) {\n    this.emitter.on(CacheUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(CacheUpdateEvent.type, callback);\n  }\n\n  raiseMarketUpdated(ids: Set<string>) {\n    this.emitter.emit(MarketUpdateEvent.type, new MarketUpdateEvent(ids));\n  }\n\n  raiseCacheUpdated(\n    id: string,\n    isNew: boolean,\n    parser: any,\n    isActive: boolean,\n  ) {\n    this.emitter.emit(\n      CacheUpdateEvent.type,\n      new CacheUpdateEvent(id, isNew, parser, isActive),\n    );\n  }\n\n  raiseCacheDeleted(id: string) {\n    this.emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));\n  }\n}\n","import { useCallback } from \"react\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { ENDPOINTS, useColorMode, useConnectionConfig } from \"../../contexts\";\nimport { notify, shortenAddress } from \"../../utils\";\nimport { CopyOutlined } from \"@ant-design/icons\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport { Box } from \"@mui/system\";\nimport { Button, FormControl, NativeSelect } from \"@mui/material\";\nimport { useTheme } from \"@mui/material/styles\";\nimport IconButton from \"@mui/material/IconButton\";\nimport Brightness4Icon from \"@mui/icons-material/Brightness4\";\nimport Brightness7Icon from \"@mui/icons-material/Brightness7\";\n\nexport const Settings = ({\n  additionalSettings,\n}: {\n  additionalSettings?: JSX.Element;\n}) => {\n  const { connected, disconnect, publicKey } = useWallet();\n  const { setEndpoint, env } = useConnectionConfig();\n  const { setVisible } = useWalletModal();\n  const open = useCallback(() => setVisible(true), [setVisible]);\n  const { setModal } = useModal();\n  const theme = useTheme();\n  const colorModeCtx = useColorMode();\n\n  const handleConnect = useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n\n  return (\n    <>\n      <Box sx={{ display: \"flex\", minWidth: \"100%\" }}>\n        {!connected && (\n          <>\n            <FormControl>\n              <NativeSelect\n                style={{ marginBottom: 5 }}\n                onChange={(e) => {\n                  setEndpoint(e.target.value);\n                }}\n              >\n                {ENDPOINTS.map(({ name, endpoint }) => (\n                  <option value={endpoint}>{name}</option>\n                ))}\n              </NativeSelect>\n            </FormControl>\n            <Button\n              variant=\"contained\"\n              onClick={handleConnect}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Connect\n            </Button>\n          </>\n        )}\n        {connected && (\n          <>\n            {publicKey && (\n              <Button\n                variant=\"outlined\"\n                onClick={async () => {\n                  if (publicKey) {\n                    await navigator.clipboard.writeText(publicKey.toBase58());\n                    notify({\n                      message: \"Wallet update\",\n                      description: \"Address copied to clipboard\",\n                    });\n                  }\n                }}\n              >\n                <CopyOutlined />\n                {shortenAddress(publicKey.toBase58())}\n              </Button>\n            )}\n            <Button\n              variant=\"outlined\"\n              onClick={open}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Change Wallet\n            </Button>\n            <Button\n              variant=\"contained\"\n              color=\"error\"\n              onClick={() => disconnect().catch()}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Disconnect ({env})\n            </Button>\n          </>\n        )}\n        <IconButton\n          sx={{ ml: 1 }}\n          onClick={colorModeCtx.toggleColorMode}\n          color=\"inherit\"\n        >\n          {theme.palette.mode === \"dark\" ? (\n            <Brightness7Icon />\n          ) : (\n            <Brightness4Icon />\n          )}\n        </IconButton>\n        {additionalSettings}\n      </Box>\n    </>\n  );\n};\n","import React from \"react\";\nimport { Modal } from \"antd\";\n\nimport \"./index.css\";\n\nexport const DefaultModal = (props: any) => {\n  const { children, closeIcon, bodyStyle, style, ...rest } = props;\n\n  return (\n    <Modal\n      style={{ background: \"transparent\", borderRadius: 16 }}\n      bodyStyle={{\n        background: \"#333333\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        ...bodyStyle,\n      }}\n      footer={null}\n      width={400}\n      {...rest}\n    >\n      {children}\n    </Modal>\n  );\n};\n","import { AccountLayout, MintLayout, Token } from '@solana/spl-token';\nimport {\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport {\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n  WRAPPED_SOL_MINT,\n} from '../utils/ids';\nimport { programIds } from '../utils/programIds';\nimport { TokenAccount } from '../models/account';\nimport { cache, TokenAccountParser } from '../contexts/AccountContext';\n\nexport function ensureSplAccount(\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  toCheck: TokenAccount,\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  if (!toCheck.info.isNative) {\n    return toCheck.pubkey;\n  }\n\n  const account = createUninitializedAccount(\n    instructions,\n    payer,\n    amount,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      WRAPPED_SOL_MINT,\n      account,\n      payer,\n    ),\n  );\n\n  cleanupInstructions.push(\n    Token.createCloseAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      account,\n      payer,\n      payer,\n      [],\n    ),\n  );\n\n  return account;\n}\n\nexport const DEFAULT_TEMP_MEM_SPACE = 65548;\n\nexport function createTempMemoryAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  signers: Keypair[],\n  owner: PublicKey,\n  space = DEFAULT_TEMP_MEM_SPACE,\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      // 0 will evict/close account since it cannot pay rent\n      lamports: 0,\n      space: space,\n      programId: owner,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createUninitializedMint(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: MintLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createUninitializedAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: AccountLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createAssociatedTokenAccountInstruction(\n  instructions: TransactionInstruction[],\n  associatedTokenAddress: PublicKey,\n  payer: PublicKey,\n  walletAddress: PublicKey,\n  splTokenMintAddress: PublicKey,\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  instructions.push(\n    new TransactionInstruction({\n      keys,\n      programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n      data: Buffer.from([]),\n    }),\n  );\n}\n\nexport function createMint(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  mintRentExempt: number,\n  decimals: number,\n  owner: PublicKey,\n  freezeAuthority: PublicKey,\n  signers: Keypair[],\n) {\n  const account = createUninitializedMint(\n    instructions,\n    payer,\n    mintRentExempt,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      account,\n      decimals,\n      owner,\n      freezeAuthority,\n    ),\n  );\n\n  return account;\n}\n\nexport function createMintFromAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  decimals: number,\n  owner: PublicKey,\n  freezeAuthority: PublicKey,\n  account: Keypair,\n) {\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: MintLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n  instructions.push(\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      account.publicKey,\n      decimals,\n      owner,\n      freezeAuthority,\n    ),\n  );\n  return account;\n}\n\nexport function createTokenAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  accountRentExempt: number,\n  mint: PublicKey,\n  owner: PublicKey,\n  signers: Keypair[],\n) {\n  const account = createUninitializedAccount(\n    instructions,\n    payer,\n    accountRentExempt,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, account, owner),\n  );\n\n  return account;\n}\n\nexport function ensureWrappedAccount(\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  toCheck: TokenAccount | undefined,\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  if (toCheck && !toCheck.info.isNative) {\n    return toCheck.pubkey;\n  }\n\n  const TOKEN_PROGRAM_ID = programIds().token;\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: AccountLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      WRAPPED_SOL_MINT,\n      account.publicKey,\n      payer,\n    ),\n  );\n\n  cleanupInstructions.push(\n    Token.createCloseAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      account.publicKey,\n      payer,\n      payer,\n      [],\n    ),\n  );\n\n  signers.push(account);\n\n  return account.publicKey.toBase58();\n}\n\n// TODO: check if one of to accounts needs to be native sol ... if yes unwrap it ...\nexport function findOrCreateAccountByMint(\n  payer: PublicKey,\n  owner: PublicKey,\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  accountRentExempt: number,\n  mint: PublicKey, // use to identify same type\n  signers: Keypair[],\n  excluded?: Set<string>,\n): PublicKey {\n  const accountToFind = mint.toBase58();\n  const ownerKey = owner.toBase58();\n  const account = cache\n    .byParser(TokenAccountParser)\n    .map(id => cache.get(id))\n    .find(\n      acc =>\n        acc !== undefined &&\n        acc.info.mint.toBase58() === accountToFind &&\n        acc.info.owner.toBase58() === ownerKey &&\n        (excluded === undefined || !excluded.has(acc.pubkey)),\n    );\n  const isWrappedSol = accountToFind === WRAPPED_SOL_MINT.toBase58();\n\n  let toAccount: PublicKey;\n  if (account && !isWrappedSol) {\n    toAccount = new PublicKey(account.pubkey);\n  } else {\n    // creating depositor pool account\n    toAccount = createTokenAccount(\n      instructions,\n      payer,\n      accountRentExempt,\n      mint,\n      owner,\n      signers,\n    );\n\n    if (isWrappedSol) {\n      cleanupInstructions.push(\n        Token.createCloseAccountInstruction(\n          TOKEN_PROGRAM_ID,\n          toAccount,\n          payer,\n          payer,\n          [],\n        ),\n      );\n    }\n  }\n\n  return toAccount;\n}","import { PublicKey } from '@solana/web3.js';\nimport { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport { StringPublicKey } from './ids';\n\nexport const extendBorsh = () => {\n  (BinaryReader.prototype as any).readPubkey = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n  };\n\n  (BinaryWriter.prototype as any).writePubkey = function (value: PublicKey) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(value.toBuffer());\n  };\n\n  (BinaryReader.prototype as any).readPubkeyAsString = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array) as StringPublicKey;\n  };\n\n  (BinaryWriter.prototype as any).writePubkeyAsString = function (\n    value: StringPublicKey,\n  ) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(base58.decode(value));\n  };\n};\n\nextendBorsh();\n","import { useEffect, useState } from \"react\";\nimport Box from \"@mui/material/Box\";\nimport Button from \"@mui/material/Button\";\nimport {\n  Select,\n  FormControl,\n  OutlinedInput,\n  InputLabel,\n  MenuItem,\n  Input,\n} from \"@mui/material\";\nimport LoadingButton from \"@mui/lab/LoadingButton\";\nimport TextField from \"@mui/material/TextField\";\nimport {\n  useConnection,\n  deserializeAccount,\n  deserializeMint,\n  useConnectionConfig,\n} from \"../../contexts\";\nimport { SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID } from \"../../utils\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport {\n  changeOffer,\n  consolidateTokenAccounts,\n  trade,\n} from \"../../actions/accept_offer\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { ENV, TokenInfo, TokenListProvider } from \"@solana/spl-token-registry\";\n\nconst MINTS = [\"None\", \"SOL\", \"USDC\", \"USDT\", \"BTC\", \"ETH\"];\n\nconst getSize = (n: any, mint: any, mintCache: any) => {\n  try {\n    const dec = mintCache[mint].decimals;\n    const size = Math.floor(parseFloat(n) * Math.pow(10, dec));\n    if (Number.isNaN(size)) {\n      return 0;\n    }\n    return size;\n  } catch {\n    return 0;\n  }\n};\n\nconst getDelegate = async (formState: any, mintCache: any) => {\n  try {\n    const sizeA = getSize(formState.sizeA, formState.mintA, mintCache);\n    const sizeB = getSize(formState.sizeB, formState.mintB, mintCache);\n    return (\n      await PublicKey.findProgramAddress(\n        [\n          Buffer.from(\"stateless_offer\"),\n          new PublicKey(formState.maker).toBuffer(),\n          new PublicKey(formState.mintA).toBuffer(),\n          new PublicKey(formState.mintB).toBuffer(),\n          new Uint8Array(new BN(sizeA).toArray(\"le\", 8)),\n          new Uint8Array(new BN(sizeB).toArray(\"le\", 8)),\n        ],\n        new PublicKey(\"SAtnofysr9Uxk7m9YphxwfL5E3wyZJWUzjwA29Gw3tQ\")\n      )\n    )[0];\n  } catch {\n    return null;\n  }\n};\n\nconst getExplorerLink = (env, formState, mint) => {\n  if (env && formState && formState[mint]) {\n    let url = `https://explorer.solana.com/address/${formState[mint]}?cluster=${env}`;\n    return window.open(url, \"_blank\");\n  }\n  return false;\n};\n\nconst getDefaultFormState = () => {\n  let url = new URL(window.location.href);\n  let params = new URLSearchParams(url.search.slice(1));\n  let defaultState = {\n    mintA: \"\",\n    mintB: \"\",\n    sizeA: \"0\",\n    sizeB: \"0\",\n    maker: \"\",\n  };\n  for (const key of params.keys()) {\n    defaultState[key] = params.get(key);\n  }\n  return defaultState;\n};\n\nconst displayActions = (\n  connection,\n  wallet: any,\n  formState: any,\n  mintCache: any,\n  nonATAs: any,\n  setNonATAs: any,\n  isSeller,\n  hasDelegate,\n  hasValidDelegate,\n  validAmount\n) => {\n  const mintEntered =\n    formState.mintA in mintCache && formState.mintB in mintCache;\n  const sizeA = getSize(formState.sizeA, formState.mintA, mintCache);\n  const sizeB = getSize(formState.sizeB, formState.mintB, mintCache);\n  if (!mintEntered || sizeA <= 0 || sizeB <= 0) {\n    return <div></div>;\n  }\n  if (isSeller && nonATAs && nonATAs.length && nonATAs.length > 0) {\n    return (\n      <Button\n        variant=\"contained\"\n        color=\"success\"\n        onClick={() => {\n          if (formState) {\n            try {\n              consolidateTokenAccounts(\n                connection,\n                new PublicKey(formState.mintA),\n                wallet,\n                nonATAs,\n                setNonATAs\n              );\n            } catch (e) {\n              return;\n            }\n          }\n        }}\n        sx={{ marginRight: \"4px\" }}\n      >\n        Consolidate Token Accounts\n      </Button>\n    );\n  }\n  if (isSeller) {\n    return (\n      <div>\n        {validAmount && !hasValidDelegate && (\n          <Button\n            variant=\"contained\"\n            onClick={() => {\n              if (formState) {\n                try {\n                  changeOffer(\n                    connection,\n                    new PublicKey(formState.mintA),\n                    new PublicKey(formState.mintB),\n                    new BN(sizeA),\n                    new BN(sizeB),\n                    wallet\n                  );\n                } catch (e) {\n                  return;\n                }\n              }\n            }}\n            sx={{ marginRight: \"4px\" }}\n          >\n            Open New Offer\n          </Button>\n        )}\n        {hasDelegate && (\n          <Button\n            variant=\"contained\"\n            color=\"error\"\n            sx={{ marginLeft: \"10px\" }}\n            onClick={() => {\n              if (formState) {\n                try {\n                  changeOffer(\n                    connection,\n                    new PublicKey(formState.mintA),\n                    new PublicKey(formState.mintB),\n                    new BN(\n                      getSize(formState.sizeA, formState.mintA, mintCache)\n                    ),\n                    new BN(\n                      getSize(formState.sizeB, formState.mintB, mintCache)\n                    ),\n                    wallet,\n                    false\n                  );\n                } catch (e) {\n                  return;\n                }\n              }\n            }}\n          >\n            Close Existing Offer\n          </Button>\n        )}\n      </div>\n    );\n  } else {\n    if (hasValidDelegate && validAmount) {\n      return (\n        <div>\n          <Button\n            variant=\"contained\"\n            color=\"success\"\n            onClick={() => {\n              if (formState) {\n                try {\n                  trade(\n                    connection,\n                    new PublicKey(formState.maker),\n                    new PublicKey(formState.mintA),\n                    new PublicKey(formState.mintB),\n                    new BN(\n                      getSize(formState.sizeA, formState.mintA, mintCache)\n                    ),\n                    new BN(\n                      getSize(formState.sizeB, formState.mintB, mintCache)\n                    ),\n                    wallet\n                  );\n                } catch (e) {\n                  return;\n                }\n              }\n            }}\n          >\n            Trade\n          </Button>\n        </div>\n      );\n    } else {\n      return <div></div>;\n    }\n  }\n};\n\nexport function TransferBox() {\n  const connection = useConnection();\n  const wallet = useWallet();\n  const { env } = useConnectionConfig();\n  const [formState, setFormState] = useState(getDefaultFormState());\n  const [accountState, setAccountState] = useState({});\n  const [mintCache, setMintCache] = useState({});\n  const [isSeller, setIsSeller] = useState(false);\n  const [validAmount, setValidAmount] = useState(false);\n  const [hasDelegate, setHasDelegate] = useState(false);\n  const [hasValidDelegate, setHasValidDelegate] = useState(false);\n  const [openA, setOpenA] = useState(false);\n  const [openB, setOpenB] = useState(false);\n  const [nonATAs, setNonATAs] = useState();\n\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n\n  useEffect(() => {\n    new TokenListProvider().resolve().then((tokens) => {\n      let tokenList;\n      if (env === \"devnet\") {\n        tokenList = tokens.filterByChainId(ENV.Devnet).getList();\n      } else if (env === \"mainnet-beta\") {\n        tokenList = tokens.filterByChainId(ENV.MainnetBeta).getList();\n      } else if (env === \"testnet\") {\n        tokenList = tokens.filterByChainId(ENV.Testnet).getList();\n      }\n      setTokenMap(\n        tokenList.reduce((map, item) => {\n          map.set(item.symbol, item);\n          return map;\n        }, new Map())\n      );\n    });\n  }, [setTokenMap, env]);\n\n  useEffect(() => {\n    if (!wallet) {\n      return;\n    }\n    setIsSeller(wallet.publicKey?.toBase58() === formState.maker);\n  }, [formState, wallet, setIsSeller]);\n\n  useEffect(() => {\n    const validate = async () => {\n      const tokenAccount: any = accountState;\n      if (!tokenAccount.mint) {\n        return;\n      }\n      const mint = tokenAccount.mint.toBase58();\n      if (mint in mintCache) {\n        const dec = mintCache[mint].decimals;\n        const totalAmount = tokenAccount.amount * Math.pow(10, -dec);\n        try {\n          const size = parseFloat(formState.sizeA);\n          setValidAmount(totalAmount >= size && size > 0);\n        } catch {\n          console.log(\"Not a valid float\");\n        }\n      }\n\n      const delegate = await getDelegate(formState, mintCache);\n      setHasDelegate(tokenAccount.delegateOption !== 0);\n      if (\n        tokenAccount.delegate &&\n        delegate &&\n        tokenAccount.delegateOption !== 0 &&\n        delegate.toBase58() === tokenAccount.delegate.toBase58()\n      ) {\n        setHasValidDelegate(true);\n      } else {\n        setHasValidDelegate(false);\n      }\n    };\n    validate();\n  }, [accountState, mintCache, formState]);\n\n  useEffect(() => {\n    let subId;\n    const fetchAccountState = async () => {\n      let sellerWallet;\n      let sellerMint;\n      try {\n        sellerWallet = new PublicKey(formState.maker);\n        sellerMint = new PublicKey(formState.mintA);\n      } catch (e) {\n        return;\n      }\n      let sellerTokenAccount = (\n        await PublicKey.findProgramAddress(\n          [\n            sellerWallet.toBuffer(),\n            TOKEN_PROGRAM_ID.toBuffer(),\n            sellerMint.toBuffer(),\n          ],\n          SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n        )\n      )[0];\n      const result = await connection.getAccountInfo(sellerTokenAccount);\n      if (result) {\n        try {\n          const tokenAccount = deserializeAccount(result.data);\n          setAccountState(tokenAccount);\n        } catch (e) {\n          console.log(\"Failed to deserialize account\");\n        }\n      } else {\n        let sellerTokenAccounts;\n        try {\n          sellerTokenAccounts = await connection.getTokenAccountsByOwner(\n            sellerWallet,\n            { mint: sellerMint }\n          );\n        } catch {\n          return;\n        }\n        if (sellerTokenAccounts.value) {\n          let badAccounts: any = [];\n          for (const account of sellerTokenAccounts.value) {\n            try {\n              const size = deserializeAccount(account.account.data).amount;\n              badAccounts.push({ pubkey: account.pubkey, size: size });\n            } catch (e) {\n              console.log(\"Failed to deserialize account\", e);\n            }\n          }\n          console.log(badAccounts);\n          setNonATAs(badAccounts);\n        }\n      }\n      subId = connection.onAccountChange(sellerTokenAccount, async (result) => {\n        if (result) {\n          console.log(\"Received account data\");\n          try {\n            const tokenAccount = deserializeAccount(result.data);\n            setAccountState(tokenAccount);\n          } catch (e) {\n            console.log(\"Failed to deserialize account\", e);\n          }\n        }\n      });\n    };\n    fetchAccountState();\n    return () => {\n      if (subId) connection.removeAccountChangeListener(subId);\n    };\n  }, [formState.maker, formState.mintA, connection, setAccountState]);\n\n  useEffect(() => {\n    const fetchMintState = async () => {\n      let mint;\n      for (const mintString of [formState.mintA, formState.mintB]) {\n        try {\n          mint = new PublicKey(mintString);\n        } catch (e) {\n          continue;\n        }\n        if (!(mint.toBase58() in mintCache)) {\n          let result = await connection.getAccountInfo(mint);\n          if (result) {\n            try {\n              const mintData = deserializeMint(result.data);\n              setMintCache({\n                ...mintCache,\n                [mintString]: mintData,\n              });\n            } catch {\n              continue;\n            }\n          }\n        }\n      }\n    };\n    fetchMintState();\n  }, [mintCache, formState.mintA, formState.mintB, connection]);\n\n  const setField = (name: any) => {\n    const setFieldWithName = (e) => {\n      setFormState({ ...formState, [name]: e.target.value });\n      let url = new URL(window.location.href);\n      let params = new URLSearchParams(url.search.slice(1));\n      params.set(name, escape(e.target.value));\n      let newUrl =\n        window.location.protocol +\n        \"//\" +\n        window.location.host +\n        window.location.pathname +\n        \"?\" +\n        params.toString();\n      window.history.pushState({ path: newUrl }, \"\", newUrl);\n    };\n    return setFieldWithName;\n  };\n\n  const getField = (name: any) => {\n    if (name in formState) {\n      return formState[name];\n    }\n  };\n\n  const handleEnter = (e) => {\n    if (e.key === \"Enter\") {\n      setOpenA(false);\n      setOpenB(false);\n    }\n  };\n\n  const getTokenKeys = (tokenMap, mintStr) => {\n    let keys: any[] = [];\n    keys.push(\n      <Input\n        onKeyPress={handleEnter}\n        inputProps={{\n          sx: { marginLeft: \"15px\" },\n          value: getField(mintStr),\n          placeholder:\n            \"Enter the desired mint public key (or select from known mints)\",\n        }}\n        value={getField(mintStr)}\n        fullWidth\n        onChange={setField(mintStr)}\n      ></Input>\n    );\n    for (const mint of MINTS) {\n      if (!tokenMap.get(mint)) {\n        if (mint === \"None\") {\n          keys.push(\n            <MenuItem value=\"\" sx={{ fontStyle: \"italic\" }}>\n              {mint}\n            </MenuItem>\n          );\n        }\n        continue;\n      }\n      keys.push(<MenuItem value={tokenMap.get(mint).address}>{mint}</MenuItem>);\n    }\n    return keys;\n  };\n\n  return (\n    <div>\n      <div>\n        <Box\n          component=\"form\"\n          sx={{\n            \"& .MuiTextField-root\": { m: 1, width: \"60ch\" },\n            justifyContent: \"center\",\n            marginBottom: \"10px\",\n          }}\n          noValidate\n          autoComplete=\"on\"\n        >\n          <LoadingButton\n            onClick={() => {\n              const w = getExplorerLink(env, formState, \"mintA\");\n              if (w) {\n                w.focus();\n              }\n            }}\n            onMouseOver={() => {}}\n            onMouseOut={() => {}}\n            disabled={!(formState.mintA && formState.mintA in mintCache)}\n            color=\"secondary\"\n            sx={{ width: \"30ch\" }}\n            variant=\"contained\"\n          >\n            Seller Mint (Explorer)\n          </LoadingButton>\n          <LoadingButton\n            onClick={() => {\n              const w = getExplorerLink(env, formState, \"mintB\");\n              if (w) {\n                w.focus();\n              }\n            }}\n            disabled={!(formState.mintB && formState.mintB in mintCache)}\n            color=\"secondary\"\n            sx={{ width: \"30ch\", marginLeft: \"10px\" }}\n            variant=\"contained\"\n          >\n            Buyer Mint (Explorer)\n          </LoadingButton>\n        </Box>\n      </div>\n      <div>\n        <Box\n          component=\"form\"\n          sx={{\n            \"& .MuiTextField-root\": { m: 1, width: \"60ch\" },\n          }}\n          noValidate\n          autoComplete=\"on\"\n        >\n          <div>\n            <TextField\n              required\n              id=\"outlined-required\"\n              label=\"Seller Public Key\"\n              value={getField(\"maker\")}\n              onChange={setField(\"maker\")}\n            />\n            <FormControl sx={{ marginBottom: \"5px\" }}>\n              <InputLabel id=\"seller-mint\">Seller Mint</InputLabel>\n              <Select\n                sx={{\n                  display: \"inline-block\",\n                  textAlign: \"left\",\n                  width: \"60ch\",\n                }}\n                labelId=\"seller-mint\"\n                value={getField(\"mintA\")}\n                input={<OutlinedInput label=\"Seller Mint\" />}\n                onChange={setField(\"mintA\")}\n                open={openA}\n                onClose={(e) => {\n                  setOpenA(false);\n                }}\n                onOpen={(e) => {\n                  setOpenA(true);\n                }}\n                renderValue={(selected) => {\n                  return selected;\n                }}\n              >\n                {getTokenKeys(tokenMap, \"mintA\")}\n              </Select>\n            </FormControl>\n            <FormControl sx={{ marginBottom: \"5px\" }}>\n              <InputLabel id=\"buyer-mint\">Buyer Mint</InputLabel>\n              <Select\n                sx={{\n                  display: \"inline-block\",\n                  textAlign: \"left\",\n                  width: \"60ch\",\n                }}\n                labelId=\"buyer-mint\"\n                value={getField(\"mintB\")}\n                input={<OutlinedInput label=\"Buyer Mint\" />}\n                onChange={setField(\"mintB\")}\n                open={openB}\n                onClose={(e) => {\n                  setOpenB(false);\n                }}\n                onOpen={(e) => {\n                  setOpenB(true);\n                }}\n                renderValue={(selected) => {\n                  return selected;\n                }}\n              >\n                {getTokenKeys(tokenMap, \"mintB\")}\n              </Select>\n            </FormControl>\n            <TextField\n              id=\"outlined-number\"\n              label=\"Seller Size\"\n              type=\"number\"\n              value={getField(\"sizeA\")}\n              onChange={setField(\"sizeA\")}\n              sx={{ marginBottom: \"5px\" }}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n            <TextField\n              id=\"outlined-number\"\n              label=\"Buyer Size\"\n              type=\"number\"\n              value={getField(\"sizeB\")}\n              onChange={setField(\"sizeB\")}\n              sx={{ marginBottom: \"5px\" }}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n          </div>\n          <div style={{ marginTop: \"10px\" }}>\n            {displayActions(\n              connection,\n              wallet,\n              formState,\n              mintCache,\n              nonATAs,\n              setNonATAs,\n              isSeller,\n              hasDelegate,\n              hasValidDelegate,\n              validAmount\n            )}\n          </div>\n        </Box>\n      </div>\n    </div>\n  );\n}\n","export default __webpack_public_path__ + \"static/media/wallet.c746d144.less\";","import { WalletAdapter, WalletError } from \"@solana/wallet-adapter-base\";\nimport {\n  useWallet,\n  WalletProvider as BaseWalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  getLedgerWallet,\n  getMathWallet,\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolongWallet,\n  getTorusWallet,\n} from \"@solana/wallet-adapter-wallets\";\nimport { Button } from \"antd\";\nimport {\n  createContext,\n  FC,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { notify } from \"../../utils\";\nimport { DefaultModal } from \"../../components\";\n\nimport \"./wallet.less\";\n\nexport interface WalletModalContextState {\n  visible: boolean;\n  setVisible: (open: boolean) => void;\n}\n\nexport const WalletModalContext = createContext<WalletModalContextState>(\n  {} as WalletModalContextState\n);\n\nexport function useWalletModal(): WalletModalContextState {\n  return useContext(WalletModalContext);\n}\n\nexport const WalletModal: FC = () => {\n  const { wallets, wallet: selected, select } = useWallet();\n  const { visible, setVisible } = useWalletModal();\n  const close = useCallback(() => {\n    setVisible(false);\n  }, [setVisible]);\n\n  return (\n    <DefaultModal visible={visible} onCancel={close}>\n      <div\n        style={{\n          background:\n            \"linear-gradient(180deg, #D329FC 0%, #8F6DDE 49.48%, #19E6AD 100%)\",\n          borderRadius: 36,\n          width: 50,\n          height: 50,\n          textAlign: \"center\",\n          verticalAlign: \"middle\",\n          fontWeight: 700,\n          fontSize: \"1.3rem\",\n          lineHeight: 2.4,\n          marginBottom: 10,\n        }}\n      ></div>\n      <h2\n        style={{\n          color: \"white\",\n          fontWeight: \"bold\",\n          fontSize: 20,\n        }}\n      >\n        {selected ? \"Change provider\" : \"\"}\n      </h2>\n      <p style={{ color: \"white\", fontSize: 14 }}>\n        {selected\n          ? \"Choose from the following options:\"\n          : \"Please sign into your wallet\"}\n      </p>\n\n      <br />\n      {wallets.map((wallet) => {\n        return (\n          <Button\n            key={wallet.name}\n            size=\"large\"\n            type={wallet === selected ? \"primary\" : \"ghost\"}\n            onClick={() => {\n              select(wallet.name);\n              close();\n            }}\n            icon={\n              <img\n                alt={`${wallet.name}`}\n                width={20}\n                height={20}\n                src={wallet.icon}\n                style={{ marginRight: 30, float: \"left\" }}\n              />\n            }\n            style={{\n              display: \"block\",\n              width: \"100%\",\n              textAlign: \"left\",\n              marginBottom: 8,\n              color: \"white\",\n            }}\n          >\n            {wallet.name}\n          </Button>\n        );\n      })}\n    </DefaultModal>\n  );\n};\n\nexport const WalletModalProvider: FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const { publicKey } = useWallet();\n  const [connected, setConnected] = useState(!!publicKey);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (publicKey) {\n      const base58 = publicKey.toBase58();\n      const keyToDisplay =\n        base58.length > 20\n          ? `${base58.substring(0, 7)}.....${base58.substring(\n              base58.length - 7,\n              base58.length\n            )}`\n          : base58;\n\n      notify({\n        message: \"Wallet update\",\n        description: \"Connected to wallet \" + keyToDisplay,\n      });\n    }\n  }, [publicKey]);\n\n  useEffect(() => {\n    if (!publicKey && connected) {\n      notify({\n        message: \"Wallet update\",\n        description: \"Disconnected from wallet\",\n      });\n    }\n    setConnected(!!publicKey);\n  }, [publicKey, connected, setConnected]);\n\n  return (\n    <WalletModalContext.Provider\n      value={{\n        visible,\n        setVisible,\n      }}\n    >\n      {children}\n      <WalletModal />\n    </WalletModalContext.Provider>\n  );\n};\n\nexport const WalletProvider: FC<{ children: ReactNode }> = ({ children }) => {\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getTorusWallet({\n        options: {\n          // @FIXME: this should be changed for Default, and by each Default storefront\n          clientId:\n            \"BOM5Cl7PXgE9Ylq1Z1tqzhpydY0RVr8k90QQ85N7AKI5QGSrr9iDC-3rvmy0K_hF0JfpLMiXoDhta68JwcxS1LQ\",\n        },\n      }),\n      getLedgerWallet(),\n      getSolongWallet(),\n      getMathWallet(),\n      getSolletWallet(),\n    ],\n    []\n  );\n\n  const onError = useCallback((error: WalletError) => {\n    console.error(error);\n    notify({\n      message: \"Wallet error\",\n      description: error.message,\n    });\n  }, []);\n\n  return (\n    <BaseWalletProvider wallets={wallets} onError={onError} autoConnect>\n      <WalletModalProvider>{children}</WalletModalProvider>\n    </BaseWalletProvider>\n  );\n};\n\nexport type WalletSigner = Pick<\n  WalletAdapter,\n  \"publicKey\" | \"signTransaction\" | \"signAllTransactions\"\n>;\n","import React, { useState, useContext, useCallback } from 'react';\n\nimport { WalletModal } from './WalletContext/WalletContext';\n\nexport enum ModalEnum {\n  WALLET = 'wallet',\n}\n\ntype ModalContextProps = {\n  setModal: (modal: ModalEnum | undefined) => void;\n  removeModal: () => void;\n};\n\nexport const ModalContext = React.createContext<ModalContextProps>({\n  setModal: () => null,\n  removeModal: () => null,\n});\n\nexport const ModalProvider: React.FC = ({ children }) => {\n  const [modal, setModal] = useState<ModalEnum | undefined>(undefined);\n\n  const removeModal = useCallback(() => {\n    setModal(undefined);\n  }, [setModal]);\n\n  return (\n    <ModalContext.Provider\n      value={{\n        setModal,\n        removeModal,\n      }}\n    >\n      {children}\n      {modal === ModalEnum.WALLET && <WalletModal />}\n    </ModalContext.Provider>\n  );\n};\n\nexport const useModal = (): ModalContextProps => {\n  const context = useContext(ModalContext);\n  if (context === undefined) {\n    throw new Error('useModal must be used within a ModalProvider');\n  }\n  return context;\n};\n","import { useTheme } from \"@mui/material\";\nimport React, { useContext } from \"react\";\n\nexport const ColorModeContext = React.createContext({});\n\nexport const ColorModeContextProvider = ({children=null as any }) => {\n  const [mode, setMode] = React.useState<'light' | 'dark'>('dark'); \n  const theme = useTheme();\n  const toggleColorMode = () => {\n    setMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));\n  }\n  return (\n    <ColorModeContext.Provider\n      value={{\n        toggleColorMode,\n        mode,\n        theme,\n      }}\n    >\n      {children}\n    </ColorModeContext.Provider>\n  );\n};\n\nexport const useColorMode = (): any => {\n  const context = useContext(ColorModeContext);\n  return context;\n};\n","import { PublicKey, AccountInfo } from '@solana/web3.js';\n\nexport type StringPublicKey = string;\n\nexport class LazyAccountInfoProxy<T> {\n  executable: boolean = false;\n  owner: StringPublicKey = '';\n  lamports: number = 0;\n\n  get data() {\n    //\n    return undefined as unknown as T;\n  }\n}\n\nexport interface LazyAccountInfo {\n  executable: boolean;\n  owner: StringPublicKey;\n  lamports: number;\n  data: [string, string];\n}\n\nconst PubKeysInternedMap = new Map<string, PublicKey>();\n\nexport const toPublicKey = (key: string | PublicKey) => {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  let result = PubKeysInternedMap.get(key);\n  if (!result) {\n    result = new PublicKey(key);\n    PubKeysInternedMap.set(key, result);\n  }\n\n  return result;\n};\n\nexport interface PublicKeyStringAndAccount<T> {\n  pubkey: string;\n  account: AccountInfo<T>;\n}\n\nexport const WRAPPED_SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const BPF_UPGRADE_LOADER_ID = new PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');\n\nexport const MEMO_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');\n\nexport const SYSTEM = new PublicKey('11111111111111111111111111111111');\n","import { ButtonGroup, ButtonGroupProps } from \"@mui/material\";\nimport { Settings } from \"./Settings\";\n\nexport type ConnectButtonProps = ButtonGroupProps & {\n  isConnected: boolean;\n  onClickConnect: () => void;\n  onClickChange: () => void;\n};\n\nexport const ConnectButton: React.FC<ConnectButtonProps> = ({\n  isConnected,\n  onClickConnect,\n  onClickChange,\n  ...restProps\n}) => {\n  return (\n    <ButtonGroup   {...restProps}>\n      <Settings/>\n    </ButtonGroup>\n  );\n};\n\nexport default ConnectButton;\n","import React, { useCallback } from \"react\";\nimport { Box } from \"@mui/system\";\n\nimport ConnectButton from \"../ConnectButton\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\n\nexport const Header: React.FC = () => {\n  const { setModal } = useModal();\n  const { setVisible } = useWalletModal();\n  const wallet = useWallet();\n  const connected = wallet.connected;\n\n  const handleChange = useCallback(() => setVisible(true), [setVisible]);\n\n  const handleConnect = useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n  return (\n    <Box\n      sx={{\n        display: \"flex\",\n        bgcolor: \"action.disabledBackground\",\n      }}\n      minWidth=\"100%\"\n    >\n      <Box sx={{flexGrow: 1}}></Box>\n      <Box\n        sx={{\n          display: \"flex\",\n          height: \"62px\",\n          justifyContent: \"flex-end\",\n          alignItems: \"center\",\n        }}\n      >\n        <ConnectButton\n          isConnected={connected}\n          sx={{ marginRight: \"36px\" }}\n          onClickConnect={handleConnect}\n          onClickChange={handleChange}\n        />\n      </Box>\n    </Box>\n  );\n};\n\nexport default Header;\n","import React, { useEffect, useState } from \"react\";\nimport \"./App.css\";\nimport Header from \"./components/Header/Header\";\nimport { TransferBox } from \"./components\";\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\";\nimport CssBaseline from \"@mui/material/CssBaseline\";\nimport { useColorMode } from \"./contexts\";\nimport { Box } from \"@mui/material\";\n\nconst getWindowDimensions = () => {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height\n  };\n}\n\nconst useWindowDimensions = () => {\n  const [windowDimensions, setWindowDimensions] = useState(\n    getWindowDimensions()\n  );\n\n  useEffect(() => {\n    function handleResize() {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return windowDimensions;\n}\n\nfunction App() {\n  const colorModeCtx = useColorMode();\n\n  const mode =\n    colorModeCtx.mode === \"dark\" || !colorModeCtx.mode ? \"dark\" : \"light\";\n\n  const { height } = useWindowDimensions();\n\n  const theme = React.useMemo(\n    () =>\n      createTheme({\n        palette: {\n          mode,\n        },\n      }),\n    [mode]\n  );\n\n  return (\n    <div className=\"App\" style={{ backgroundColor: \"transparent\" }}>\n      <ThemeProvider theme={theme}>\n        <CssBaseline />\n        <Header />\n        <Box\n          sx={{\n            width: 600,\n            flexGrow: 1,\n            mt: `${Math.floor(0.2*height)}px`,\n            px: \"50%\",\n            display: \"flex\",\n            alignSelf: \"center\",\n            justifyContent: \"center\",\n            alignContent: \"center\",\n          }}\n        >\n          <TransferBox />\n        </Box>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  AccountsProvider,\n  WalletProvider,\n  ConnectionProvider,\n  ColorModeContextProvider,\n} from \"./contexts\";\n\nimport \"antd/dist/antd.css\";\nimport \"@fontsource/open-sans\";\nimport \"@fontsource/roboto\";\nimport \"@fontsource/sora\";\n\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <ConnectionProvider>\n      <WalletProvider>\n        <AccountsProvider>\n          <ColorModeContextProvider>\n            <App />\n          </ColorModeContextProvider>\n        </AccountsProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nreportWebVitals();\n","import BN from 'bn.js';\n\nexport const TEN = new BN(10);\nexport const HALF_WAD = TEN.pow(new BN(18));\nexport const WAD = TEN.pow(new BN(18));\nexport const RAY = TEN.pow(new BN(27));\nexport const ZERO = new BN(0);\n","import { useCallback, useState } from 'react';\nimport { MintInfo } from '@solana/spl-token';\n\nimport { TokenAccount } from './../models';\nimport { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { WAD, ZERO } from '../constants';\nimport { TokenInfo } from '@solana/spl-token-registry';\n\nexport type KnownTokenMap = Map<string, TokenInfo>;\n\nexport const formatPriceNumber = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 8,\n});\n\nexport function useLocalStorageState(key: string, defaultState?: string) {\n  const [state, setState] = useState(() => {\n    // NOTE: Not sure if this is ok\n    const storedState = localStorage.getItem(key);\n    if (storedState) {\n      return JSON.parse(storedState);\n    }\n    return defaultState;\n  });\n\n  const setLocalStorageState = useCallback(\n    newState => {\n      const changed = state !== newState;\n      if (!changed) {\n        return;\n      }\n      setState(newState);\n      if (newState === null) {\n        localStorage.removeItem(key);\n      } else {\n        try {\n          localStorage.setItem(key, JSON.stringify(newState));\n        } catch {\n          // ignore\n        }\n      }\n    },\n    [state, key],\n  );\n\n  return [state, setLocalStorageState];\n}\n\nexport const findProgramAddress = async (\n  seeds: (Buffer | Uint8Array)[],\n  programId: PublicKey,\n) => {\n  const key =\n    'pda-' +\n    seeds.reduce((agg, item) => agg + item.toString('hex'), '') +\n    programId.toString();\n  let cached = localStorage.getItem(key);\n  if (cached) {\n    const value = JSON.parse(cached);\n\n    return [value.key, parseInt(value.nonce)] as [string, number];\n  }\n\n  const result = await PublicKey.findProgramAddress(seeds, programId);\n\n  try {\n    localStorage.setItem(\n      key,\n      JSON.stringify({\n        key: result[0].toBase58(),\n        nonce: result[1],\n      }),\n    );\n  } catch {\n    // ignore\n  }\n\n  return [result[0].toBase58(), result[1]] as [string, number];\n};\n\n// shorten the checksummed version of the input address to have 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\n\nexport function getTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownSymbol = map.get(mintAddress)?.symbol;\n  if (knownSymbol) {\n    return knownSymbol;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\nexport function getVerboseTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownName = map.get(mintAddress)?.name;\n  if (knownName) {\n    return knownName;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\n\nexport function getTokenByName(tokenMap: KnownTokenMap, name: string) {\n  let token: TokenInfo | null = null;\n  for (const val of tokenMap.values()) {\n    if (val.symbol === name) {\n      token = val;\n      break;\n    }\n  }\n  return token;\n}\n\nexport function getTokenIcon(\n  map: KnownTokenMap,\n  mintAddress?: string | PublicKey,\n): string | undefined {\n  const address =\n    typeof mintAddress === 'string' ? mintAddress : mintAddress?.toBase58();\n  if (!address) {\n    return;\n  }\n\n  return map.get(address)?.logoURI;\n}\n\nexport function isKnownMint(map: KnownTokenMap, mintAddress: string) {\n  return !!map.get(mintAddress);\n}\n\nexport const STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);\n\nexport function chunks<T>(array: T[], size: number): T[][] {\n  return Array.apply<number, T[], T[][]>(\n    0,\n    new Array(Math.ceil(array.length / size)),\n  ).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n\nexport function toLamports(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  return Math.floor(amount * precision);\n}\n\nexport function wadToLamports(amount?: BN): BN {\n  return amount?.div(WAD) || ZERO;\n}\n\nexport function fromLamports(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount = Math.floor(\n    typeof account === 'number'\n      ? account\n      : BN.isBN(account)\n      ? account.toNumber()\n      : account.info.amount.toNumber(),\n  );\n\n  const precision = Math.pow(10, mint?.decimals || 9);\n  return (amount / precision) * rate;\n}\n\nexport const tryParseKey = (key: string): PublicKey | null => {\n  try {\n    return new PublicKey(key);\n  } catch (error) {\n    return null;\n  }\n};\n\nvar SI_SYMBOL = ['', 'k', 'M', 'G', 'T', 'P', 'E'];\n\nconst abbreviateNumber = (number: number, precision: number) => {\n  let tier = (Math.log10(number) / 3) | 0;\n  let scaled = number;\n  let suffix = SI_SYMBOL[tier];\n  if (tier !== 0) {\n    let scale = Math.pow(10, tier * 3);\n    scaled = number / scale;\n  }\n\n  return scaled.toFixed(precision) + suffix;\n};\n\nexport const formatAmount = (\n  val: number,\n  precision: number = 2,\n  abbr: boolean = true,\n) => (abbr ? abbreviateNumber(val, precision) : val.toFixed(precision));\n\nexport function formatTokenAmount(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n  prefix = '',\n  suffix = '',\n  precision = 2,\n  abbr = false,\n): string {\n  if (!account) {\n    return '';\n  }\n\n  return `${[prefix]}${formatAmount(\n    fromLamports(account, mint, rate),\n    precision,\n    abbr,\n  )}${suffix}`;\n}\n\nexport const formatUSD = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n});\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n};\n\nexport const formatPct = new Intl.NumberFormat('en-US', {\n  style: 'percent',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport function convert(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  let result = (amount / precision) * rate;\n\n  return result;\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import { sleep, useLocalStorageState } from \"../utils/utils\";\nimport {\n  Keypair,\n  Commitment,\n  Connection,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n  Blockhash,\n  FeeCalculator,\n} from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport { notify } from \"../utils/notifications\";\nimport { ExplorerLink } from \"../components/ExplorerLink\";\nimport {\n  TokenInfo,\n  TokenListProvider,\n  ENV as ChainId,\n} from \"@solana/spl-token-registry\";\nimport { WalletSigner } from \"./WalletContext/WalletContext\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport type ENV = \"mainnet-beta\" | \"testnet\" | \"devnet\" | \"localnet\";\n\nexport const ENDPOINTS = [\n  {\n    name: \"mainnet-beta\" as ENV,\n    endpoint: \"https://api.mainnet-beta.solana.com\",\n    ChainId: ChainId.MainnetBeta,\n  },\n  {\n    name: \"devnet\" as ENV,\n    endpoint: \"https://api.devnet.solana.com\",\n    ChainId: ChainId.Devnet,\n  },\n];\n\nconst DEFAULT = ENDPOINTS[0].endpoint;\n\ninterface ConnectionConfig {\n  connection: Connection;\n  endpoint: string;\n  env: ENV;\n  setEndpoint: (val: string) => void;\n  tokens: TokenInfo[];\n  tokenMap: Map<string, TokenInfo>;\n}\n\nconst ConnectionContext = React.createContext<ConnectionConfig>({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map<string, TokenInfo>(),\n});\n\nexport function ConnectionProvider({ children = undefined as any }) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\n    \"connectionEndpoint\",\n    ENDPOINTS[0].endpoint\n  );\n\n  const connection = useMemo(\n    () => new Connection(endpoint, \"recent\"),\n    [endpoint]\n  );\n\n  const env =\n    ENDPOINTS.find((end) => end.endpoint === endpoint)?.name ||\n    ENDPOINTS[0].name;\n\n  const [tokens, setTokens] = useState<TokenInfo[]>([]);\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n  useEffect(() => {\n    // fetch token files\n    new TokenListProvider().resolve().then((container) => {\n      const list = container\n        .excludeByTag(\"nft\")\n        .filterByChainId(\n          ENDPOINTS.find((end) => end.endpoint === endpoint)?.ChainId ||\n            ChainId.MainnetBeta\n        )\n        .getList();\n\n      const knownMints = [...list].reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map<string, TokenInfo>());\n\n      setTokenMap(knownMints);\n      setTokens(list);\n    });\n  }, [env, endpoint]);\n\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n  useEffect(() => {\n    const id = connection.onAccountChange(\n      Keypair.generate().publicKey,\n      () => {}\n    );\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n\n  return (\n    <ConnectionContext.Provider\n      value={{\n        endpoint,\n        setEndpoint,\n        connection,\n        tokens,\n        tokenMap,\n        env,\n      }}\n    >\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection() {\n  return useContext(ConnectionContext).connection as Connection;\n}\n\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap,\n  };\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach((log) => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[][],\n  signers: Keypair[][]\n) {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength: any = null;\n  let toRemoveSigners: Record<number, boolean> = {};\n\n \n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          \"single\"\n        );\n        stopPoint = 1;\n      } else {\n        stopPoint = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          SequenceType.StopOnFailure,\n          \"single\"\n        );\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      \"Died on \",\n      stopPoint,\n      \"retrying from instruction\",\n      instructions[stopPoint],\n      \"instructions length is\",\n      instructions.length\n    );\n    lastInstructionsLength = instructions.length;\n  }\n}\n\nexport const sendTransactions = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructionSet: TransactionInstruction[][],\n  signersSet: Keypair[][],\n  sequenceType: SequenceType = SequenceType.Parallel,\n  commitment: Commitment = \"singleGossip\",\n  successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n  failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n  block?: BlockhashAndFeeCalculator\n): Promise<number> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns: Transaction[] = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach((instruction) => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n  let breakEarlyObject = { breakEarly: false, i: 0 };\n  console.log(\n    \"Signed txns length\",\n    signedTxns.length,\n    \"vs handed in length\",\n    instructionSet.length\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    signedTxnPromise\n      .then(({ txid, slot }) => {\n        successCallback(txid, i);\n      })\n      .catch((reason) => {\n        // @ts-ignore\n        failCallback(signedTxns[i], i);\n        if (sequenceType === SequenceType.StopOnFailure) {\n          breakEarlyObject.breakEarly = true;\n          breakEarlyObject.i = i;\n        }\n      });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log(\"Caught failure\", e);\n        if (breakEarlyObject.breakEarly) {\n          console.log(\"Died on \", breakEarlyObject.i);\n          return breakEarlyObject.i; // Return the txn we failed on by index\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    await Promise.all(pendingTxns);\n  }\n\n  return signedTxns.length;\n};\n\nexport const sendTransaction = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  awaitConfirmation = true,\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment\n    );\n\n    if (!confirmation)\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n      notify({\n        message: \"Transaction failed...\",\n        description: (\n          <>\n            {errors.map((err) => (\n              <div>{err}</div>\n            ))}\n            <ExplorerLink address={txid} type=\"transaction\" />\n          </>\n        ),\n        type: \"error\",\n      });\n\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    try {\n      transaction = await wallet.signTransaction(transaction);\n    } catch {\n      return false;\n    }\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n  console.log(\"About to send\");\n  try {\n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n\n    return { txid, slot };\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    }\n  );\n\n  console.log(\"Started awaiting confirmation for\", txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      \"recent\",\n      true\n    );\n\n    if (!confirmation)\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error(\"Transaction failed: Custom instruction error\");\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    console.error(\"Timeout Error caught\", err);\n    if ((err as any).timeout) {\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, \"single\")\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith(\"Program log: \")) {\n            throw new Error(\n              \"Transaction failed: \" + line.slice(\"Program log: \".length)\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log(\"Latency\", txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString(\"base64\");\n  const config: any = { encoding: \"base64\", commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"simulateTransaction\", args);\n  if (res.error) {\n    throw new Error(\"failed to simulate transaction: \" + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = \"recent\",\n  queryStatus = false\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log(\"Rejecting for timeout...\");\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log(\"Rejected via websocket\", result.err);\n            reject(status);\n          } else {\n            console.log(\"Resolved via websocket\", result);\n            resolve(status);\n          }\n        },\n        commitment\n      );\n    } catch (e) {\n      done = true;\n      console.error(\"WS error in setup\", txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          console.log(`https://explorer.solana.com/tx/${txid}?cluster=mainnet-beta`); // TODO\n          if (!done) {\n            if (!status) {\n              console.log(\"REST null result for\", txid, status);\n            } else if (status.err) {\n              console.log(\"REST error for\", txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log(\"REST no confirmations for\", txid, status);\n            } else {\n              console.log(\"REST confirmation for\", txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log(\"REST connection error: txid\", txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log(\"Returning status\", status);\n  return status;\n}\n"],"sourceRoot":""}