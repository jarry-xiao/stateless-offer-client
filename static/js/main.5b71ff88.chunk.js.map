{"version":3,"sources":["contexts/AccountContext.tsx","actions/metadata.ts","actions/accept_offer.ts","utils/notifications.tsx","components/ExplorerLink/index.tsx","utils/eventEmitter.ts","components/Settings/index.tsx","components/DefaultModal/index.tsx","utils/account.ts","components/TransferBox/index.tsx","contexts/WalletContext/wallet.less","contexts/WalletContext/WalletContext.tsx","contexts/ModalContext.tsx","contexts/ColorModeContext.tsx","utils/ids.ts","utils/programIds.ts","components/ConnectButton.tsx","components/Header/Header.tsx","App.tsx","reportWebVitals.ts","index.tsx","utils/borsh.ts","constants/math.ts","utils/utils.ts","contexts/ConnectionContext.tsx"],"names":["AccountsContext","React","createContext","pendingCalls","Map","genericCache","pendingMintCalls","mintCache","getMintInfo","connection","pubKey","a","getAccountInfo","info","Error","data","Buffer","from","deserializeMint","TokenAccountParser","length","buffer","deserializeAccount","pubkey","account","keyToAccountParser","cache","emitter","EventEmitter","query","parser","id","PublicKey","address","toBase58","get","then","add","set","obj","isActive","deserialize","registerParser","delete","undefined","Function","isNew","has","raiseCacheUpdated","key","raiseCacheDeleted","byParser","result","keys","push","queryMint","mint","getMint","addMint","UseNativeAccount","useConnection","publicKey","useWallet","useState","nativeAccount","setNativeAccount","updateCache","useCallback","wrapped","WRAPPED_SOL_MINT","owner","amount","u64","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","wrapNativeAccount","useEffect","subId","updateAccount","onAccountChange","removeAccountChangeListener","PRECACHED_OWNERS","Set","precacheUserTokenAccounts","getTokenAccountsByOwner","programId","programIds","token","value","forEach","AccountsProvider","children","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","walletKey","selectUserAccounts","map","filter","accounts","subs","onCache","args","tokenSubID","onProgramAccountChange","accountId","accountInfo","AccountLayout","span","removeProgramAccountChangeListener","Provider","decode","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","MintLayout","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority","MetadataKey","MetadataCategory","METADATA_PREFIX","EDITION","MasterEditionV1","maxSupply","printingMint","oneTimePrintingAuthorizationMint","this","MasterEditionV2","EditionMarker","ledger","edition","editionOffset","indexOffset","Math","floor","positionInBitsetFromRight","mask","pow","Edition","parent","EditionV1","Creator","verified","share","Data","name","symbol","uri","sellerFeeBasisPoints","creators","Metadata","updateAuthority","primarySaleHappened","isMutable","editionNonce","masterEdition","MetadataV1","metadata","toPublicKey","createProgramAddress","toBuffer","Uint8Array","getEdition","CreateMetadataArgs","instruction","UpdateMetadataArgs","CreateMasterEditionArgs","MintPrintingTokensArgs","METADATA_SCHEMA","kind","fields","type","METADATA_REPLACE","RegExp","decodeMetadata","deserializeUnchecked","replace","tokenMint","PROGRAM_IDS","findProgramAddress","getTokenMetadata","TOKEN_METADATA_PROGRAM_ID","AcceptOfferArgs","hasMetadata","makerSize","takerSize","bumpSeed","schema","acceptOfferInstructionNoMetadata","makerWallet","takerWallet","makerSrc","makerDst","takerSrc","takerDst","makerSrcMint","takerSrcMint","transferAuthority","settings","serialize","isSigner","isWritable","TOKEN_PROGRAM_ID","NATIVE_MINT","SystemProgram","ix","TransactionInstruction","STATELESS_ASK_PROGRAM_ID","acceptOfferInstructionWithMetadata","additionalKeys","consolidateTokenAccounts","wallet","nonATAs","setNonATAs","notify","message","signers","instructions","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","tokenAccountMint","createAssociatedTokenAccountInstruction","size","transferIx","Token","createTransferInstruction","closeIx","createCloseAccountInstruction","Conn","sendTransactionWithRetry","changeOffer","mintA","mintB","sizeA","sizeB","setHasValidDelegate","setHasDelegate","approve","ataIx","tokenAccountMintA","tokenAccountMintB","toArray","authIx","createApproveInstruction","toNumber","createRevokeInstruction","trade","maker","metadataPubkey","meta","console","log","hasSellerMetadata","hasBuyerMetadata","makerAccountMintA","makerAccountMintB","takerAccountMintA","takerAccountMintB","hasATAMintB","bump","paidCreatorFees","tradeIx","response","nftMint","feeMint","creator","creatorPubkey","creatorTokenAccount","description","txid","placement","notification","style","color","opacity","backgroundColor","ExplorerLink","props","code","href","target","rel","title","Text","shortenAddress","CacheUpdateEvent","CacheDeleteEvent","MarketUpdateEvent","ids","Emitter","callback","on","removeListener","emit","Settings","additionalSettings","connected","disconnect","useConnectionConfig","setEndpoint","env","endpoint","setVisible","useWalletModal","open","setModal","useModal","theme","useTheme","colorModeCtx","useColorMode","handleConnect","ModalEnum","WALLET","sx","display","minWidth","marginBottom","onChange","e","ENDPOINTS","variant","onClick","marginLeft","navigator","clipboard","writeText","catch","ml","toggleColorMode","palette","mode","DefaultModal","bodyStyle","closeIcon","rest","background","borderRadius","flexDirection","alignItems","footer","width","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","SYSVAR_RENT_PUBKEY","MINTS","getSize","n","dec","decimals","parseFloat","displayFees","isSeller","formState","fees","getFees","isSellerNFT","feeAmount","isFeePayer","feePct","toFixed","side","marginTop","fontSize","textAlign","getDelegate","BN","getExplorerLink","url","window","TransferBox","URL","location","params","URLSearchParams","search","slice","defaultState","getDefaultFormState","setFormState","accountState","setAccountState","buyerAccountState","setBuyerAccountState","setMintCache","buyerLamports","setBuyerLamports","setIsSeller","validAmount","setValidAmount","hasDelegate","hasValidDelegate","openA","setOpenA","openB","setOpenB","anchorElA","setAnchorElA","anchorElB","setAnchorElB","openPopA","setOpenPopA","openPopB","setOpenPopB","inputClicked","setMetadata","tokenMap","setTokenMap","TokenListProvider","resolve","tokens","tokenList","filterByChainId","ENV","Devnet","getList","MainnetBeta","Testnet","reduce","item","validate","tokenAccount","totalAmount","fetchAccountState","sellerWallet","sellerMint","sellerTokenAccount","sellerTokenAccounts","badAccounts","buyerWallet","buyerMint","walletResult","buyerTokenAccount","buyerTokenAccounts","fetchMintState","mintString","mintData","getMetadata","setField","escape","newUrl","protocol","host","pathname","toString","history","pushState","path","getField","handleEnter","handlePopoverCloseA","handlePopoverCloseB","getTokenKeys","mintStr","onKeyPress","inputProps","placeholder","fullWidth","onKeyDown","stopPropagation","fontStyle","component","m","justifyContent","noValidate","autoComplete","w","focus","onMouseOver","currentTarget","onMouseOut","disabled","pointerEvents","anchorEl","anchorOrigin","vertical","horizontal","transformOrigin","onClose","height","required","label","labelId","input","onOpen","MenuProps","maxWidth","renderValue","selected","InputLabelProps","shrink","mintEntered","isConnected","isNaN","hasSufficientTokenBalance","hasSufficientLamports","LAMPORTS_PER_SOL","hasSufficientBalance","canTrade","canOpenOffer","canCancelOffer","marginRight","displayActions","WalletModalContext","useContext","WalletModal","wallets","select","visible","close","onCancel","verticalAlign","fontWeight","lineHeight","icon","alt","src","float","WalletModalProvider","setConnected","base58","keyToDisplay","substring","WalletProvider","useMemo","getPhantomWallet","getSolflareWallet","getTorusWallet","options","clientId","getLedgerWallet","getSolongWallet","getMathWallet","getSolletWallet","onError","error","autoConnect","ModalContext","removeModal","context","ColorModeContext","ColorModeContextProvider","setMode","prevMode","PubKeysInternedMap","BPF_UPGRADE_LOADER_ID","MEMO_ID","SYSTEM","associatedToken","bpf_upgrade_loader","system","memo","ConnectButton","onClickConnect","onClickChange","restProps","ButtonGroup","Header","handleChange","Box","bgcolor","flexGrow","getWindowDimensions","innerWidth","innerHeight","App","windowDimensions","setWindowDimensions","handleResize","addEventListener","removeEventListener","useWindowDimensions","createTheme","className","position","ThemeProvider","CssBaseline","mt","px","alignSelf","alignContent","left","right","bottom","padding","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","BinaryReader","prototype","readPubkey","array","readFixedArray","BinaryWriter","writePubkey","writeFixedArray","readPubkeyAsString","encode","writePubkeyAsString","TEN","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","useLocalStorageState","storedState","localStorage","getItem","JSON","parse","setState","setLocalStorageState","newState","removeItem","setItem","stringify","seeds","agg","cached","parseInt","nonce","chars","chunks","Array","apply","ceil","_","index","currency","sleep","ms","Promise","setTimeout","ChainId","DEFAULT","ConnectionContext","Connection","ConnectionProvider","find","end","setTokens","container","list","excludeByTag","knownMints","Keypair","generate","onSlotChange","removeSlotChangeListener","SequenceType","getErrorForTransaction","confirmTransaction","getParsedConfirmedTransaction","tx","errors","logMessages","regex","exec","lastIndex","sendTransactionsWithManualRetry","stopPoint","tries","lastInstructionsLength","toRemoveSigners","instr","i","filteredSigners","sendTransactions","StopOnFailure","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","transaction","Transaction","recentBlockhash","blockhash","setSigners","s","partialSign","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","signedTxnPromise","sendSignedTransaction","signedTransaction","slot","reason","all","sendTransaction","awaitConfirmation","includesFeePayer","signTransaction","rawTransaction","skipPreflight","sendRawTransaction","awaitTransactionSignatureConfirmation","DEFAULT_TIMEOUT","confirmation","err","beforeSend","getUnixTs","Date","getTime","timeout","startTime","done","simulateResult","simulateTransaction","logs","line","startsWith","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","encoding","_rpcRequest","res","queryStatus","_rpcEndpoint","cfg","status","confirmations","reject","onSignature","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener"],"mappings":"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","file":"static/js/main.5b71ff88.chunk.js","sourcesContent":["import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n} from 'react';\nimport { useConnection } from './ConnectionContext';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\nimport { AccountLayout, MintInfo, MintLayout, u64 } from '@solana/spl-token';\nimport { TokenAccount } from '../models';\nimport { chunks } from '../utils/utils';\nimport { EventEmitter } from '../utils/eventEmitter';\nimport { StringPublicKey, WRAPPED_SOL_MINT } from '../utils/ids';\nimport { programIds } from '../utils/programIds';\n\nconst AccountsContext = React.createContext<any>(null);\n\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\nconst genericCache = new Map<string, ParsedAccountBase>();\nconst pendingMintCalls = new Map<string, Promise<MintInfo>>();\nconst mintCache = new Map<string, MintInfo>();\n\nexport interface ParsedAccountBase {\n  pubkey: StringPublicKey;\n  account: AccountInfo<Buffer>;\n  info: any; // TODO: change to unknown\n}\n\nexport type AccountParser = (\n  pubkey: StringPublicKey,\n  data: AccountInfo<Buffer>,\n) => ParsedAccountBase | undefined;\n\nexport interface ParsedAccount<T> extends ParsedAccountBase {\n  info: T;\n}\n\nconst getMintInfo = async (connection: Connection, pubKey: PublicKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n  if (info === null) {\n    throw new Error('Failed to find mint account');\n  }\n\n  const data = Buffer.from(info.data);\n\n  return deserializeMint(data);\n};\n\nexport const MintParser = (pubKey: string, info: AccountInfo<Buffer>) => {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeMint(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const TokenAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  // Sometimes a wrapped sol account gets closed, goes to 0 length,\n  // triggers an update over wss which triggers this guy to get called\n  // since your UI already logged that pubkey as a token account. Check for length.\n  if (info.data.length > 0) {\n    const buffer = Buffer.from(info.data);\n    const data = deserializeAccount(buffer);\n\n    const details = {\n      pubkey: pubKey,\n      account: {\n        ...info,\n      },\n      info: data,\n    } as TokenAccount;\n\n    return details;\n  }\n};\n\nexport const GenericAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  const buffer = Buffer.from(info.data);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: buffer,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const keyToAccountParser = new Map<string, AccountParser>();\n\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (\n    connection: Connection,\n    pubKey: string | PublicKey,\n    parser?: AccountParser,\n  ) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = genericCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    // TODO: refactor to use multiple accounts query with flush like behavior\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error('Account not found');\n      }\n\n      return cache.add(id, data, parser);\n    }) as Promise<TokenAccount>;\n    pendingCalls.set(address, query as any);\n\n    return query;\n  },\n  add: (\n    id: PublicKey | string,\n    obj: AccountInfo<Buffer>,\n    parser?: AccountParser,\n    isActive?: boolean | undefined | ((parsed: any) => boolean),\n  ) => {\n    const address = typeof id === 'string' ? id : id?.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n    if (!deserialize) {\n      throw new Error(\n        'Deserializer needs to be registered or passed as a parameter',\n      );\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(address, obj);\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;\n    else if (isActive instanceof Function) isActive = isActive(account);\n\n    const isNew = !genericCache.has(address);\n\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n    return false;\n  },\n\n  byParser: (parser: AccountParser) => {\n    const result: string[] = [];\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey: PublicKey | string, parser: AccountParser) => {\n    if (pubkey) {\n      const address = typeof pubkey === 'string' ? pubkey : pubkey?.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: async (connection: Connection, pubKey: string | PublicKey) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let mint = mintCache.get(address);\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingMintCalls.delete(address);\n\n      mintCache.set(address, data);\n      return data;\n    }) as Promise<MintInfo>;\n    pendingMintCalls.set(address, query as any);\n\n    return query;\n  },\n  getMint: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\n    const mint = deserializeMint(obj.data);\n    const id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  },\n};\n\nexport const useAccountsContext = () => {\n  const context = useContext(AccountsContext);\n\n  return context;\n};\n\nfunction wrapNativeAccount(\n  pubkey: string,\n  account?: AccountInfo<Buffer>,\n): TokenAccount | undefined {\n  if (!account) {\n    return undefined;\n  }\n\n  const key = new PublicKey(pubkey);\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: key,\n      mint: WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null,\n    },\n  };\n}\n\nexport const getCachedAccount = (\n  predicate: (account: TokenAccount) => boolean,\n) => {\n  for (const account of genericCache.values()) {\n    if (predicate(account)) {\n      return account as TokenAccount;\n    }\n  }\n};\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\n\n  const updateCache = useCallback(\n    account => {\n      if (publicKey) {\n        const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n        if (wrapped !== undefined) {\n          const id = publicKey.toBase58();\n          cache.registerParser(id, TokenAccountParser);\n          genericCache.set(id, wrapped as TokenAccount);\n          cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser, true);\n        }\n      }\n    },\n    [publicKey],\n  );\n\n  useEffect(() => {\n    let subId = 0;\n    const updateAccount = (account: AccountInfo<Buffer> | null) => {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    (async () => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      try {\n        const account = await connection.getAccountInfo(publicKey);\n        updateAccount(account);\n      } catch {\n        return;\n      }\n\n      subId = connection.onAccountChange(publicKey, updateAccount);\n    })();\n\n    return () => {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n\n  return { nativeAccount };\n};\n\nconst PRECACHED_OWNERS = new Set<string>();\nconst precacheUserTokenAccounts = async (\n  connection: Connection,\n  owner?: PublicKey,\n) => {\n  if (!owner) {\n    return;\n  }\n\n  // used for filtering account updates over websocket\n  PRECACHED_OWNERS.add(owner.toBase58());\n\n  // user accounts are updated via ws subscription\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token,\n  });\n\n  accounts.value.forEach(info => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({ children = null as any }) {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\n  const { nativeAccount } = UseNativeAccount();\n  const walletKey = publicKey?.toBase58();\n\n  const selectUserAccounts = useCallback(() => {\n    return cache\n      .byParser(TokenAccountParser)\n      .map(id => cache.get(id))\n      .filter(a => a && a.info.owner.toBase58() === walletKey)\n      .map(a => a as TokenAccount);\n  }, [walletKey]);\n\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(\n      a => a !== undefined,\n    ) as TokenAccount[];\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n\n  useEffect(() => {\n    const subs: number[] = [];\n    cache.emitter.onCache(args => {\n      if (args.isNew && args.isActive) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), info => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      });\n\n      // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n      const tokenSubID = connection.onProgramAccountChange(\n        programIds().token,\n        info => {\n          // TODO: fix type in web3.js\n          const id = info.accountId as unknown as string;\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n          if (info.accountInfo.data.length === AccountLayout.span) {\n            const data = deserializeAccount(info.accountInfo.data);\n\n            if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n              cache.add(id, info.accountInfo, TokenAccountParser);\n              setTokenAccounts(selectUserAccounts());\n            }\n          }\n        },\n        'singleGossip',\n      );\n\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n\n  return (\n    <AccountsContext.Provider\n      value={{\n        userAccounts,\n        nativeAccount,\n      }}\n    >\n      {children}\n    </AccountsContext.Provider>\n  );\n}\n\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount as AccountInfo<Buffer>,\n  };\n}\n\nexport const getMultipleAccounts = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const result = await Promise.all(\n    chunks(keys, 99).map(chunk =>\n      getMultipleAccountsCore(connection, chunk, commitment),\n    ),\n  );\n\n  const array = result\n    .map(\n      a =>\n        a.array.map(acc => {\n          if (!acc) {\n            return undefined;\n          }\n\n          const { data, ...rest } = acc;\n          const obj = {\n            ...rest,\n            data: Buffer.from(data[0], 'base64'),\n          } as AccountInfo<Buffer>;\n          return obj;\n        }) as AccountInfo<Buffer>[],\n    )\n    .flat();\n  return { keys, array };\n};\n\nconst getMultipleAccountsCore = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const args = connection._buildArgs([keys], commitment, 'base64');\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  if (unsafeRes.error) {\n    throw new Error(\n      'failed to get info about account ' + unsafeRes.error.message,\n    );\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\n    return { keys, array };\n  }\n\n  // TODO: fix\n  throw new Error();\n};\n\nexport function useMint(key?: string | PublicKey) {\n  const connection = useConnection();\n  const [mint, setMint] = useState<MintInfo>();\n\n  const id = typeof key === 'string' ? key : key?.toBase58();\n\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache\n      .query(connection, id, MintParser)\n      .then(acc => setMint(acc.info as any))\n      .catch(err => console.log(err));\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === id) {\n        cache\n          .query(connection, id, MintParser)\n          .then(mint => setMint(mint.info as any));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n\n  return mint;\n}\n\nexport function useAccount(pubKey?: PublicKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState<TokenAccount>();\n\n  const key = pubKey?.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache\n          .query(connection, key, TokenAccountParser)\n          .catch(err => console.log(err));\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n\n  return account;\n}\n\n// TODO: expose in spl package\nexport const deserializeAccount = (data: Buffer) => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n\n// TODO: expose in spl package\nexport const deserializeMint = (data: Buffer) => {\n  if (data.length !== MintLayout.span) {\n    throw new Error('Not a valid Mint');\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as MintInfo;\n};\n","import {\n    PublicKey,\n    SystemProgram,\n    SYSVAR_RENT_PUBKEY,\n    TransactionInstruction,\n  } from '@solana/web3.js';\n  import { programIds } from '../utils/programIds';\n  import { deserializeUnchecked, serialize } from 'borsh';\n  import BN from 'bn.js';\n  import { findProgramAddress, StringPublicKey, toPublicKey } from '../utils';\n  import { TOKEN_METADATA_PROGRAM_ID } from '../utils';\n\n  export const METADATA_PREFIX = 'metadata';\n  export const EDITION = 'edition';\n  export const RESERVATION = 'reservation';\n  \n  export const MAX_NAME_LENGTH = 32;\n  \n  export const MAX_SYMBOL_LENGTH = 10;\n  \n  export const MAX_URI_LENGTH = 200;\n  \n  export const MAX_CREATOR_LIMIT = 5;\n  \n  export const MAX_CREATOR_LEN = 32 + 1 + 1;\n  export const MAX_METADATA_LEN =\n    1 +\n    32 +\n    32 +\n    MAX_NAME_LENGTH +\n    MAX_SYMBOL_LENGTH +\n    MAX_URI_LENGTH +\n    MAX_CREATOR_LIMIT * MAX_CREATOR_LEN +\n    2 +\n    1 +\n    1 +\n    198;\n  \n  export const MAX_EDITION_LEN = 1 + 32 + 8 + 200;\n  \n  export const EDITION_MARKER_BIT_SIZE = 248;\n  \n  export enum MetadataKey {\n    Uninitialized = 0,\n    MetadataV1 = 4,\n    EditionV1 = 1,\n    MasterEditionV1 = 2,\n    MasterEditionV2 = 6,\n    EditionMarker = 7,\n  }\n  \n  export enum MetadataCategory {\n    Audio = 'audio',\n    Video = 'video',\n    Image = 'image',\n    VR = 'vr',\n    HTML = 'html',\n  }\n  \n  export type MetadataFile = {\n    uri: string;\n    type: string;\n  };\n  \n  export type FileOrString = MetadataFile | string;\n  \n  export type Attribute = {\n    trait_type?: string;\n    display_type?: string;\n    value: string | number;\n  };\n  \n  export interface IMetadataExtension {\n    name: string;\n    symbol: string;\n  \n    creators: Creator[] | null;\n    description: string;\n    // preview image absolute URI\n    image: string;\n    animation_url?: string;\n  \n    attributes?: Attribute[];\n  \n    // stores link to item on meta\n    external_url: string;\n  \n    seller_fee_basis_points: number;\n  \n    properties: {\n      files?: FileOrString[];\n      category: MetadataCategory;\n      maxSupply?: number;\n      creators?: {\n        address: string;\n        shares: number;\n      }[];\n    };\n  }\n  \n  export class MasterEditionV1 {\n    key: MetadataKey;\n    supply: BN;\n    maxSupply?: BN;\n    /// Can be used to mint tokens that give one-time permission to mint a single limited edition.\n    printingMint: StringPublicKey;\n    /// If you don't know how many printing tokens you are going to need, but you do know\n    /// you are going to need some amount in the future, you can use a token from this mint.\n    /// Coming back to token metadata with one of these tokens allows you to mint (one time)\n    /// any number of printing tokens you want. This is used for instance by Auction Manager\n    /// with participation NFTs, where we dont know how many people will bid and need participation\n    /// printing tokens to redeem, so we give it ONE of these tokens to use after the auction is over,\n    /// because when the auction begins we just dont know how many printing tokens we will need,\n    /// but at the end we will. At the end it then burns this token with token-metadata to\n    /// get the printing tokens it needs to give to bidders. Each bidder then redeems a printing token\n    /// to get their limited editions.\n    oneTimePrintingAuthorizationMint: StringPublicKey;\n  \n    constructor(args: {\n      key: MetadataKey;\n      supply: BN;\n      maxSupply?: BN;\n      printingMint: StringPublicKey;\n      oneTimePrintingAuthorizationMint: StringPublicKey;\n    }) {\n      this.key = MetadataKey.MasterEditionV1;\n      this.supply = args.supply;\n      this.maxSupply = args.maxSupply;\n      this.printingMint = args.printingMint;\n      this.oneTimePrintingAuthorizationMint =\n        args.oneTimePrintingAuthorizationMint;\n    }\n  }\n  \n  export class MasterEditionV2 {\n    key: MetadataKey;\n    supply: BN;\n    maxSupply?: BN;\n  \n    constructor(args: { key: MetadataKey; supply: BN; maxSupply?: BN }) {\n      this.key = MetadataKey.MasterEditionV2;\n      this.supply = args.supply;\n      this.maxSupply = args.maxSupply;\n    }\n  }\n  \n  export class EditionMarker {\n    key: MetadataKey;\n    ledger: number[];\n  \n    constructor(args: { key: MetadataKey; ledger: number[] }) {\n      this.key = MetadataKey.EditionMarker;\n      this.ledger = args.ledger;\n    }\n  \n    editionTaken(edition: number) {\n      const editionOffset = edition % EDITION_MARKER_BIT_SIZE;\n      const indexOffset = Math.floor(editionOffset / 8);\n  \n      if (indexOffset > 30) {\n        throw Error('bad index for edition');\n      }\n  \n      const positionInBitsetFromRight = 7 - (editionOffset % 8);\n  \n      const mask = Math.pow(2, positionInBitsetFromRight);\n  \n      const appliedMask = this.ledger[indexOffset] & mask;\n  \n      return appliedMask != 0;\n    }\n  }\n  \n  export class Edition {\n    key: MetadataKey;\n    /// Points at MasterEdition struct\n    parent: StringPublicKey;\n    /// Starting at 0 for master record, this is incremented for each edition minted.\n    edition: BN;\n  \n    constructor(args: {\n      key: MetadataKey;\n      parent: StringPublicKey;\n      edition: BN;\n    }) {\n      this.key = MetadataKey.EditionV1;\n      this.parent = args.parent;\n      this.edition = args.edition;\n    }\n  }\n  export class Creator {\n    address: StringPublicKey;\n    verified: boolean;\n    share: number;\n  \n    constructor(args: {\n      address: StringPublicKey;\n      verified: boolean;\n      share: number;\n    }) {\n      this.address = args.address;\n      this.verified = args.verified;\n      this.share = args.share;\n    }\n  }\n  \n  export class Data {\n    name: string;\n    symbol: string;\n    uri: string;\n    sellerFeeBasisPoints: number;\n    creators: Creator[] | null;\n    constructor(args: {\n      name: string;\n      symbol: string;\n      uri: string;\n      sellerFeeBasisPoints: number;\n      creators: Creator[] | null;\n    }) {\n      this.name = args.name;\n      this.symbol = args.symbol;\n      this.uri = args.uri;\n      this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;\n      this.creators = args.creators;\n    }\n  }\n  \n  export class Metadata {\n    key: MetadataKey;\n    updateAuthority: StringPublicKey;\n    mint: StringPublicKey;\n    data: Data;\n    primarySaleHappened: boolean;\n    isMutable: boolean;\n    editionNonce: number | null;\n  \n    // set lazy\n    masterEdition?: StringPublicKey;\n    edition?: StringPublicKey;\n  \n    constructor(args: {\n      updateAuthority: StringPublicKey;\n      mint: StringPublicKey;\n      data: Data;\n      primarySaleHappened: boolean;\n      isMutable: boolean;\n      editionNonce: number | null;\n    }) {\n      this.key = MetadataKey.MetadataV1;\n      this.updateAuthority = args.updateAuthority;\n      this.mint = args.mint;\n      this.data = args.data;\n      this.primarySaleHappened = args.primarySaleHappened;\n      this.isMutable = args.isMutable;\n      this.editionNonce = args.editionNonce ?? null;\n    }\n  \n    public async init() {\n      const metadata = toPublicKey(programIds().metadata);\n      if (this.editionNonce !== null) {\n        this.edition = (\n          await PublicKey.createProgramAddress(\n            [\n              Buffer.from(METADATA_PREFIX),\n              metadata.toBuffer(),\n              toPublicKey(this.mint).toBuffer(),\n              new Uint8Array([this.editionNonce || 0]),\n            ],\n            metadata,\n          )\n        ).toBase58();\n      } else {\n        this.edition = await getEdition(this.mint);\n      }\n      this.masterEdition = this.edition;\n    }\n  }\n  \n  class CreateMetadataArgs {\n    instruction: number = 0;\n    data: Data;\n    isMutable: boolean;\n  \n    constructor(args: { data: Data; isMutable: boolean }) {\n      this.data = args.data;\n      this.isMutable = args.isMutable;\n    }\n  }\n  class UpdateMetadataArgs {\n    instruction: number = 1;\n    data: Data | null;\n    // Not used by this app, just required for instruction\n    updateAuthority: StringPublicKey | null;\n    primarySaleHappened: boolean | null;\n    constructor(args: {\n      data?: Data;\n      updateAuthority?: string;\n      primarySaleHappened: boolean | null;\n    }) {\n      this.data = args.data ? args.data : null;\n      this.updateAuthority = args.updateAuthority ? args.updateAuthority : null;\n      this.primarySaleHappened = args.primarySaleHappened;\n    }\n  }\n  \n  class CreateMasterEditionArgs {\n    instruction: number = 10;\n    maxSupply: BN | null;\n    constructor(args: { maxSupply: BN | null }) {\n      this.maxSupply = args.maxSupply;\n    }\n  }\n  \n  class MintPrintingTokensArgs {\n    instruction: number = 9;\n    supply: BN;\n  \n    constructor(args: { supply: BN }) {\n      this.supply = args.supply;\n    }\n  }\n  \n  export const METADATA_SCHEMA = new Map<any, any>([\n    [\n      CreateMetadataArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['data', Data],\n          ['isMutable', 'u8'], // bool\n        ],\n      },\n    ],\n    [\n      UpdateMetadataArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['data', { kind: 'option', type: Data }],\n          ['updateAuthority', { kind: 'option', type: 'pubkeyAsString' }],\n          ['primarySaleHappened', { kind: 'option', type: 'u8' }],\n        ],\n      },\n    ],\n  \n    [\n      CreateMasterEditionArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['maxSupply', { kind: 'option', type: 'u64' }],\n        ],\n      },\n    ],\n    [\n      MintPrintingTokensArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['supply', 'u64'],\n        ],\n      },\n    ],\n    [\n      MasterEditionV1,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['supply', 'u64'],\n          ['maxSupply', { kind: 'option', type: 'u64' }],\n          ['printingMint', 'pubkeyAsString'],\n          ['oneTimePrintingAuthorizationMint', 'pubkeyAsString'],\n        ],\n      },\n    ],\n    [\n      MasterEditionV2,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['supply', 'u64'],\n          ['maxSupply', { kind: 'option', type: 'u64' }],\n        ],\n      },\n    ],\n    [\n      Edition,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['parent', 'pubkeyAsString'],\n          ['edition', 'u64'],\n        ],\n      },\n    ],\n    [\n      Data,\n      {\n        kind: 'struct',\n        fields: [\n          ['name', 'string'],\n          ['symbol', 'string'],\n          ['uri', 'string'],\n          ['sellerFeeBasisPoints', 'u16'],\n          ['creators', { kind: 'option', type: [Creator] }],\n        ],\n      },\n    ],\n    [\n      Creator,\n      {\n        kind: 'struct',\n        fields: [\n          ['address', 'pubkeyAsString'],\n          ['verified', 'u8'],\n          ['share', 'u8'],\n        ],\n      },\n    ],\n    [\n      Metadata,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['updateAuthority', 'pubkeyAsString'],\n          ['mint', 'pubkeyAsString'],\n          ['data', Data],\n          ['primarySaleHappened', 'u8'], // bool\n          ['isMutable', 'u8'], // bool\n        ],\n      },\n    ],\n    [\n      EditionMarker,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['ledger', [31]],\n        ],\n      },\n    ],\n  ]);\n  \n  // eslint-disable-next-line no-control-regex\n  const METADATA_REPLACE = new RegExp('\\u0000', 'g');\n  \n  export const decodeMetadata = (buffer: Buffer): Metadata => {\n    const metadata = deserializeUnchecked(\n      METADATA_SCHEMA,\n      Metadata,\n      buffer,\n    ) as Metadata;\n    metadata.data.name = metadata.data.name.replace(METADATA_REPLACE, '');\n    metadata.data.uri = metadata.data.uri.replace(METADATA_REPLACE, '');\n    metadata.data.symbol = metadata.data.symbol.replace(METADATA_REPLACE, '');\n    return metadata;\n  };\n  \n  export const decodeEditionMarker = (buffer: Buffer): EditionMarker => {\n    const editionMarker = deserializeUnchecked(\n      METADATA_SCHEMA,\n      EditionMarker,\n      buffer,\n    ) as EditionMarker;\n    return editionMarker;\n  };\n  \n  export const decodeEdition = (buffer: Buffer) => {\n    return deserializeUnchecked(METADATA_SCHEMA, Edition, buffer) as Edition;\n  };\n  \n  export const decodeMasterEdition = (\n    buffer: Buffer,\n  ): MasterEditionV1 | MasterEditionV2 => {\n    if (buffer[0] == MetadataKey.MasterEditionV1) {\n      return deserializeUnchecked(\n        METADATA_SCHEMA,\n        MasterEditionV1,\n        buffer,\n      ) as MasterEditionV1;\n    } else {\n      return deserializeUnchecked(\n        METADATA_SCHEMA,\n        MasterEditionV2,\n        buffer,\n      ) as MasterEditionV2;\n    }\n  };\n  \n  export async function updateMetadata(\n    data: Data | undefined,\n    newUpdateAuthority: string | undefined,\n    primarySaleHappened: boolean | null | undefined,\n    mintKey: StringPublicKey,\n    updateAuthority: StringPublicKey,\n    instructions: TransactionInstruction[],\n    metadataAccount?: StringPublicKey,\n  ) {\n    const metadataProgramId = programIds().metadata;\n  \n    metadataAccount =\n      metadataAccount ||\n      (\n        await findProgramAddress(\n          [\n            Buffer.from('metadata'),\n            toPublicKey(metadataProgramId).toBuffer(),\n            toPublicKey(mintKey).toBuffer(),\n          ],\n          toPublicKey(metadataProgramId),\n        )\n      )[0];\n  \n    const value = new UpdateMetadataArgs({\n      data,\n      updateAuthority: !newUpdateAuthority ? undefined : newUpdateAuthority,\n      primarySaleHappened:\n        primarySaleHappened === null || primarySaleHappened === undefined\n          ? null\n          : primarySaleHappened,\n    });\n    const txnData = Buffer.from(serialize(METADATA_SCHEMA, value));\n    const keys = [\n      {\n        pubkey: toPublicKey(metadataAccount),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(updateAuthority),\n        isSigner: true,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: toPublicKey(metadataProgramId),\n        data: txnData,\n      }),\n    );\n  \n    return metadataAccount;\n  }\n  \n  export async function createMetadata(\n    data: Data,\n    updateAuthority: StringPublicKey,\n    mintKey: StringPublicKey,\n    mintAuthorityKey: StringPublicKey,\n    instructions: TransactionInstruction[],\n    payer: StringPublicKey,\n  ) {\n    const metadataProgramId = programIds().metadata;\n  \n    const metadataAccount = (\n      await findProgramAddress(\n        [\n          Buffer.from('metadata'),\n          toPublicKey(metadataProgramId).toBuffer(),\n          toPublicKey(mintKey).toBuffer(),\n        ],\n        toPublicKey(metadataProgramId),\n      )\n    )[0];\n    console.log('Data', data);\n    const value = new CreateMetadataArgs({ data, isMutable: true });\n    const txnData = Buffer.from(serialize(METADATA_SCHEMA, value));\n  \n    const keys = [\n      {\n        pubkey: toPublicKey(metadataAccount),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(mintKey),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(mintAuthorityKey),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(payer),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(updateAuthority),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: toPublicKey(metadataProgramId),\n        data: txnData,\n      }),\n    );\n  \n    return metadataAccount;\n  }\n  \n  export async function createMasterEdition(\n    maxSupply: BN | undefined,\n    mintKey: StringPublicKey,\n    updateAuthorityKey: StringPublicKey,\n    mintAuthorityKey: StringPublicKey,\n    payer: StringPublicKey,\n    instructions: TransactionInstruction[],\n  ) {\n    const metadataProgramId = programIds().metadata;\n  \n    const metadataAccount = (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          toPublicKey(metadataProgramId).toBuffer(),\n          toPublicKey(mintKey).toBuffer(),\n        ],\n        toPublicKey(metadataProgramId),\n      )\n    )[0];\n  \n    const editionAccount = (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          toPublicKey(metadataProgramId).toBuffer(),\n          toPublicKey(mintKey).toBuffer(),\n          Buffer.from(EDITION),\n        ],\n        toPublicKey(metadataProgramId),\n      )\n    )[0];\n  \n    const value = new CreateMasterEditionArgs({ maxSupply: maxSupply || null });\n    const data = Buffer.from(serialize(METADATA_SCHEMA, value));\n  \n    const keys = [\n      {\n        pubkey: toPublicKey(editionAccount),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(mintKey),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(updateAuthorityKey),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(mintAuthorityKey),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(payer),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(metadataAccount),\n        isSigner: false,\n        isWritable: false,\n      },\n  \n      {\n        pubkey: programIds().token,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n  \n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: toPublicKey(metadataProgramId),\n        data,\n      }),\n    );\n  }\n  \n  export async function deprecatedMintNewEditionFromMasterEditionViaPrintingToken(\n    newMint: StringPublicKey,\n    tokenMint: StringPublicKey,\n    newMintAuthority: StringPublicKey,\n    printingMint: StringPublicKey,\n    authorizationTokenHoldingAccount: StringPublicKey,\n    burnAuthority: StringPublicKey,\n    updateAuthorityOfMaster: StringPublicKey,\n    reservationList: StringPublicKey | undefined,\n    instructions: TransactionInstruction[],\n    payer: StringPublicKey,\n  ) {\n    const metadataProgramId = programIds().metadata;\n  \n    const newMetadataKey = await getMetadata(newMint);\n    const masterMetadataKey = await getMetadata(tokenMint);\n    const newEdition = await getEdition(newMint);\n    const masterEdition = await getEdition(tokenMint);\n  \n    const data = Buffer.from([3]);\n  \n    const keys = [\n      {\n        pubkey: toPublicKey(newMetadataKey),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(newEdition),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(masterEdition),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(newMint),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(newMintAuthority),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(printingMint),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(authorizationTokenHoldingAccount),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(burnAuthority),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(payer),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(updateAuthorityOfMaster),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(masterMetadataKey),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: programIds().token,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n  \n    if (reservationList) {\n      keys.push({\n        pubkey: toPublicKey(reservationList),\n        isSigner: false,\n        isWritable: true,\n      });\n    }\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: toPublicKey(metadataProgramId),\n        data,\n      }),\n    );\n  }\n  \n  export async function mintNewEditionFromMasterEditionViaToken(\n    newMint: StringPublicKey,\n    tokenMint: StringPublicKey,\n    newMintAuthority: StringPublicKey,\n    newUpdateAuthority: StringPublicKey,\n    tokenOwner: StringPublicKey,\n    tokenAccount: StringPublicKey,\n    instructions: TransactionInstruction[],\n    payer: StringPublicKey,\n    edition: BN,\n  ) {\n    const metadataProgramId = programIds().metadata;\n  \n    const newMetadataKey = await getMetadata(newMint);\n    const masterMetadataKey = await getMetadata(tokenMint);\n    const newEdition = await getEdition(newMint);\n    const masterEdition = await getEdition(tokenMint);\n    const editionMarkPda = await getEditionMarkPda(tokenMint, edition);\n  \n    const data = Buffer.from([11, ...edition.toArray('le', 8)]);\n  \n    const keys = [\n      {\n        pubkey: toPublicKey(newMetadataKey),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(newEdition),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(masterEdition),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(newMint),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(editionMarkPda),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(newMintAuthority),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(payer),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(tokenOwner),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(tokenAccount),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(newUpdateAuthority),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(masterMetadataKey),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: programIds().token,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n  \n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: toPublicKey(metadataProgramId),\n        data,\n      }),\n    );\n  }\n  \n  export async function updatePrimarySaleHappenedViaToken(\n    metadata: StringPublicKey,\n    owner: StringPublicKey,\n    tokenAccount: StringPublicKey,\n    instructions: TransactionInstruction[],\n  ) {\n    const metadataProgramId = programIds().metadata;\n  \n    const data = Buffer.from([4]);\n  \n    const keys = [\n      {\n        pubkey: toPublicKey(metadata),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(owner),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(tokenAccount),\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: toPublicKey(metadataProgramId),\n        data,\n      }),\n    );\n  }\n  \n  export async function deprecatedCreateReservationList(\n    metadata: StringPublicKey,\n    masterEdition: StringPublicKey,\n    resource: StringPublicKey,\n    updateAuthority: StringPublicKey,\n    payer: StringPublicKey,\n    instructions: TransactionInstruction[],\n  ) {\n    const metadataProgramId = programIds().metadata;\n  \n    const reservationList = await deprecatedGetReservationList(\n      masterEdition,\n      resource,\n    );\n    const data = Buffer.from([6]);\n  \n    const keys = [\n      {\n        pubkey: toPublicKey(reservationList),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(payer),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(updateAuthority),\n        isSigner: true,\n        isWritable: false,\n      },\n  \n      {\n        pubkey: toPublicKey(masterEdition),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(resource),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(metadata),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: toPublicKey(metadataProgramId),\n        data,\n      }),\n    );\n  }\n  \n  export async function signMetadata(\n    metadata: StringPublicKey,\n    creator: StringPublicKey,\n    instructions: TransactionInstruction[],\n  ) {\n    const metadataProgramId = programIds().metadata;\n  \n    const data = Buffer.from([7]);\n  \n    const keys = [\n      {\n        pubkey: toPublicKey(metadata),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(creator),\n        isSigner: true,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: toPublicKey(metadataProgramId),\n        data,\n      }),\n    );\n  }\n  \n  export async function deprecatedMintPrintingTokens(\n    destination: StringPublicKey,\n    printingMint: StringPublicKey,\n    updateAuthority: StringPublicKey,\n    metadata: StringPublicKey,\n    masterEdition: StringPublicKey,\n    supply: BN,\n    instructions: TransactionInstruction[],\n  ) {\n    const PROGRAM_IDS = programIds();\n    const metadataProgramId = PROGRAM_IDS.metadata;\n  \n    const value = new MintPrintingTokensArgs({ supply });\n    const data = Buffer.from(serialize(METADATA_SCHEMA, value));\n  \n    const keys = [\n      {\n        pubkey: toPublicKey(destination),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(printingMint),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(updateAuthority),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(metadata),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: toPublicKey(masterEdition),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: PROGRAM_IDS.token,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: toPublicKey(metadataProgramId),\n        data,\n      }),\n    );\n  }\n  \n  export async function convertMasterEditionV1ToV2(\n    masterEdition: StringPublicKey,\n    oneTimeAuthMint: StringPublicKey,\n    printingMint: StringPublicKey,\n    instructions: TransactionInstruction[],\n  ) {\n    const metadataProgramId = programIds().metadata;\n  \n    const data = Buffer.from([12]);\n  \n    const keys = [\n      {\n        pubkey: toPublicKey(masterEdition),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(oneTimeAuthMint),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: toPublicKey(printingMint),\n        isSigner: false,\n        isWritable: true,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: toPublicKey(metadataProgramId),\n        data,\n      }),\n    );\n  }\n  \n  export async function getEdition(\n    tokenMint: StringPublicKey,\n  ): Promise<StringPublicKey> {\n    const PROGRAM_IDS = programIds();\n  \n    return (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          toPublicKey(PROGRAM_IDS.metadata).toBuffer(),\n          toPublicKey(tokenMint).toBuffer(),\n          Buffer.from(EDITION),\n        ],\n        toPublicKey(PROGRAM_IDS.metadata),\n      )\n    )[0];\n  }\n  \n  export async function getMetadata(\n    tokenMint: StringPublicKey,\n  ): Promise<StringPublicKey> {\n    const PROGRAM_IDS = programIds();\n  \n    return (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          toPublicKey(PROGRAM_IDS.metadata).toBuffer(),\n          toPublicKey(tokenMint).toBuffer(),\n        ],\n        toPublicKey(PROGRAM_IDS.metadata),\n      )\n    )[0];\n  }\n  \n  export async function deprecatedGetReservationList(\n    masterEdition: StringPublicKey,\n    resource: StringPublicKey,\n  ): Promise<StringPublicKey> {\n    const PROGRAM_IDS = programIds();\n  \n    return (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          toPublicKey(PROGRAM_IDS.metadata).toBuffer(),\n          toPublicKey(masterEdition).toBuffer(),\n          Buffer.from(RESERVATION),\n          toPublicKey(resource).toBuffer(),\n        ],\n        toPublicKey(PROGRAM_IDS.metadata),\n      )\n    )[0];\n  }\n  \n  export async function getEditionMarkPda(\n    mint: StringPublicKey,\n    edition: BN,\n  ): Promise<StringPublicKey> {\n    const PROGRAM_IDS = programIds();\n    const editionNumber = Math.floor(edition.toNumber() / 248);\n  \n    return (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          toPublicKey(PROGRAM_IDS.metadata).toBuffer(),\n          toPublicKey(mint).toBuffer(),\n          Buffer.from(EDITION),\n          Buffer.from(editionNumber.toString()),\n        ],\n        toPublicKey(PROGRAM_IDS.metadata),\n      )\n    )[0];\n  }\n\nexport const getTokenMetadata = async (\n    mint: PublicKey,\n  ) => {\n    return (\n      await PublicKey.findProgramAddress(\n        [\n          Buffer.from('metadata'),\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n          mint.toBuffer(),\n        ],\n        TOKEN_METADATA_PROGRAM_ID,\n      )\n    )[0];\n  };","import {\n  SystemProgram,\n  TransactionInstruction,\n  PublicKey,\n  Keypair,\n} from \"@solana/web3.js\";\nimport { Connection as Conn } from \"../contexts\";\nimport BN, { min } from \"bn.js\";\nimport {\n  notify,\n  createAssociatedTokenAccountInstruction,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from \"../utils\";\nimport { Schema, serialize } from \"borsh\";\nimport { TOKEN_PROGRAM_ID, Token, NATIVE_MINT } from \"@solana/spl-token\";\nimport { STATELESS_ASK_PROGRAM_ID, TOKEN_METADATA_PROGRAM_ID } from \"../utils/\";\nimport { decodeMetadata, getTokenMetadata } from \"./metadata\";\n\nexport class AcceptOfferArgs {\n  instruction: number = 0;\n  hasMetadata: boolean;\n  makerSize: BN;\n  takerSize: BN;\n  bumpSeed: number;\n\n  static schema: Schema = new Map([\n    [\n      AcceptOfferArgs,\n      {\n        kind: \"struct\",\n        fields: [\n          [\"instruction\", \"u8\"],\n          [\"hasMetadata\", \"u8\"],\n          [\"makerSize\", \"u64\"],\n          [\"takerSize\", \"u64\"],\n          [\"bumpSeed\", \"u8\"],\n        ],\n      },\n    ],\n  ]);\n\n  constructor(args: {\n    hasMetadata: boolean;\n    makerSize: BN;\n    takerSize: BN;\n    bumpSeed: number;\n  }) {\n    this.hasMetadata = args.hasMetadata;\n    this.makerSize = args.makerSize;\n    this.takerSize = args.takerSize;\n    this.bumpSeed = args.bumpSeed;\n  }\n}\n\nexport const acceptOfferInstructionNoMetadata = async (\n  makerWallet: PublicKey,\n  takerWallet: PublicKey,\n  makerSrc: PublicKey,\n  makerDst: PublicKey,\n  takerSrc: PublicKey,\n  takerDst: PublicKey,\n  makerSrcMint: PublicKey,\n  takerSrcMint: PublicKey,\n  transferAuthority: PublicKey,\n  makerSize: BN,\n  takerSize: BN,\n  bumpSeed: number\n) => {\n  let settings = new AcceptOfferArgs({\n    hasMetadata: false,\n    makerSize,\n    takerSize,\n    bumpSeed,\n  });\n  const data = Buffer.from(serialize(AcceptOfferArgs.schema, settings));\n  let keys = [\n    {\n      pubkey: makerWallet,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: takerWallet,\n      isSigner: true,\n      isWritable: false,\n    },\n    {\n      pubkey: makerSrc,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: makerDst,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: takerSrc,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: takerDst,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: makerSrcMint,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: takerSrcMint,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: transferAuthority,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  if (takerSrcMint.toBase58() === NATIVE_MINT.toBase58()) {\n    keys.push({\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    });\n  }\n  return {\n    ix: [\n      new TransactionInstruction({\n        keys,\n        programId: STATELESS_ASK_PROGRAM_ID,\n        data,\n      }),\n    ],\n  };\n};\n\nexport const acceptOfferInstructionWithMetadata = async (\n  makerWallet: PublicKey,\n  takerWallet: PublicKey,\n  makerSrc: PublicKey,\n  makerDst: PublicKey,\n  takerSrc: PublicKey,\n  takerDst: PublicKey,\n  makerSrcMint: PublicKey,\n  takerSrcMint: PublicKey,\n  transferAuthority: PublicKey,\n  additionalKeys: any[],\n  makerSize: BN,\n  takerSize: BN,\n  bumpSeed: number\n) => {\n  let settings = new AcceptOfferArgs({\n    hasMetadata: true,\n    makerSize,\n    takerSize,\n    bumpSeed,\n  });\n  const data = Buffer.from(serialize(AcceptOfferArgs.schema, settings));\n  let keys = [\n    {\n      pubkey: makerWallet,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: takerWallet,\n      isSigner: true,\n      isWritable: false,\n    },\n    {\n      pubkey: makerSrc,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: makerDst,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: takerSrc,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: takerDst,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: makerSrcMint,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: takerSrcMint,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: transferAuthority,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  if (takerSrcMint.toBase58() === NATIVE_MINT.toBase58()) {\n    keys.push({\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    });\n  }\n  keys.push(...additionalKeys);\n  return {\n    ix: [\n      new TransactionInstruction({\n        keys,\n        programId: STATELESS_ASK_PROGRAM_ID,\n        data,\n      }),\n    ],\n  };\n};\n\nexport const consolidateTokenAccounts = async (\n  connection,\n  mint: PublicKey,\n  wallet: any,\n  nonATAs: any[],\n  setNonATAs: any\n) => {\n  if (!wallet.publicKey) {\n    notify({ message: \"Wallet not connected!\" });\n    return false;\n  }\n  let signers: Keypair[] = [];\n  let instructions: TransactionInstruction[] = [];\n  const tokenAccountMint = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n  createAssociatedTokenAccountInstruction(\n    instructions,\n    tokenAccountMint,\n    wallet.publicKey,\n    wallet.publicKey,\n    mint\n  );\n  for (const { pubkey, size } of nonATAs) {\n    const transferIx = Token.createTransferInstruction(\n      TOKEN_PROGRAM_ID,\n      pubkey,\n      tokenAccountMint,\n      wallet.publicKey,\n      [],\n      size\n    );\n    const closeIx = Token.createCloseAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      pubkey,\n      wallet.publicKey,\n      wallet.publicKey,\n      []\n    );\n    instructions.push(...[transferIx, closeIx]);\n  }\n  const response = await Conn.sendTransactionWithRetry(\n    connection,\n    wallet,\n    [...instructions],\n    signers,\n    \"max\"\n  );\n  if (!response) {\n    notify({ message: \"Consolidation Failed\" });\n    return false;\n  } else {\n    notify({\n      message:\n        \"Successfully merged all token accounts into 1 Assoicated Token Account\",\n    });\n    setNonATAs([]);\n    return true;\n  }\n};\n\nexport const changeOffer = async (\n  connection,\n  mintA: PublicKey,\n  mintB: PublicKey,\n  sizeA: BN,\n  sizeB: BN,\n  wallet: any,\n  setHasValidDelegate: any,\n  setHasDelegate: any,\n  metadata,\n  approve = true\n) => {\n  if (!wallet.publicKey) {\n    notify({ message: \"Wallet not connected!\" });\n    return false;\n  }\n  let signers: Keypair[] = [];\n  let ataIx: TransactionInstruction[] = [];\n  const tokenAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintA.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintA = await connection.getAccountInfo(tokenAccountMintA);\n  if (!hasATAMintA) {\n    notify({ message: \"User must have ATA to create offer\" });\n    return false;\n  }\n\n  let tokenAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintB.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintB = await connection.getAccountInfo(tokenAccountMintB);\n  if (!hasATAMintB) {\n    createAssociatedTokenAccountInstruction(\n      ataIx,\n      tokenAccountMintB,\n      wallet.publicKey,\n      wallet.publicKey,\n      mintB\n    );\n  }\n  tokenAccountMintB =\n    mintB.toBase58() === NATIVE_MINT.toBase58()\n      ? wallet.publicKey\n      : tokenAccountMintB;\n\n  const transferAuthority = (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"stateless_offer\"),\n        wallet.publicKey.toBuffer(),\n        mintA.toBuffer(),\n        mintB.toBuffer(),\n        new Uint8Array(sizeA.toArray(\"le\", 8)),\n        new Uint8Array(sizeB.toArray(\"le\", 8)),\n      ],\n      STATELESS_ASK_PROGRAM_ID\n    )\n  )[0];\n  let authIx;\n  if (approve) {\n    authIx = Token.createApproveInstruction(\n      TOKEN_PROGRAM_ID,\n      tokenAccountMintA,\n      transferAuthority,\n      wallet.publicKey,\n      [],\n      sizeA.toNumber()\n    );\n  } else {\n    authIx = Token.createRevokeInstruction(\n      TOKEN_PROGRAM_ID,\n      tokenAccountMintA,\n      wallet.publicKey,\n      []\n    );\n  }\n  const response = await Conn.sendTransactionWithRetry(\n    connection,\n    wallet,\n    [...ataIx, authIx],\n    signers,\n    \"max\"\n  );\n  if (!response) {\n    notify({ message: \"Delegation transaction failed\" });\n    return false;\n  } else {\n    if (approve) {\n      setHasDelegate(true);\n      setHasValidDelegate(true);\n      notify({\n        message: `Successfully assigned delegate (${transferAuthority.toBase58()})`,\n      });\n    } else {\n      setHasDelegate(false);\n      notify({\n        message: `Successfully removed delegate (${transferAuthority.toBase58()})`,\n      });\n    }\n    return true;\n  }\n};\n\nexport const trade = async (\n  connection,\n  maker: PublicKey,\n  mintA: PublicKey,\n  mintB: PublicKey,\n  sizeA: BN,\n  sizeB: BN,\n  metadata,\n  setHasValidDelegate,\n  wallet: any\n) => {\n  for (const mint of [mintA.toBase58(), mintB.toBase58()]) {\n    if (!(mint in metadata)) {\n      let metadataPubkey: any = await getTokenMetadata(new PublicKey(mint));\n      try {\n        let result = await connection.getAccountInfo(metadataPubkey);\n        if (result) {\n          try {\n            const meta: any = decodeMetadata(result.data);\n            metadata[mint] = { pubkey: metadataPubkey, account: meta };\n          } catch {\n            console.log(\"Failed to decode metadata for mint:\", mint);\n          }\n        }\n      } catch {\n        notify({ message: \"Network request to fetch mint metadata failed\" });\n        return false;\n      }\n    }\n  }\n\n  let hasSellerMetadata = mintA.toBase58() in metadata;\n  let hasBuyerMetadata = mintB.toBase58() in metadata;\n\n  if (!wallet.publicKey) {\n    notify({ message: \"Wallet not connected!\" });\n    return false;\n  }\n  let signers: Keypair[] = [];\n  let ataIx: TransactionInstruction[] = [];\n\n  const makerAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [maker.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintA.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  if (!(await connection.getAccountInfo(makerAccountMintA))) {\n    notify({ message: \"Maker must have ATA for mint A\" });\n    return false;\n  }\n\n  let makerAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [maker.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintB.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  if (!(await connection.getAccountInfo(makerAccountMintB))) {\n    notify({ message: \"Maker must have ATA for mint B\" });\n    return false;\n  }\n\n  const takerAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintA.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintA = await connection.getAccountInfo(takerAccountMintA);\n  if (!hasATAMintA) {\n    createAssociatedTokenAccountInstruction(\n      ataIx,\n      takerAccountMintA,\n      wallet.publicKey,\n      wallet.publicKey,\n      mintA\n    );\n  }\n\n  let takerAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintB.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintB = await connection.getAccountInfo(\n    new PublicKey(takerAccountMintB)\n  );\n\n  const isNative = mintB.toBase58() === NATIVE_MINT.toBase58();\n  if (!hasATAMintB && !isNative) {\n    notify({ message: \"Taker must have ATA for mint B\" });\n    return false;\n  }\n\n  makerAccountMintB = isNative ? maker : makerAccountMintB;\n  takerAccountMintB = isNative ? wallet.publicKey : takerAccountMintB;\n  const [transferAuthority, bump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"stateless_offer\"),\n      maker.toBuffer(),\n      mintA.toBuffer(),\n      mintB.toBuffer(),\n      new Uint8Array(sizeA.toArray(\"le\", 8)),\n      new Uint8Array(sizeB.toArray(\"le\", 8)),\n    ],\n    STATELESS_ASK_PROGRAM_ID\n  );\n\n  let response;\n  let paidCreatorFees = \"\";\n  if (!hasBuyerMetadata && !hasSellerMetadata) {\n    let { ix } = await acceptOfferInstructionNoMetadata(\n      maker,\n      wallet.publicKey,\n      makerAccountMintA,\n      makerAccountMintB,\n      takerAccountMintB,\n      takerAccountMintA,\n      mintA,\n      mintB,\n      transferAuthority,\n      sizeA,\n      sizeB,\n      bump\n    );\n    const tradeIx = ix;\n    console.log(\"Executing trade (pure swap)\");\n    response = await Conn.sendTransactionWithRetry(\n      connection,\n      wallet,\n      [...ataIx, ...tradeIx],\n      signers,\n      \"max\"\n    );\n  } else if (metadata) {\n    try {\n      let nftMint;\n      let feeMint;\n      if (mintA.toBase58() in metadata) {\n        nftMint = mintA;\n        feeMint = mintB;\n      } else if (mintB.toBase58() in metadata) {\n        nftMint = mintB;\n        feeMint = mintA;\n      } else {\n        notify({ message: \"Neither seller or buyer mint has valid metadata\" });\n        return false;\n      }\n\n      let additionalKeys: any[] = [];\n      const creators = metadata[nftMint.toBase58()].account.data.creators;\n      if (!creators) {\n        notify({\n          message:\n            \"Trade transaction failed: specified metadata has invalid creators\",\n        });\n        return false;\n      }\n      const metadataPubkey = metadata[nftMint.toBase58()].pubkey;\n      if (!metadataPubkey) {\n        notify({\n          message: \"Trade transaction failed: metadata account is undefined\",\n        });\n        return false;\n      }\n      additionalKeys.push({\n        pubkey: metadataPubkey,\n        isSigner: false,\n        isWritable: false,\n      });\n      for (const creator of creators) {\n        const creatorPubkey = new PublicKey(creator.address);\n        additionalKeys.push({\n          pubkey: creatorPubkey,\n          isSigner: false,\n          isWritable: true,\n        });\n        if (!isNative) {\n          let creatorTokenAccount = (\n            await PublicKey.findProgramAddress(\n              [\n                creatorPubkey.toBuffer(),\n                TOKEN_PROGRAM_ID.toBuffer(),\n                feeMint.toBuffer(),\n              ],\n              SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n            )\n          )[0];\n          const hasATACreator = await connection.getAccountInfo(\n            creatorTokenAccount\n          );\n          if (!hasATACreator) {\n            createAssociatedTokenAccountInstruction(\n              ataIx,\n              creatorTokenAccount,\n              wallet.publicKey,\n              creatorPubkey,\n              feeMint\n            );\n          }\n          additionalKeys.push({\n            pubkey: creatorTokenAccount,\n            isSigner: false,\n            isWritable: true,\n          });\n        }\n      }\n      let { ix } = await acceptOfferInstructionWithMetadata(\n        maker,\n        wallet.publicKey,\n        makerAccountMintA,\n        makerAccountMintB,\n        takerAccountMintB,\n        takerAccountMintA,\n        mintA,\n        mintB,\n        transferAuthority,\n        additionalKeys,\n        sizeA,\n        sizeB,\n        bump\n      );\n      const tradeIx = ix;\n      console.log(\"Executing trade (metadata and creators supplied)\");\n      response = await Conn.sendTransactionWithRetry(\n        connection,\n        wallet,\n        [...ataIx, ...tradeIx],\n        signers,\n        \"max\"\n      );\n      paidCreatorFees = \" (Creator Fees Paid)\";\n    } catch (e) {\n      console.log(e);\n      console.log(\"Encountered error while processing metadata\");\n    }\n  }\n\n  if (!response) {\n    notify({ message: \"Trade transaction failed\" });\n    return false;\n  } else {\n    notify({ message: `Trade successful${paidCreatorFees}` });\n    setHasValidDelegate(false);\n    return true;\n  }\n};\n","import React from 'react';\nimport { notification } from 'antd';\n// import Link from '../components/Link';\n\nexport function notify({\n  message = '',\n  description = undefined as any,\n  txid = '',\n  type = 'info',\n  placement = 'bottomLeft',\n}) {\n  if (txid) {\n    //   <Link\n    //     external\n    //     to={'https://explorer.solana.com/tx/' + txid}\n    //     style={{ color: '#0000ff' }}\n    //   >\n    //     View transaction {txid.slice(0, 8)}...{txid.slice(txid.length - 8)}\n    //   </Link>\n\n    description = <></>;\n  }\n  (notification as any)[type]({\n    message: <span style={{ color: 'black' }}>{message}</span>,\n    description: (\n      <span style={{ color: 'black', opacity: 0.5 }}>{description}</span>\n    ),\n    placement,\n    style: {\n      backgroundColor: 'white',\n    },\n  });\n}\n","import React from 'react';\nimport { Typography } from 'antd';\nimport { shortenAddress } from '../../utils/utils';\nimport { PublicKey } from '@solana/web3.js';\n\nexport const ExplorerLink = (props: {\n  address: string | PublicKey;\n  type: string;\n  code?: boolean;\n  style?: React.CSSProperties;\n  length?: number;\n}) => {\n  const { type, code } = props;\n\n  const address =\n    typeof props.address === 'string'\n      ? props.address\n      : props.address?.toBase58();\n\n  if (!address) {\n    return null;\n  }\n\n  const length = props.length ?? 9;\n\n  return (\n    <a\n      href={`https://explorer.solana.com/${type}/${address}`}\n      target=\"_blank\"\n      rel=\"noreferrer\"\n      title={address}\n      style={props.style}\n    >\n      {code ? (\n        <Typography.Text style={props.style} code>\n          {shortenAddress(address, length)}\n        </Typography.Text>\n      ) : (\n        shortenAddress(address, length)\n      )}\n    </a>\n  );\n};\n","import { EventEmitter as Emitter } from 'eventemitter3';\n\nexport class CacheUpdateEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  parser: any;\n  isNew: boolean;\n  isActive: boolean;\n  constructor(id: string, isNew: boolean, parser: any, isActive: boolean) {\n    this.id = id;\n    this.parser = parser;\n    this.isNew = isNew;\n    this.isActive = isActive;\n  }\n}\n\nexport class CacheDeleteEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n\nexport class MarketUpdateEvent {\n  static type = 'MarketUpdate';\n  ids: Set<string>;\n  constructor(ids: Set<string>) {\n    this.ids = ids;\n  }\n}\n\nexport class EventEmitter {\n  private emitter = new Emitter();\n\n  onMarket(callback: (args: MarketUpdateEvent) => void) {\n    this.emitter.on(MarketUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(MarketUpdateEvent.type, callback);\n  }\n\n  onCache(callback: (args: CacheUpdateEvent) => void) {\n    this.emitter.on(CacheUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(CacheUpdateEvent.type, callback);\n  }\n\n  raiseMarketUpdated(ids: Set<string>) {\n    this.emitter.emit(MarketUpdateEvent.type, new MarketUpdateEvent(ids));\n  }\n\n  raiseCacheUpdated(\n    id: string,\n    isNew: boolean,\n    parser: any,\n    isActive: boolean,\n  ) {\n    this.emitter.emit(\n      CacheUpdateEvent.type,\n      new CacheUpdateEvent(id, isNew, parser, isActive),\n    );\n  }\n\n  raiseCacheDeleted(id: string) {\n    this.emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));\n  }\n}\n","import { useCallback } from \"react\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { ENDPOINTS, useColorMode, useConnectionConfig } from \"../../contexts\";\nimport { notify, shortenAddress } from \"../../utils\";\nimport { CopyOutlined } from \"@ant-design/icons\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport { Box } from \"@mui/system\";\nimport { Button, FormControl, NativeSelect } from \"@mui/material\";\nimport { useTheme } from \"@mui/material/styles\";\nimport IconButton from \"@mui/material/IconButton\";\nimport Brightness4Icon from \"@mui/icons-material/Brightness4\";\nimport Brightness7Icon from \"@mui/icons-material/Brightness7\";\n\nexport const Settings = ({\n  additionalSettings,\n}: {\n  additionalSettings?: JSX.Element;\n}) => {\n  const { connected, disconnect, publicKey } = useWallet();\n  const { setEndpoint, env, endpoint } = useConnectionConfig();\n  const { setVisible } = useWalletModal();\n  const open = useCallback(() => setVisible(true), [setVisible]);\n  const { setModal } = useModal();\n  const theme = useTheme();\n  const colorModeCtx = useColorMode();\n\n  const handleConnect = useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n\n  return (\n    <>\n      <Box sx={{ display: \"flex\", minWidth: \"100%\" }}>\n        {!connected && (\n          <>\n            <FormControl>\n              <NativeSelect\n                style={{ marginBottom: 5 }}\n                onChange={(e) => {\n                  setEndpoint(e.target.value);\n                }}\n                value={endpoint}\n              >\n                {ENDPOINTS.map(({ name, endpoint }) => (\n                  <option key={name} value={endpoint}>{name}</option>\n                ))}\n              </NativeSelect>\n            </FormControl>\n            <Button\n              variant=\"contained\"\n              onClick={handleConnect}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Connect\n            </Button>\n          </>\n        )}\n        {connected && (\n          <>\n            {publicKey && (\n              <Button\n                variant=\"outlined\"\n                onClick={async () => {\n                  if (publicKey) {\n                    await navigator.clipboard.writeText(publicKey.toBase58());\n                    notify({\n                      message: \"Wallet update\",\n                      description: \"Address copied to clipboard\",\n                    });\n                  }\n                }}\n              >\n                <CopyOutlined />\n                {shortenAddress(publicKey.toBase58())}\n              </Button>\n            )}\n            <Button\n              variant=\"outlined\"\n              onClick={open}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Change Wallet\n            </Button>\n            <Button\n              variant=\"contained\"\n              color=\"error\"\n              onClick={() => disconnect().catch()}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Disconnect ({env})\n            </Button>\n          </>\n        )}\n        <IconButton\n          sx={{ ml: 1 }}\n          onClick={colorModeCtx.toggleColorMode}\n          color=\"inherit\"\n        >\n          {theme.palette.mode === \"dark\" ? (\n            <Brightness7Icon />\n          ) : (\n            <Brightness4Icon />\n          )}\n        </IconButton>\n        {additionalSettings}\n      </Box>\n    </>\n  );\n};\n","import React from \"react\";\nimport { Modal } from \"antd\";\n\nimport \"./index.css\";\n\nexport const DefaultModal = (props: any) => {\n  const { children, closeIcon, bodyStyle, style, ...rest } = props;\n\n  return (\n    <Modal\n      style={{ background: \"transparent\", borderRadius: 16 }}\n      bodyStyle={{\n        background: \"#333333\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        ...bodyStyle,\n      }}\n      footer={null}\n      width={400}\n      {...rest}\n    >\n      {children}\n    </Modal>\n  );\n};\n","import { AccountLayout, MintLayout, Token } from '@solana/spl-token';\nimport {\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport {\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n  WRAPPED_SOL_MINT,\n} from '../utils/ids';\nimport { programIds } from '../utils/programIds';\nimport { TokenAccount } from '../models/account';\nimport { cache, TokenAccountParser } from '../contexts/AccountContext';\n\nexport function ensureSplAccount(\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  toCheck: TokenAccount,\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  if (!toCheck.info.isNative) {\n    return toCheck.pubkey;\n  }\n\n  const account = createUninitializedAccount(\n    instructions,\n    payer,\n    amount,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      WRAPPED_SOL_MINT,\n      account,\n      payer,\n    ),\n  );\n\n  cleanupInstructions.push(\n    Token.createCloseAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      account,\n      payer,\n      payer,\n      [],\n    ),\n  );\n\n  return account;\n}\n\nexport const DEFAULT_TEMP_MEM_SPACE = 65548;\n\nexport function createTempMemoryAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  signers: Keypair[],\n  owner: PublicKey,\n  space = DEFAULT_TEMP_MEM_SPACE,\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      // 0 will evict/close account since it cannot pay rent\n      lamports: 0,\n      space: space,\n      programId: owner,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createUninitializedMint(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: MintLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createUninitializedAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: AccountLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createAssociatedTokenAccountInstruction(\n  instructions: TransactionInstruction[],\n  associatedTokenAddress: PublicKey,\n  payer: PublicKey,\n  walletAddress: PublicKey,\n  splTokenMintAddress: PublicKey,\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  instructions.push(\n    new TransactionInstruction({\n      keys,\n      programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n      data: Buffer.from([]),\n    }),\n  );\n}\n\nexport function createMint(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  mintRentExempt: number,\n  decimals: number,\n  owner: PublicKey,\n  freezeAuthority: PublicKey,\n  signers: Keypair[],\n) {\n  const account = createUninitializedMint(\n    instructions,\n    payer,\n    mintRentExempt,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      account,\n      decimals,\n      owner,\n      freezeAuthority,\n    ),\n  );\n\n  return account;\n}\n\nexport function createMintFromAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  decimals: number,\n  owner: PublicKey,\n  freezeAuthority: PublicKey,\n  account: Keypair,\n) {\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: MintLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n  instructions.push(\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      account.publicKey,\n      decimals,\n      owner,\n      freezeAuthority,\n    ),\n  );\n  return account;\n}\n\nexport function createTokenAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  accountRentExempt: number,\n  mint: PublicKey,\n  owner: PublicKey,\n  signers: Keypair[],\n) {\n  const account = createUninitializedAccount(\n    instructions,\n    payer,\n    accountRentExempt,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, account, owner),\n  );\n\n  return account;\n}\n\nexport function ensureWrappedAccount(\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  toCheck: TokenAccount | undefined,\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  if (toCheck && !toCheck.info.isNative) {\n    return toCheck.pubkey;\n  }\n\n  const TOKEN_PROGRAM_ID = programIds().token;\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: AccountLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      WRAPPED_SOL_MINT,\n      account.publicKey,\n      payer,\n    ),\n  );\n\n  cleanupInstructions.push(\n    Token.createCloseAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      account.publicKey,\n      payer,\n      payer,\n      [],\n    ),\n  );\n\n  signers.push(account);\n\n  return account.publicKey.toBase58();\n}\n\n// TODO: check if one of to accounts needs to be native sol ... if yes unwrap it ...\nexport function findOrCreateAccountByMint(\n  payer: PublicKey,\n  owner: PublicKey,\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  accountRentExempt: number,\n  mint: PublicKey, // use to identify same type\n  signers: Keypair[],\n  excluded?: Set<string>,\n): PublicKey {\n  const accountToFind = mint.toBase58();\n  const ownerKey = owner.toBase58();\n  const account = cache\n    .byParser(TokenAccountParser)\n    .map(id => cache.get(id))\n    .find(\n      acc =>\n        acc !== undefined &&\n        acc.info.mint.toBase58() === accountToFind &&\n        acc.info.owner.toBase58() === ownerKey &&\n        (excluded === undefined || !excluded.has(acc.pubkey)),\n    );\n  const isWrappedSol = accountToFind === WRAPPED_SOL_MINT.toBase58();\n\n  let toAccount: PublicKey;\n  if (account && !isWrappedSol) {\n    toAccount = new PublicKey(account.pubkey);\n  } else {\n    // creating depositor pool account\n    toAccount = createTokenAccount(\n      instructions,\n      payer,\n      accountRentExempt,\n      mint,\n      owner,\n      signers,\n    );\n\n    if (isWrappedSol) {\n      cleanupInstructions.push(\n        Token.createCloseAccountInstruction(\n          TOKEN_PROGRAM_ID,\n          toAccount,\n          payer,\n          payer,\n          [],\n        ),\n      );\n    }\n  }\n\n  return toAccount;\n}","import { useEffect, useState } from \"react\";\nimport Box from \"@mui/material/Box\";\nimport Button from \"@mui/material/Button\";\nimport {\n  Select,\n  FormControl,\n  OutlinedInput,\n  InputLabel,\n  MenuItem,\n  Input,\n} from \"@mui/material\";\nimport LoadingButton from \"@mui/lab/LoadingButton\";\nimport TextField from \"@mui/material/TextField\";\nimport {\n  useConnection,\n  deserializeAccount,\n  deserializeMint,\n  useConnectionConfig,\n} from \"../../contexts\";\nimport { SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID } from \"../../utils\";\nimport { TOKEN_PROGRAM_ID, NATIVE_MINT } from \"@solana/spl-token\";\nimport {\n  changeOffer,\n  consolidateTokenAccounts,\n  trade,\n} from \"../../actions/accept_offer\";\nimport { LAMPORTS_PER_SOL, PublicKey } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { ENV, TokenInfo, TokenListProvider } from \"@solana/spl-token-registry\";\nimport Popover from \"@mui/material/Popover\";\nimport {\n  STATELESS_ASK_PROGRAM_ID,\n  TOKEN_METADATA_PROGRAM_ID,\n} from \"../../utils/\";\nimport {\n  decodeMetadata,\n  Metadata,\n  getTokenMetadata,\n} from \"../../actions/metadata\";\nimport \"./styles.css\"\n\nconst MINTS = [\"None\", \"SOL\", \"USDC\", \"USDT\", \"BTC\", \"ETH\"];\n\nconst getSize = (n: any, mint: any, mintCache: any) => {\n  try {\n    const dec = mintCache[mint].decimals;\n    const size = Math.floor(parseFloat(n) * Math.pow(10, dec));\n    return size;\n  } catch {\n    return 0;\n  }\n};\n\nconst getFees = (formState, metadata) => {\n  try {\n    if (formState.mintA in metadata) {\n      const fees = metadata[formState.mintA].account.data.sellerFeeBasisPoints;\n      const size = parseFloat(formState.sizeB);\n      return [true, size, (size * fees) / 10000, fees];\n    } else if (formState.mintB in metadata) {\n      const fees = metadata[formState.mintB].account.data.sellerFeeBasisPoints;\n      const size = parseFloat(formState.sizeA);\n      return [false, size, (size * fees) / 10000, fees];\n    } else {\n      return [true, 0, 0, 0];\n    }\n  } catch {\n    return [true, 0, 0, 0];\n  }\n};\n\nconst displayFees = (isSeller, formState, metadata) => {\n  // const creator\n  const [isSellerNFT, size, feeAmount, fees] = getFees(formState, metadata);\n  const isFeePayer = (isSellerNFT && !isSeller) || (!isSellerNFT && isSeller);\n  if (fees <= 0) return null;\n\n  const feePct = (fees / 100).toFixed(2);\n  if (isFeePayer) {\n    const side = !isSellerNFT ? \"Seller\" : \"Buyer\";\n    return (\n      <div\n        style={{\n          marginLeft: \"12px\",\n          marginTop: \"2px\",\n          fontSize: 12,\n          textAlign: \"left\",\n        }}\n      >\n        {`* ${side} will pay a ${feePct}% fee on trade (pays ~${feeAmount.toFixed(\n          4\n        )})`}\n      </div>\n    );\n  } else {\n    const side = isSellerNFT ? \"Seller\" : \"Buyer\";\n    return (\n      <div\n        style={{\n          marginLeft: \"12px\",\n          marginTop: \"2px\",\n          fontSize: 12,\n          textAlign: \"left\",\n        }}\n      >\n        {`* ${side} will receive ${feePct}% less on trade due to fees (receives ~${(\n          size - feeAmount\n        ).toFixed(4)})`}\n      </div>\n    );\n  }\n};\n\nconst getDelegate = async (formState: any, mintCache: any, metadata) => {\n  try {\n    const sizeA = getSize(formState.sizeA, formState.mintA, mintCache);\n    const sizeB = getSize(formState.sizeB, formState.mintB, mintCache);\n    return (\n      await PublicKey.findProgramAddress(\n        [\n          Buffer.from(\"stateless_offer\"),\n          new PublicKey(formState.maker).toBuffer(),\n          new PublicKey(formState.mintA).toBuffer(),\n          new PublicKey(formState.mintB).toBuffer(),\n          new Uint8Array(new BN(sizeA).toArray(\"le\", 8)),\n          new Uint8Array(new BN(sizeB).toArray(\"le\", 8)),\n        ],\n        STATELESS_ASK_PROGRAM_ID\n      )\n    )[0];\n  } catch (e) {\n    console.log(\"Failed to get delegate. Metadata:\", metadata);\n    return null;\n  }\n};\n\nconst getExplorerLink = (env, formState, mint) => {\n  if (env && formState && formState[mint]) {\n    let url = `https://explorer.solana.com/address/${formState[mint]}?cluster=${env}`;\n    return window.open(url, \"_blank\");\n  }\n  return false;\n};\n\nconst getDefaultFormState = () => {\n  let url = new URL(window.location.href);\n  let params = new URLSearchParams(url.search.slice(1));\n  let defaultState = {\n    mintA: \"\",\n    mintB: \"\",\n    sizeA: \"0\",\n    sizeB: \"0\",\n    maker: \"\",\n  };\n  for (const key of params.keys()) {\n    defaultState[key] = params.get(key);\n  }\n  return defaultState;\n};\n\nexport function TransferBox() {\n  const connection = useConnection();\n  const wallet = useWallet();\n  const { env } = useConnectionConfig();\n  const [formState, setFormState] = useState(getDefaultFormState());\n  const [accountState, setAccountState] = useState({});\n  const [buyerAccountState, setBuyerAccountState] = useState({});\n  const [mintCache, setMintCache] = useState({});\n  const [buyerLamports, setBuyerLamports] = useState(0);\n  const [isSeller, setIsSeller] = useState(false);\n  const [validAmount, setValidAmount] = useState(false);\n  const [hasDelegate, setHasDelegate] = useState(false);\n  const [hasValidDelegate, setHasValidDelegate] = useState(false);\n  const [openA, setOpenA] = useState(false);\n  const [openB, setOpenB] = useState(false);\n  const [nonATAs, setNonATAs] = useState([]);\n  const [anchorElA, setAnchorElA] = useState(null);\n  const [anchorElB, setAnchorElB] = useState(null);\n  const [openPopA, setOpenPopA] = useState(false);\n  const [openPopB, setOpenPopB] = useState(false);\n  let inputClicked = false;\n  const [metadata, setMetadata] = useState({});\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n\n  useEffect(() => {\n    console.log(\"RESET\");\n    if (!wallet.connected) {\n      console.log(\"Wallet disconnected, resetting state\");\n      setBuyerAccountState({});\n      setIsSeller(false);\n      setValidAmount(false);\n      setMintCache({});\n      setHasDelegate(false);\n      setHasValidDelegate(false);\n    }\n  }, [wallet.connected, wallet.publicKey]);\n\n  useEffect(() => {\n    console.log(\"TOKEN LOOKUP\");\n    new TokenListProvider().resolve().then((tokens) => {\n      let tokenList;\n      if (env === \"devnet\") {\n        tokenList = tokens.filterByChainId(ENV.Devnet).getList();\n      } else if (env === \"mainnet-beta\") {\n        tokenList = tokens.filterByChainId(ENV.MainnetBeta).getList();\n      } else if (env === \"testnet\") {\n        tokenList = tokens.filterByChainId(ENV.Testnet).getList();\n      }\n      setTokenMap(\n        tokenList.reduce((map, item) => {\n          map.set(item.symbol, item);\n          return map;\n        }, new Map())\n      );\n    });\n  }, [setTokenMap, env]);\n\n  useEffect(() => {\n    console.log(\"SET SELLER\");\n    if (!wallet) {\n      return;\n    }\n    setIsSeller(wallet.publicKey?.toBase58() === formState.maker);\n  }, [formState.maker, wallet, setIsSeller]);\n\n  useEffect(() => {\n    console.log(\"VALIDATE TOKEN ACCOUNT\");\n    const validate = async () => {\n      const tokenAccount: any = accountState;\n      if (!tokenAccount.mint) {\n        return;\n      }\n      const mint = tokenAccount.mint.toBase58();\n      if (mint in mintCache) {\n        const dec = mintCache[mint].decimals;\n        const totalAmount = tokenAccount.amount * Math.pow(10, -dec);\n        try {\n          const size = parseFloat(formState.sizeA);\n          setValidAmount(totalAmount >= size && size > 0);\n        } catch {\n          console.log(\"Not a valid float\");\n        }\n      }\n      const delegate = await getDelegate(\n        formState,\n        mintCache,\n        metadata[formState.mintA]\n      );\n      setHasDelegate(tokenAccount.delegateOption !== 0);\n      if (\n        tokenAccount.delegate &&\n        delegate &&\n        tokenAccount.delegateOption !== 0 &&\n        delegate.toBase58() === tokenAccount.delegate.toBase58()\n      ) {\n        setHasValidDelegate(true);\n      } else {\n        setHasValidDelegate(false);\n      }\n    };\n    validate();\n  }, [accountState, mintCache, formState, metadata]);\n\n  useEffect(() => {\n    console.log(\"FETCH SELLER TOKEN ACCOUNT\");\n    let subId;\n    if (!wallet.connected) {\n      return;\n    }\n    const fetchAccountState = async () => {\n      let sellerWallet;\n      let sellerMint;\n      try {\n        sellerWallet = new PublicKey(formState.maker);\n        sellerMint = new PublicKey(formState.mintA);\n      } catch (e) {\n        return;\n      }\n      let sellerTokenAccount = (\n        await PublicKey.findProgramAddress(\n          [\n            sellerWallet.toBuffer(),\n            TOKEN_PROGRAM_ID.toBuffer(),\n            sellerMint.toBuffer(),\n          ],\n          SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n        )\n      )[0];\n      const result = await connection.getAccountInfo(sellerTokenAccount);\n      if (result) {\n        try {\n          const tokenAccount = deserializeAccount(result.data);\n          setAccountState(tokenAccount);\n        } catch (e) {\n          console.log(\"Failed to deserialize account\");\n        }\n      } else {\n        let sellerTokenAccounts;\n        try {\n          sellerTokenAccounts = await connection.getTokenAccountsByOwner(\n            sellerWallet,\n            { mint: sellerMint }\n          );\n        } catch {\n          return;\n        }\n        if (sellerTokenAccounts.value) {\n          let badAccounts: any = [];\n          for (const account of sellerTokenAccounts.value) {\n            try {\n              const size = deserializeAccount(account.account.data).amount;\n              badAccounts.push({ pubkey: account.pubkey, size: size });\n            } catch (e) {\n              console.log(\"Failed to deserialize account\", e);\n            }\n          }\n          console.log(badAccounts);\n          setNonATAs(badAccounts);\n        }\n      }\n      subId = connection.onAccountChange(sellerTokenAccount, async (result) => {\n        if (result) {\n          console.log(\"Received account data\");\n          try {\n            const tokenAccount = deserializeAccount(result.data);\n            setAccountState(tokenAccount);\n          } catch (e) {\n            console.log(\"Failed to deserialize account\", e);\n          }\n        }\n      });\n    };\n    fetchAccountState();\n    return () => {\n      if (subId) connection.removeAccountChangeListener(subId);\n    };\n  }, [\n    formState.maker,\n    formState.mintA,\n    connection,\n    setAccountState,\n    wallet.connected,\n  ]);\n\n  useEffect(() => {\n    console.log(\"FETCH BUYER TOKEN ACCOUNT\");\n    let subId;\n    if (!wallet.connected || !wallet.publicKey) {\n      console.log(\"Wallet disconnected, can't fetch buyer token account\");\n      return;\n    }\n    const fetchAccountState = async () => {\n      let buyerWallet;\n      let buyerMint;\n      try {\n        buyerWallet = wallet.publicKey;\n        buyerMint = new PublicKey(formState.mintB);\n      } catch (e) {\n        return;\n      }\n      try {\n        let walletResult = await connection.getAccountInfo(buyerWallet);\n        if (walletResult) {\n          setBuyerLamports(walletResult.lamports);\n        }\n      } catch {\n        console.log(\"Failed to fetch wallet\");\n      }\n      let buyerTokenAccount = (\n        await PublicKey.findProgramAddress(\n          [\n            buyerWallet.toBuffer(),\n            TOKEN_PROGRAM_ID.toBuffer(),\n            buyerMint.toBuffer(),\n          ],\n          SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n        )\n      )[0];\n      let result;\n      try {\n        result = await connection.getAccountInfo(buyerTokenAccount);\n      } catch {\n        console.log(\"Failed to fetch Buyer ATA\");\n      }\n      if (result) {\n        try {\n          const tokenAccount = deserializeAccount(result.data);\n          setBuyerAccountState(tokenAccount);\n        } catch (e) {\n          console.log(\"Failed to deserialize account\");\n        }\n      } else {\n        let buyerTokenAccounts;\n        try {\n          buyerTokenAccounts = await connection.getTokenAccountsByOwner(\n            buyerWallet,\n            { mint: buyerMint }\n          );\n        } catch {\n          return;\n        }\n        if (buyerTokenAccounts.value) {\n          let badAccounts: any = [];\n          for (const account of buyerTokenAccounts.value) {\n            try {\n              const size = deserializeAccount(account.account.data).amount;\n              badAccounts.push({ pubkey: account.pubkey, size: size });\n            } catch (e) {\n              console.log(\"Failed to deserialize account\", e);\n            }\n          }\n          setNonATAs(badAccounts);\n        }\n      }\n      subId = connection.onAccountChange(buyerTokenAccount, async (result) => {\n        if (result) {\n          console.log(\"Received account data\");\n          try {\n            const tokenAccount = deserializeAccount(result.data);\n            setBuyerAccountState(tokenAccount);\n          } catch (e) {\n            console.log(\"Failed to deserialize account\", e);\n          }\n        }\n      });\n    };\n    fetchAccountState();\n    return () => {\n      if (subId) connection.removeAccountChangeListener(subId);\n    };\n  }, [\n    formState.maker,\n    formState.mintB,\n    connection,\n    setBuyerAccountState,\n    wallet.publicKey,\n    wallet.connected,\n  ]);\n\n  useEffect(() => {\n    console.log(\"FETCH MINT ACCOUNTS\");\n    if (!wallet.connected) {\n      return;\n    }\n    const fetchMintState = async () => {\n      let mint;\n      for (const mintString of [formState.mintA, formState.mintB]) {\n        try {\n          mint = new PublicKey(mintString);\n        } catch (e) {\n          continue;\n        }\n        if (!(mint.toBase58() in mintCache)) {\n          let result = await connection.getAccountInfo(mint);\n          if (result) {\n            try {\n              const mintData = deserializeMint(result.data);\n              setMintCache({\n                ...mintCache,\n                [mintString]: mintData,\n              });\n            } catch {\n              continue;\n            }\n          }\n        }\n      }\n    };\n    fetchMintState();\n  }, [\n    mintCache,\n    formState.mintA,\n    formState.mintB,\n    connection,\n    wallet.connected,\n  ]);\n\n  useEffect(() => {\n    console.log(\"FETCH METADATA ACCOUNTS\");\n    if (!wallet.connected) {\n      return;\n    }\n    const getMetadata = async () => {\n      for (const mint of [formState.mintA, formState.mintB]) {\n        if (!(mint in mintCache)) {\n          return;\n        }\n        if (mint in metadata) {\n          return;\n        }\n        const metadataPubkey: any = await getTokenMetadata(new PublicKey(mint));\n        const result = await connection.getAccountInfo(metadataPubkey);\n        if (result) {\n          try {\n            const meta: any = decodeMetadata(result.data);\n            setMetadata({\n              ...metadata,\n              [mint]: { pubkey: metadataPubkey, account: meta },\n            });\n            break;\n          } catch {\n            continue;\n          }\n        }\n      }\n    };\n    getMetadata();\n  }, [\n    mintCache,\n    formState.mintA,\n    formState.mintB,\n    setMetadata,\n    connection,\n    wallet.connected,\n  ]);\n\n  const setField = (name: any) => {\n    const setFieldWithName = (e) => {\n      setFormState({ ...formState, [name]: e.target.value });\n      let url = new URL(window.location.href);\n      let params = new URLSearchParams(url.search.slice(1));\n      params.set(name, escape(e.target.value));\n      let newUrl =\n        window.location.protocol +\n        \"//\" +\n        window.location.host +\n        window.location.pathname +\n        \"?\" +\n        params.toString();\n      window.history.pushState({ path: newUrl }, \"\", newUrl);\n    };\n    return setFieldWithName;\n  };\n\n  const getField = (name: any) => {\n    if (name in formState) {\n      return formState[name];\n    }\n  };\n\n  const handleEnter = (e) => {\n    if (e.key === \"Enter\") {\n      setOpenA(false);\n      setOpenB(false);\n    }\n  };\n\n  const handlePopoverOpenA = (e) => {\n    setAnchorElA(e.currentTarget);\n    setOpenPopA(true);\n  };\n\n  const handlePopoverCloseA = (e) => {\n    setAnchorElA(null);\n    setOpenPopA(false);\n  };\n\n  const handlePopoverOpenB = (e) => {\n    setAnchorElB(e.currentTarget);\n    setOpenPopB(true);\n  };\n\n  const handlePopoverCloseB = (e) => {\n    setAnchorElB(null);\n    setOpenPopB(false);\n  };\n\n  const getTokenKeys = (tokenMap, mintStr) => {\n    let keys: any[] = [];\n    keys.push(\n      <Input\n        key={mintStr}\n        onKeyPress={handleEnter}\n        inputProps={{\n          sx: { marginLeft: \"15px\" },\n          value: getField(mintStr),\n          placeholder:\n            \"Enter the desired mint public key (or select from known mints)\",\n        }}\n        sx={{width:\"60ch\"}}\n        value={getField(mintStr)}\n        fullWidth\n        onChange={(e) => {\n          setField(mintStr)(e);\n        }}\n        onClick={(e) => {\n          inputClicked = true;\n        }} // necessary?\n        onKeyDown={(e) => e.stopPropagation()} // necessary?\n      ></Input>\n    );\n    for (const mint of MINTS) {\n      if (!tokenMap.get(mint)) {\n        if (mint === \"None\") {\n          keys.push(\n            <MenuItem key={mint} value=\"\" sx={{ width: \"60ch\", fontStyle: \"italic\" }}>\n              {mint}\n            </MenuItem>\n          );\n        }\n        continue;\n      }\n      keys.push(\n        <MenuItem sx={{width:\"60ch\"}} key={mint} value={tokenMap.get(mint).address}>\n          {mint}\n        </MenuItem>\n      );\n    }\n    return keys;\n  };\n\n  const displayActions = () => {\n    const mintEntered =\n      formState.mintA in mintCache && formState.mintB in mintCache;\n    const sizeA = getSize(formState.sizeA, formState.mintA, mintCache);\n    const sizeB = getSize(formState.sizeB, formState.mintB, mintCache);\n    let isConnected = true;\n    if (\n      !mintEntered ||\n      sizeA <= 0 ||\n      sizeB <= 0 ||\n      isNaN(sizeA) ||\n      isNaN(sizeB)\n    ) {\n      isConnected = false;\n    }\n    const buyerAccount: any = buyerAccountState;\n\n    const hasSufficientTokenBalance =\n      buyerAccount &&\n      \"amount\" in buyerAccount &&\n      isConnected &&\n      buyerAccount.amount.toNumber() >= sizeB;\n\n    const hasSufficientLamports =\n      buyerLamports >= parseFloat(formState.sizeB) * LAMPORTS_PER_SOL;\n    const isNativeSOL = formState.mintB === NATIVE_MINT.toBase58();\n\n    const hasSufficientBalance = !isNativeSOL\n      ? hasSufficientTokenBalance\n      : hasSufficientLamports;\n\n    const canTrade =\n      !isSeller && hasValidDelegate && validAmount && hasSufficientBalance;\n    const canOpenOffer =\n      isSeller && validAmount && !hasValidDelegate && isConnected;\n    const canCancelOffer = isSeller && hasDelegate && isConnected;\n\n    if (nonATAs && nonATAs.length && nonATAs.length > 0) {\n      return (\n        <Button\n          variant=\"contained\"\n          color=\"success\"\n          onClick={() => {\n            if (formState) {\n              try {\n                consolidateTokenAccounts(\n                  connection,\n                  isSeller\n                    ? new PublicKey(formState.mintA)\n                    : new PublicKey(formState.mintB),\n                  wallet,\n                  nonATAs,\n                  setNonATAs\n                );\n              } catch (e) {\n                return;\n              }\n            }\n          }}\n          sx={{ marginRight: \"4px\" }}\n        >\n          Consolidate Token Accounts\n        </Button>\n      );\n    }\n    return (\n      <div>\n        {!isSeller && hasValidDelegate && validAmount && !hasSufficientBalance && (\n          <div\n            style={{\n              marginLeft: \"12px\",\n              marginBottom: \"5px\",\n              fontSize: 12,\n              textAlign: \"left\",\n              color: \"red\",\n            }}\n          >\n            {`* Buyer has insufficient funds`}\n          </div>\n        )}\n        <div>\n          <Button\n            variant=\"contained\"\n            disabled={!canOpenOffer}\n            onClick={() => {\n              if (formState) {\n                try {\n                  changeOffer(\n                    connection,\n                    new PublicKey(formState.mintA),\n                    new PublicKey(formState.mintB),\n                    new BN(sizeA),\n                    new BN(sizeB),\n                    wallet,\n                    setHasValidDelegate,\n                    setHasDelegate,\n                    metadata\n                  );\n                } catch (e) {\n                  return;\n                }\n              }\n            }}\n          >\n            Open New Offer\n          </Button>\n          <Button\n            variant=\"contained\"\n            color=\"error\"\n            sx={{ marginLeft: \"10px\" }}\n            disabled={!canCancelOffer}\n            onClick={() => {\n              if (formState) {\n                try {\n                  changeOffer(\n                    connection,\n                    new PublicKey(formState.mintA),\n                    new PublicKey(formState.mintB),\n                    new BN(\n                      getSize(formState.sizeA, formState.mintA, mintCache)\n                    ),\n                    new BN(\n                      getSize(formState.sizeB, formState.mintB, mintCache)\n                    ),\n                    wallet,\n                    setHasValidDelegate,\n                    setHasDelegate,\n                    metadata,\n                    false\n                  );\n                } catch (e) {\n                  return;\n                }\n              }\n            }}\n          >\n            Close Existing Offer\n          </Button>\n          <Button\n            variant=\"contained\"\n            color=\"success\"\n            sx={{ marginLeft: \"10px\" }}\n            disabled={!canTrade}\n            onClick={() => {\n              if (formState) {\n                try {\n                  trade(\n                    connection,\n                    new PublicKey(formState.maker),\n                    new PublicKey(formState.mintA),\n                    new PublicKey(formState.mintB),\n                    new BN(\n                      getSize(formState.sizeA, formState.mintA, mintCache)\n                    ),\n                    new BN(\n                      getSize(formState.sizeB, formState.mintB, mintCache)\n                    ),\n                    metadata,\n                    setHasValidDelegate,\n                    wallet\n                  );\n                } catch (e) {\n                  return;\n                }\n              }\n            }}\n          >\n            Trade\n          </Button>\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div>\n      <div>\n        <Box\n          component=\"form\"\n          sx={{\n            \"& .MuiTextField-root\": { m: 1, width: \"60ch\" },\n            justifyContent: \"center\",\n            marginBottom: \"10px\",\n          }}\n          noValidate\n          autoComplete=\"on\"\n        >\n          <LoadingButton\n            onClick={() => {\n              const w = getExplorerLink(env, formState, \"mintA\");\n              if (w) {\n                w.focus();\n              }\n            }}\n            onMouseOver={handlePopoverOpenA}\n            onMouseOut={handlePopoverCloseA}\n            disabled={!(formState.mintA && formState.mintA in mintCache)}\n            color=\"secondary\"\n            sx={{ width: \"30ch\" }}\n            variant=\"contained\"\n            aria-owns={openPopA ? \"mouse-popoverA\" : undefined}\n            aria-haspopup=\"true\"\n          >\n            Seller Mint (Explorer)\n          </LoadingButton>\n          <Popover\n            id=\"mouse-popoverA\"\n            sx={{\n              pointerEvents: \"none\",\n            }}\n            open={openPopA}\n            anchorEl={anchorElA}\n            anchorOrigin={{\n              vertical: \"top\",\n              horizontal: \"left\",\n            }}\n            transformOrigin={{\n              vertical: \"bottom\",\n              horizontal: \"left\",\n            }}\n            onClose={handlePopoverCloseA}\n          >\n            <object\n              data={`https://explorer.solana.com/address/${formState[\"mintA\"]}/?cluster=${env}`}\n              width=\"500\"\n              height=\"500\"\n            ></object>\n          </Popover>\n          <LoadingButton\n            onClick={() => {\n              const w = getExplorerLink(env, formState, \"mintB\");\n              if (w) {\n                w.focus();\n              }\n            }}\n            onMouseOver={handlePopoverOpenB}\n            onMouseOut={handlePopoverCloseB}\n            disabled={!(formState.mintB && formState.mintB in mintCache)}\n            color=\"secondary\"\n            sx={{ width: \"30ch\", marginLeft: \"10px\" }}\n            variant=\"contained\"\n            aria-owns={openPopB ? \"mouse-popoverB\" : undefined}\n            aria-haspopup=\"true\"\n          >\n            Buyer Mint (Explorer)\n          </LoadingButton>\n          <Popover\n            id=\"mouse-popoverB\"\n            sx={{\n              pointerEvents: \"none\",\n            }}\n            open={openPopB}\n            anchorEl={anchorElB}\n            anchorOrigin={{\n              vertical: \"top\",\n              horizontal: \"left\",\n            }}\n            transformOrigin={{\n              vertical: \"bottom\",\n              horizontal: \"left\",\n            }}\n            onClose={handlePopoverCloseB}\n          >\n            <object\n              data={`https://explorer.solana.com/address/${formState[\"mintB\"]}/?cluster=${env}`}\n              width=\"500\"\n              height=\"500\"\n            ></object>\n          </Popover>\n        </Box>\n      </div>\n      <div>\n        <Box\n          component=\"form\"\n          sx={{\n            \"& .MuiTextField-root\": { m: 1, width: \"60ch\" },\n          }}\n          noValidate\n          autoComplete=\"on\"\n        >\n          <div>\n            <TextField\n              required\n              id=\"outlined-required\"\n              label=\"Seller Public Key\"\n              value={getField(\"maker\")}\n              onChange={setField(\"maker\")}\n            />\n            <FormControl sx={{ marginTop: \"8px\", marginBottom: \"15px\"}}>\n              <InputLabel id=\"seller-mint\">Seller Mint</InputLabel>\n              <Select\n                sx={{\n                  textAlign: \"left\",\n                  width: \"60ch\",\n                }}\n                labelId=\"seller-mint\"\n                value={getField(\"mintA\")}\n                input={<OutlinedInput label=\"Seller Mint\" />}\n                onChange={(e) => {\n                  setField(\"mintA\")(e);\n                }}\n                open={openA}\n                onClose={(e) => {\n                  if (inputClicked) {\n                    inputClicked = false;\n                  } else {\n                    setOpenA(false);\n                  }\n                }}\n                onOpen={(e) => {\n                  setOpenA(true);\n                  setOpenB(false);\n                }}\n                MenuProps={{\n                  sx: {maxWidth:\"60ch\"}\n                }}\n                renderValue={(selected) => {\n                  return selected;\n                }}\n              >\n                {getTokenKeys(tokenMap, \"mintA\")}\n              </Select>\n            </FormControl>\n            <FormControl sx={{ marginBottom: \"5px\" }}>\n              <InputLabel id=\"buyer-mint\">Buyer Mint</InputLabel>\n              <Select\n                sx={{\n                  textAlign: \"left\",\n                  width: \"60ch\",\n                }}\n                style={{width: \"60ch\"}}\n                labelId=\"buyer-mint\"\n                value={getField(\"mintB\")}\n                input={<OutlinedInput label=\"Buyer Mint\" />}\n                onChange={setField(\"mintB\")}\n                open={openB}\n                onClose={(e) => {\n                  if (inputClicked) {\n                    inputClicked = false;\n                  } else {\n                    setOpenB(false);\n                  }\n                }}\n                onOpen={(e) => {\n                  setOpenA(false);\n                  setOpenB(true);\n                }}\n                MenuProps={{\n                  sx: {width:\"60ch\"}\n                }}\n                renderValue={(selected) => {\n                  return selected;\n                }}\n              >\n                {getTokenKeys(tokenMap, \"mintB\")}\n              </Select>\n            </FormControl>\n            <TextField\n              id=\"outlined-number\"\n              label=\"Seller Size\"\n              type=\"number\"\n              value={getField(\"sizeA\")}\n              onChange={setField(\"sizeA\")}\n              sx={{ marginBottom: \"5px\" }}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n            <TextField\n              id=\"outlined-number\"\n              label=\"Buyer Size\"\n              type=\"number\"\n              value={getField(\"sizeB\")}\n              onChange={setField(\"sizeB\")}\n              sx={{ marginBottom: \"2px\" }}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n          </div>\n          {displayFees(isSeller, formState, metadata)}\n          <div style={{ marginTop: \"5px\" }}>{displayActions()}</div>\n        </Box>\n      </div>\n    </div>\n  );\n}\n","export default __webpack_public_path__ + \"static/media/wallet.c746d144.less\";","import { WalletAdapter, WalletError } from \"@solana/wallet-adapter-base\";\nimport {\n  useWallet,\n  WalletProvider as BaseWalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  getLedgerWallet,\n  getMathWallet,\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolongWallet,\n  getTorusWallet,\n} from \"@solana/wallet-adapter-wallets\";\nimport { Button } from \"antd\";\nimport {\n  createContext,\n  FC,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { notify } from \"../../utils\";\nimport { DefaultModal } from \"../../components\";\n\nimport \"./wallet.less\";\n\nexport interface WalletModalContextState {\n  visible: boolean;\n  setVisible: (open: boolean) => void;\n}\n\nexport const WalletModalContext = createContext<WalletModalContextState>(\n  {} as WalletModalContextState\n);\n\nexport function useWalletModal(): WalletModalContextState {\n  return useContext(WalletModalContext);\n}\n\nexport const WalletModal: FC = () => {\n  const { wallets, wallet: selected, select } = useWallet();\n  const { visible, setVisible } = useWalletModal();\n  const close = useCallback(() => {\n    setVisible(false);\n  }, [setVisible]);\n\n  return (\n    <DefaultModal visible={visible} onCancel={close}>\n      <div\n        style={{\n          background:\n            \"linear-gradient(180deg, #D329FC 0%, #8F6DDE 49.48%, #19E6AD 100%)\",\n          borderRadius: 36,\n          width: 50,\n          height: 50,\n          textAlign: \"center\",\n          verticalAlign: \"middle\",\n          fontWeight: 700,\n          fontSize: \"1.3rem\",\n          lineHeight: 2.4,\n          marginBottom: 10,\n        }}\n      ></div>\n      <h2\n        style={{\n          color: \"white\",\n          fontWeight: \"bold\",\n          fontSize: 20,\n        }}\n      >\n        {selected ? \"Change provider\" : \"\"}\n      </h2>\n      <p style={{ color: \"white\", fontSize: 14 }}>\n        {selected\n          ? \"Choose from the following options:\"\n          : \"Please sign into your wallet\"}\n      </p>\n\n      <br />\n      {wallets.map((wallet) => {\n        return (\n          <Button\n            key={wallet.name}\n            size=\"large\"\n            type={wallet === selected ? \"primary\" : \"ghost\"}\n            onClick={() => {\n              select(wallet.name);\n              close();\n            }}\n            icon={\n              <img\n                alt={`${wallet.name}`}\n                width={20}\n                height={20}\n                src={wallet.icon}\n                style={{ marginRight: 30, float: \"left\" }}\n              />\n            }\n            style={{\n              display: \"block\",\n              width: \"100%\",\n              textAlign: \"left\",\n              marginBottom: 8,\n              color: \"white\",\n            }}\n          >\n            {wallet.name}\n          </Button>\n        );\n      })}\n    </DefaultModal>\n  );\n};\n\nexport const WalletModalProvider: FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const { publicKey } = useWallet();\n  const [connected, setConnected] = useState(!!publicKey);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (publicKey) {\n      const base58 = publicKey.toBase58();\n      const keyToDisplay =\n        base58.length > 20\n          ? `${base58.substring(0, 7)}.....${base58.substring(\n              base58.length - 7,\n              base58.length\n            )}`\n          : base58;\n\n      notify({\n        message: \"Wallet update\",\n        description: \"Connected to wallet \" + keyToDisplay,\n      });\n    }\n  }, [publicKey]);\n\n  useEffect(() => {\n    if (!publicKey && connected) {\n      notify({\n        message: \"Wallet update\",\n        description: \"Disconnected from wallet\",\n      });\n    }\n    setConnected(!!publicKey);\n  }, [publicKey, connected, setConnected]);\n\n  return (\n    <WalletModalContext.Provider\n      value={{\n        visible,\n        setVisible,\n      }}\n    >\n      {children}\n      <WalletModal />\n    </WalletModalContext.Provider>\n  );\n};\n\nexport const WalletProvider: FC<{ children: ReactNode }> = ({ children }) => {\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getTorusWallet({\n        options: {\n          // @FIXME: this should be changed for Default, and by each Default storefront\n          clientId:\n            \"BOM5Cl7PXgE9Ylq1Z1tqzhpydY0RVr8k90QQ85N7AKI5QGSrr9iDC-3rvmy0K_hF0JfpLMiXoDhta68JwcxS1LQ\",\n        },\n      }),\n      getLedgerWallet(),\n      getSolongWallet(),\n      getMathWallet(),\n      getSolletWallet(),\n    ],\n    []\n  );\n\n  const onError = useCallback((error: WalletError) => {\n    console.error(error);\n    notify({\n      message: \"Wallet error\",\n      description: error.message,\n    });\n  }, []);\n\n  return (\n    <BaseWalletProvider wallets={wallets} onError={onError} autoConnect>\n      <WalletModalProvider>{children}</WalletModalProvider>\n    </BaseWalletProvider>\n  );\n};\n\nexport type WalletSigner = Pick<\n  WalletAdapter,\n  \"publicKey\" | \"signTransaction\" | \"signAllTransactions\"\n>;\n","import React, { useState, useContext, useCallback } from 'react';\n\nimport { WalletModal } from './WalletContext/WalletContext';\n\nexport enum ModalEnum {\n  WALLET = 'wallet',\n}\n\ntype ModalContextProps = {\n  setModal: (modal: ModalEnum | undefined) => void;\n  removeModal: () => void;\n};\n\nexport const ModalContext = React.createContext<ModalContextProps>({\n  setModal: () => null,\n  removeModal: () => null,\n});\n\nexport const ModalProvider: React.FC = ({ children }) => {\n  const [modal, setModal] = useState<ModalEnum | undefined>(undefined);\n\n  const removeModal = useCallback(() => {\n    setModal(undefined);\n  }, [setModal]);\n\n  return (\n    <ModalContext.Provider\n      value={{\n        setModal,\n        removeModal,\n      }}\n    >\n      {children}\n      {modal === ModalEnum.WALLET && <WalletModal />}\n    </ModalContext.Provider>\n  );\n};\n\nexport const useModal = (): ModalContextProps => {\n  const context = useContext(ModalContext);\n  if (context === undefined) {\n    throw new Error('useModal must be used within a ModalProvider');\n  }\n  return context;\n};\n","import { useTheme } from \"@mui/material\";\nimport React, { useContext } from \"react\";\n\nexport const ColorModeContext = React.createContext({});\n\nexport const ColorModeContextProvider = ({children=null as any }) => {\n  const [mode, setMode] = React.useState<'light' | 'dark'>('dark'); \n  const theme = useTheme();\n  const toggleColorMode = () => {\n    setMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));\n  }\n  return (\n    <ColorModeContext.Provider\n      value={{\n        toggleColorMode,\n        mode,\n        theme,\n      }}\n    >\n      {children}\n    </ColorModeContext.Provider>\n  );\n};\n\nexport const useColorMode = (): any => {\n  const context = useContext(ColorModeContext);\n  return context;\n};\n","import { PublicKey, AccountInfo } from '@solana/web3.js';\n\nexport type StringPublicKey = string;\n\nexport class LazyAccountInfoProxy<T> {\n  executable: boolean = false;\n  owner: StringPublicKey = '';\n  lamports: number = 0;\n\n  get data() {\n    //\n    return undefined as unknown as T;\n  }\n}\n\nexport interface LazyAccountInfo {\n  executable: boolean;\n  owner: StringPublicKey;\n  lamports: number;\n  data: [string, string];\n}\n\nconst PubKeysInternedMap = new Map<string, PublicKey>();\n\nexport const toPublicKey = (key: string | PublicKey) => {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  let result = PubKeysInternedMap.get(key);\n  if (!result) {\n    result = new PublicKey(key);\n    PubKeysInternedMap.set(key, result);\n  }\n\n  return result;\n};\n\nexport interface PublicKeyStringAndAccount<T> {\n  pubkey: string;\n  account: AccountInfo<T>;\n}\n\nexport const WRAPPED_SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const BPF_UPGRADE_LOADER_ID = new PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');\n\nexport const MEMO_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');\n\nexport const SYSTEM = new PublicKey('11111111111111111111111111111111');\n\nexport const TOKEN_METADATA_PROGRAM_ID = new PublicKey(\n  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',\n);\n\nexport const STATELESS_ASK_PROGRAM_ID = new PublicKey(\"SAtnofysr9Uxk7m9YphxwfL5E3wyZJWUzjwA29Gw3tQ\");","import {\n  TOKEN_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_METADATA_PROGRAM_ID,\n  BPF_UPGRADE_LOADER_ID,\n  SYSTEM,\n  MEMO_ID,\n} from './ids';\n\nexport const setProgramIds = async () => {};\n\nexport const programIds = () => {\n  return {\n    token: TOKEN_PROGRAM_ID,\n    associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    bpf_upgrade_loader: BPF_UPGRADE_LOADER_ID,\n    system: SYSTEM,\n    memo: MEMO_ID,\n    metadata: TOKEN_METADATA_PROGRAM_ID,\n  };\n};\n","import { ButtonGroup, ButtonGroupProps } from \"@mui/material\";\nimport { Settings } from \"./Settings\";\n\nexport type ConnectButtonProps = ButtonGroupProps & {\n  isConnected: boolean;\n  onClickConnect: () => void;\n  onClickChange: () => void;\n};\n\nexport const ConnectButton: React.FC<ConnectButtonProps> = ({\n  isConnected,\n  onClickConnect,\n  onClickChange,\n  ...restProps\n}) => {\n  return (\n    <ButtonGroup   {...restProps}>\n      <Settings/>\n    </ButtonGroup>\n  );\n};\n\nexport default ConnectButton;\n","import React, { useCallback } from \"react\";\nimport { Box } from \"@mui/system\";\n\nimport ConnectButton from \"../ConnectButton\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\n\nexport const Header: React.FC = () => {\n  const { setModal } = useModal();\n  const { setVisible } = useWalletModal();\n  const wallet = useWallet();\n  const connected = wallet.connected;\n\n  const handleChange = useCallback(() => setVisible(true), [setVisible]);\n\n  const handleConnect = useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n  return (\n    <Box\n      sx={{\n        display: \"flex\",\n        bgcolor: \"action.disabledBackground\",\n      }}\n      minWidth=\"100%\"\n    >\n      <Box sx={{flexGrow: 1}}></Box>\n      <Box\n        sx={{\n          display: \"flex\",\n          height: \"62px\",\n          justifyContent: \"flex-end\",\n          alignItems: \"center\",\n        }}\n      >\n        <ConnectButton\n          isConnected={connected}\n          sx={{ marginRight: \"36px\" }}\n          onClickConnect={handleConnect}\n          onClickChange={handleChange}\n        />\n      </Box>\n    </Box>\n  );\n};\n\nexport default Header;\n","import React, { useEffect, useState } from \"react\";\nimport \"./App.css\";\nimport Header from \"./components/Header/Header\";\nimport { TransferBox } from \"./components\";\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\";\nimport CssBaseline from \"@mui/material/CssBaseline\";\nimport { useColorMode } from \"./contexts\";\nimport { Box } from \"@mui/material\";\n\nconst getWindowDimensions = () => {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height,\n  };\n};\n\nconst useWindowDimensions = () => {\n  const [windowDimensions, setWindowDimensions] = useState(\n    getWindowDimensions()\n  );\n\n  useEffect(() => {\n    function handleResize() {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return windowDimensions;\n};\n\nfunction App() {\n  const colorModeCtx = useColorMode();\n\n  const mode =\n    colorModeCtx.mode === \"dark\" || !colorModeCtx.mode ? \"dark\" : \"light\";\n\n  const { height } = useWindowDimensions();\n\n  const theme = React.useMemo(\n    () =>\n      createTheme({\n        palette: {\n          mode,\n        },\n      }),\n    [mode]\n  );\n\n  return (\n    <div\n      className=\"App\"\n      style={{ position: \"relative\", backgroundColor: \"transparent\", height: \"100%\" }}\n    >\n      <ThemeProvider theme={theme}>\n        <CssBaseline />\n        <Header />\n        <Box\n          sx={{\n            width: 600,\n            flexGrow: 1,\n            mt: `${Math.floor(0.2 * height)}px`,\n            px: \"50%\",\n            display: \"flex\",\n            alignSelf: \"center\",\n            justifyContent: \"center\",\n            alignContent: \"center\",\n          }}\n        >\n          <TransferBox />\n        </Box>\n        <Box\n          sx={{\n            alignItems: \"flex-end\",\n            display: \"flex\",\n            maxWidth: \"200ch\",\n            position: \"absolute\",\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            left: 0,\n            right: 0,\n            bottom: 0,\n            textAlign: \"left\",\n            padding: \"20px\"\n          }}\n          fontSize={11}\n        >\n          *This page was produced by the Solana Foundation (\"SF\") for internal\n          educational and inspiration purposes only. SF does not encourage,\n          induce or sanction the deployment, integration or use of Oyster or any\n          similar application (including its code) in violation of applicable\n          laws or regulations and hereby prohibits any such deployment,\n          integration or use. Anyone using this code or a derivation thereof\n          must comply with applicable laws and regulations when releasing\n          related software.\n        </Box>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  AccountsProvider,\n  WalletProvider,\n  ConnectionProvider,\n  ColorModeContextProvider,\n} from \"./contexts\";\n\nimport \"antd/dist/antd.css\";\nimport \"@fontsource/open-sans\";\nimport \"@fontsource/roboto\";\nimport \"@fontsource/sora\";\n\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <ConnectionProvider>\n      <WalletProvider>\n        <AccountsProvider>\n          <ColorModeContextProvider>\n            <App />\n          </ColorModeContextProvider>\n        </AccountsProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nreportWebVitals();\n","import { PublicKey } from '@solana/web3.js';\nimport { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport { StringPublicKey } from './ids';\n\nexport const extendBorsh = () => {\n  (BinaryReader.prototype as any).readPubkey = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n  };\n\n  (BinaryWriter.prototype as any).writePubkey = function (value: PublicKey) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(value.toBuffer());\n  };\n\n  (BinaryReader.prototype as any).readPubkeyAsString = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array) as StringPublicKey;\n  };\n\n  (BinaryWriter.prototype as any).writePubkeyAsString = function (\n    value: StringPublicKey,\n  ) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(base58.decode(value));\n  };\n};\n\nextendBorsh();\n","import BN from 'bn.js';\n\nexport const TEN = new BN(10);\nexport const HALF_WAD = TEN.pow(new BN(18));\nexport const WAD = TEN.pow(new BN(18));\nexport const RAY = TEN.pow(new BN(27));\nexport const ZERO = new BN(0);\n","import { useCallback, useState } from 'react';\nimport { MintInfo } from '@solana/spl-token';\n\nimport { TokenAccount } from './../models';\nimport { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { WAD, ZERO } from '../constants';\nimport { TokenInfo } from '@solana/spl-token-registry';\n\nexport type KnownTokenMap = Map<string, TokenInfo>;\n\nexport const formatPriceNumber = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 8,\n});\n\nexport function useLocalStorageState(key: string, defaultState?: string) {\n  const [state, setState] = useState(() => {\n    // NOTE: Not sure if this is ok\n    const storedState = localStorage.getItem(key);\n    if (storedState) {\n      return JSON.parse(storedState);\n    }\n    return defaultState;\n  });\n\n  const setLocalStorageState = useCallback(\n    newState => {\n      const changed = state !== newState;\n      if (!changed) {\n        return;\n      }\n      setState(newState);\n      if (newState === null) {\n        localStorage.removeItem(key);\n      } else {\n        try {\n          localStorage.setItem(key, JSON.stringify(newState));\n        } catch {\n          // ignore\n        }\n      }\n    },\n    [state, key],\n  );\n\n  return [state, setLocalStorageState];\n}\n\nexport const findProgramAddress = async (\n  seeds: (Buffer | Uint8Array)[],\n  programId: PublicKey,\n) => {\n  const key =\n    'pda-' +\n    seeds.reduce((agg, item) => agg + item.toString('hex'), '') +\n    programId.toString();\n  let cached = localStorage.getItem(key);\n  if (cached) {\n    const value = JSON.parse(cached);\n\n    return [value.key, parseInt(value.nonce)] as [string, number];\n  }\n\n  const result = await PublicKey.findProgramAddress(seeds, programId);\n\n  try {\n    localStorage.setItem(\n      key,\n      JSON.stringify({\n        key: result[0].toBase58(),\n        nonce: result[1],\n      }),\n    );\n  } catch {\n    // ignore\n  }\n\n  return [result[0].toBase58(), result[1]] as [string, number];\n};\n\n// shorten the checksummed version of the input address to have 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\n\nexport function getTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownSymbol = map.get(mintAddress)?.symbol;\n  if (knownSymbol) {\n    return knownSymbol;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\nexport function getVerboseTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownName = map.get(mintAddress)?.name;\n  if (knownName) {\n    return knownName;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\n\nexport function getTokenByName(tokenMap: KnownTokenMap, name: string) {\n  let token: TokenInfo | null = null;\n  for (const val of tokenMap.values()) {\n    if (val.symbol === name) {\n      token = val;\n      break;\n    }\n  }\n  return token;\n}\n\nexport function getTokenIcon(\n  map: KnownTokenMap,\n  mintAddress?: string | PublicKey,\n): string | undefined {\n  const address =\n    typeof mintAddress === 'string' ? mintAddress : mintAddress?.toBase58();\n  if (!address) {\n    return;\n  }\n\n  return map.get(address)?.logoURI;\n}\n\nexport function isKnownMint(map: KnownTokenMap, mintAddress: string) {\n  return !!map.get(mintAddress);\n}\n\nexport const STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);\n\nexport function chunks<T>(array: T[], size: number): T[][] {\n  return Array.apply<number, T[], T[][]>(\n    0,\n    new Array(Math.ceil(array.length / size)),\n  ).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n\nexport function toLamports(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  return Math.floor(amount * precision);\n}\n\nexport function wadToLamports(amount?: BN): BN {\n  return amount?.div(WAD) || ZERO;\n}\n\nexport function fromLamports(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount = Math.floor(\n    typeof account === 'number'\n      ? account\n      : BN.isBN(account)\n      ? account.toNumber()\n      : account.info.amount.toNumber(),\n  );\n\n  const precision = Math.pow(10, mint?.decimals || 9);\n  return (amount / precision) * rate;\n}\n\nexport const tryParseKey = (key: string): PublicKey | null => {\n  try {\n    return new PublicKey(key);\n  } catch (error) {\n    return null;\n  }\n};\n\nvar SI_SYMBOL = ['', 'k', 'M', 'G', 'T', 'P', 'E'];\n\nconst abbreviateNumber = (number: number, precision: number) => {\n  let tier = (Math.log10(number) / 3) | 0;\n  let scaled = number;\n  let suffix = SI_SYMBOL[tier];\n  if (tier !== 0) {\n    let scale = Math.pow(10, tier * 3);\n    scaled = number / scale;\n  }\n\n  return scaled.toFixed(precision) + suffix;\n};\n\nexport const formatAmount = (\n  val: number,\n  precision: number = 2,\n  abbr: boolean = true,\n) => (abbr ? abbreviateNumber(val, precision) : val.toFixed(precision));\n\nexport function formatTokenAmount(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n  prefix = '',\n  suffix = '',\n  precision = 2,\n  abbr = false,\n): string {\n  if (!account) {\n    return '';\n  }\n\n  return `${[prefix]}${formatAmount(\n    fromLamports(account, mint, rate),\n    precision,\n    abbr,\n  )}${suffix}`;\n}\n\nexport const formatUSD = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n});\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n};\n\nexport const formatPct = new Intl.NumberFormat('en-US', {\n  style: 'percent',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport function convert(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  let result = (amount / precision) * rate;\n\n  return result;\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import { sleep, useLocalStorageState } from \"../utils/utils\";\nimport {\n  Keypair,\n  Commitment,\n  Connection,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n  Blockhash,\n  FeeCalculator,\n} from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport { notify } from \"../utils/notifications\";\nimport { ExplorerLink } from \"../components/ExplorerLink\";\nimport {\n  TokenInfo,\n  TokenListProvider,\n  ENV as ChainId,\n} from \"@solana/spl-token-registry\";\nimport { WalletSigner } from \"./WalletContext/WalletContext\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport type ENV = \"mainnet-beta\" | \"testnet\" | \"devnet\" | \"localnet\";\n\nexport const ENDPOINTS = [\n  {\n    name: \"mainnet-beta\" as ENV,\n    endpoint: \"https://api.mainnet-beta.solana.com\",\n    ChainId: ChainId.MainnetBeta,\n  },\n  {\n    name: \"devnet\" as ENV,\n    endpoint: \"https://api.devnet.solana.com\",\n    ChainId: ChainId.Devnet,\n  },\n];\n\nconst DEFAULT = ENDPOINTS[0].endpoint;\n\ninterface ConnectionConfig {\n  connection: Connection;\n  endpoint: string;\n  env: ENV;\n  setEndpoint: (val: string) => void;\n  tokens: TokenInfo[];\n  tokenMap: Map<string, TokenInfo>;\n}\n\nconst ConnectionContext = React.createContext<ConnectionConfig>({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map<string, TokenInfo>(),\n});\n\nexport function ConnectionProvider({ children = undefined as any }) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\n    \"connectionEndpoint\",\n    ENDPOINTS[0].endpoint\n  );\n\n  const connection = useMemo(\n    () => new Connection(endpoint, \"recent\"),\n    [endpoint]\n  );\n\n  const env =\n    ENDPOINTS.find((end) => end.endpoint === endpoint)?.name ||\n    ENDPOINTS[0].name;\n\n  const [tokens, setTokens] = useState<TokenInfo[]>([]);\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n  useEffect(() => {\n    // fetch token files\n    new TokenListProvider().resolve().then((container) => {\n      const list = container\n        .excludeByTag(\"nft\")\n        .filterByChainId(\n          ENDPOINTS.find((end) => end.endpoint === endpoint)?.ChainId ||\n            ChainId.MainnetBeta\n        )\n        .getList();\n\n      const knownMints = [...list].reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map<string, TokenInfo>());\n\n      setTokenMap(knownMints);\n      setTokens(list);\n    });\n  }, [env, endpoint]);\n\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n  useEffect(() => {\n    const id = connection.onAccountChange(\n      Keypair.generate().publicKey,\n      () => {}\n    );\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n\n  return (\n    <ConnectionContext.Provider\n      value={{\n        endpoint,\n        setEndpoint,\n        connection,\n        tokens,\n        tokenMap,\n        env,\n      }}\n    >\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection() {\n  return useContext(ConnectionContext).connection as Connection;\n}\n\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap,\n  };\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach((log) => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[][],\n  signers: Keypair[][]\n) {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength: any = null;\n  let toRemoveSigners: Record<number, boolean> = {};\n\n \n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          \"single\"\n        );\n        stopPoint = 1;\n      } else {\n        stopPoint = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          SequenceType.StopOnFailure,\n          \"single\"\n        );\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      \"Died on \",\n      stopPoint,\n      \"retrying from instruction\",\n      instructions[stopPoint],\n      \"instructions length is\",\n      instructions.length\n    );\n    lastInstructionsLength = instructions.length;\n  }\n}\n\nexport const sendTransactions = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructionSet: TransactionInstruction[][],\n  signersSet: Keypair[][],\n  sequenceType: SequenceType = SequenceType.Parallel,\n  commitment: Commitment = \"singleGossip\",\n  successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n  failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n  block?: BlockhashAndFeeCalculator\n): Promise<number> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns: Transaction[] = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach((instruction) => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n  let breakEarlyObject = { breakEarly: false, i: 0 };\n  console.log(\n    \"Signed txns length\",\n    signedTxns.length,\n    \"vs handed in length\",\n    instructionSet.length\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    signedTxnPromise\n      .then(({ txid, slot }) => {\n        successCallback(txid, i);\n      })\n      .catch((reason) => {\n        // @ts-ignore\n        failCallback(signedTxns[i], i);\n        if (sequenceType === SequenceType.StopOnFailure) {\n          breakEarlyObject.breakEarly = true;\n          breakEarlyObject.i = i;\n        }\n      });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log(\"Caught failure\", e);\n        if (breakEarlyObject.breakEarly) {\n          console.log(\"Died on \", breakEarlyObject.i);\n          return breakEarlyObject.i; // Return the txn we failed on by index\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    await Promise.all(pendingTxns);\n  }\n\n  return signedTxns.length;\n};\n\nexport const sendTransaction = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  awaitConfirmation = true,\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment\n    );\n\n    if (!confirmation)\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n      notify({\n        message: \"Transaction failed...\",\n        description: (\n          <>\n            {errors.map((err) => (\n              <div>{err}</div>\n            ))}\n            <ExplorerLink address={txid} type=\"transaction\" />\n          </>\n        ),\n        type: \"error\",\n      });\n\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    try {\n      transaction = await wallet.signTransaction(transaction);\n    } catch {\n      return false;\n    }\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n  console.log(\"About to send\");\n  try {\n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n\n    return { txid, slot };\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    }\n  );\n\n  console.log(\"Started awaiting confirmation for\", txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      \"recent\",\n      true\n    );\n\n    if (!confirmation)\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error(\"Transaction failed: Custom instruction error\");\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    console.error(\"Timeout Error caught\", err);\n    if ((err as any).timeout) {\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, \"single\")\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith(\"Program log: \")) {\n            throw new Error(\n              \"Transaction failed: \" + line.slice(\"Program log: \".length)\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log(\"Latency\", txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString(\"base64\");\n  const config: any = { encoding: \"base64\", commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"simulateTransaction\", args);\n  if (res.error) {\n    throw new Error(\"failed to simulate transaction: \" + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = \"recent\",\n  queryStatus = false\n): Promise<SignatureStatus | null | void> {\n\n  let endpoint = (connection as any)._rpcEndpoint;\n  let env = \"mainnet-beta\";\n  for (const cfg of ENDPOINTS) {\n    if (cfg.endpoint === endpoint) {\n      env = cfg.name;\n      break;\n    }\n  }\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log(\"Rejecting for timeout...\");\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log(\"Rejected via websocket\", result.err);\n            reject(status);\n          } else {\n            console.log(\"Resolved via websocket\", result);\n            resolve(status);\n          }\n        },\n        commitment\n      );\n    } catch (e) {\n      done = true;\n      console.error(\"WS error in setup\", txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          console.log(`https://explorer.solana.com/tx/${txid}?cluster=${env}`);\n          if (!done) {\n            if (!status) {\n              console.log(\"REST null result for\", txid, status);\n            } else if (status.err) {\n              console.log(\"REST error for\", txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log(\"REST no confirmations for\", txid, status);\n            } else {\n              console.log(\"REST confirmation for\", txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log(\"REST connection error: txid\", txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log(\"Returning status\", status);\n  return status;\n}\n"],"sourceRoot":""}