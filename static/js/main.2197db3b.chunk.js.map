{"version":3,"sources":["contexts/AccountContext.tsx","utils/programIds.ts","utils/notifications.tsx","components/ExplorerLink/index.tsx","utils/eventEmitter.ts","components/Settings/index.tsx","components/DefaultModal/index.tsx","actions/accept_offer.ts","utils/account.ts","components/TransferBox/index.tsx","contexts/WalletContext/wallet.less","contexts/WalletContext/WalletContext.tsx","contexts/ModalContext.tsx","contexts/ColorModeContext.tsx","utils/borsh.ts","utils/ids.ts","components/ConnectButton.tsx","components/Header/Header.tsx","App.tsx","reportWebVitals.ts","index.tsx","constants/math.ts","utils/utils.ts","contexts/ConnectionContext.tsx"],"names":["AccountsContext","React","createContext","pendingCalls","Map","genericCache","pendingMintCalls","mintCache","getMintInfo","connection","pubKey","a","getAccountInfo","info","Error","data","Buffer","from","deserializeMint","TokenAccountParser","length","buffer","deserializeAccount","pubkey","account","keyToAccountParser","cache","emitter","EventEmitter","query","parser","id","PublicKey","address","toBase58","get","then","add","set","obj","isActive","deserialize","registerParser","delete","undefined","Function","isNew","has","raiseCacheUpdated","key","raiseCacheDeleted","byParser","result","keys","push","queryMint","mint","getMint","addMint","UseNativeAccount","useConnection","publicKey","useWallet","useState","nativeAccount","setNativeAccount","updateCache","useCallback","wrapped","WRAPPED_SOL_MINT","owner","amount","u64","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","wrapNativeAccount","useEffect","subId","updateAccount","onAccountChange","removeAccountChangeListener","PRECACHED_OWNERS","Set","precacheUserTokenAccounts","getTokenAccountsByOwner","programId","programIds","token","value","forEach","AccountsProvider","children","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","walletKey","selectUserAccounts","map","filter","accounts","subs","onCache","args","tokenSubID","onProgramAccountChange","accountId","accountInfo","AccountLayout","span","removeProgramAccountChangeListener","Provider","decode","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","MintLayout","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority","TOKEN_PROGRAM_ID","associatedToken","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","bpf_upgrade_loader","BPF_UPGRADE_LOADER_ID","system","SYSTEM","memo","MEMO_ID","notify","message","description","txid","type","placement","notification","style","color","opacity","backgroundColor","ExplorerLink","props","code","href","target","title","Text","shortenAddress","CacheUpdateEvent","this","CacheDeleteEvent","MarketUpdateEvent","ids","Emitter","callback","on","removeListener","emit","Settings","additionalSettings","connected","disconnect","useConnectionConfig","setEndpoint","endpoint","env","setVisible","useWalletModal","open","setModal","useModal","theme","useTheme","colorModeCtx","useColorMode","handleConnect","ModalEnum","WALLET","sx","display","minWidth","marginBottom","onChange","e","ENDPOINTS","name","variant","onClick","marginLeft","navigator","clipboard","writeText","catch","ml","toggleColorMode","palette","mode","DefaultModal","bodyStyle","closeIcon","rest","background","borderRadius","flexDirection","alignItems","footer","width","PROGRAM_ID","AcceptOfferArgs","instruction","makerSize","takerSize","bumpSeed","schema","kind","fields","acceptOfferInstruction","makerWallet","takerWallet","makerSrc","makerDst","takerSrc","takerDst","makerSrcMint","takerSrcMint","transferAuthority","settings","serialize","isSigner","isWritable","NATIVE_MINT","SystemProgram","ix","TransactionInstruction","changeOffer","mintA","mintB","sizeA","sizeB","wallet","approve","signers","ataIx","findProgramAddress","toBuffer","tokenAccountMintA","tokenAccountMintB","createAssociatedTokenAccountInstruction","Uint8Array","toArray","authIx","Token","createApproveInstruction","toNumber","createRevokeInstruction","Conn","sendTransactionWithRetry","trade","maker","makerAccountMintA","makerAccountMintB","takerAccountMintA","takerAccountMintB","hasATAMintB","console","log","bump","tradeIx","instructions","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","SYSVAR_RENT_PUBKEY","MINTS","getSize","n","dec","decimals","Math","floor","parseFloat","pow","getDelegate","formState","BN","displayActions","isSeller","hasDelegate","hasValidDelegate","validAmount","mintEntered","marginRight","TransferBox","url","URL","window","location","params","URLSearchParams","search","slice","defaultState","getDefaultFormState","setFormState","accountState","setAccountState","setMintCache","setIsSeller","setValidAmount","setHasDelegate","setHasValidDelegate","setOpen","tokenMap","setTokenMap","TokenListProvider","resolve","tokens","tokenList","filterByChainId","ENV","Devnet","getList","MainnetBeta","Testnet","reduce","item","symbol","validate","tokenAccount","totalAmount","size","fetchAccountState","sellerWallet","sellerMint","sellerTokenAccount","fetchMintState","mintString","mintData","setField","escape","newUrl","protocol","host","pathname","toString","history","pushState","path","getField","handleEnter","component","m","justifyContent","noValidate","autoComplete","w","focus","required","label","textAlign","labelId","input","onClose","onOpen","renderValue","selected","onKeyPress","getTokenKeys","InputLabelProps","shrink","marginTop","WalletModalContext","useContext","WalletModal","wallets","select","visible","setShowWallets","close","onCancel","height","verticalAlign","fontWeight","fontSize","lineHeight","icon","alt","src","float","WalletModalProvider","setConnected","base58","keyToDisplay","substring","WalletProvider","useMemo","getPhantomWallet","getSolflareWallet","getTorusWallet","options","clientId","getLedgerWallet","getSolongWallet","getMathWallet","getSolletWallet","onError","error","autoConnect","ModalContext","removeModal","context","ColorModeContext","ColorModeContextProvider","setMode","prevMode","BinaryReader","prototype","readPubkey","array","readFixedArray","BinaryWriter","writePubkey","writeFixedArray","readPubkeyAsString","encode","writePubkeyAsString","ConnectButton","isConnected","onClickConnect","onClickChange","restProps","ButtonGroup","Header","handleChange","Box","bgcolor","flexGrow","App","createTheme","className","ThemeProvider","CssBaseline","py","px","alignSelf","alignContent","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","TEN","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","useLocalStorageState","storedState","localStorage","getItem","JSON","parse","setState","setLocalStorageState","newState","removeItem","setItem","stringify","chars","chunks","Array","apply","ceil","_","index","currency","sleep","ms","Promise","setTimeout","ChainId","DEFAULT","ConnectionContext","Connection","ConnectionProvider","find","end","setTokens","container","list","excludeByTag","knownMints","Keypair","generate","onSlotChange","removeSlotChangeListener","SequenceType","getErrorForTransaction","confirmTransaction","getParsedConfirmedTransaction","tx","errors","meta","logMessages","regex","exec","lastIndex","sendTransactionsWithManualRetry","stopPoint","tries","lastInstructionsLength","toRemoveSigners","instr","i","filteredSigners","sendTransactions","StopOnFailure","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","transaction","Transaction","recentBlockhash","blockhash","setSigners","s","partialSign","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","signedTxnPromise","sendSignedTransaction","signedTransaction","slot","reason","all","sendTransaction","awaitConfirmation","includesFeePayer","signTransaction","rawTransaction","skipPreflight","sendRawTransaction","awaitTransactionSignatureConfirmation","DEFAULT_TIMEOUT","confirmation","err","beforeSend","getUnixTs","Date","getTime","timeout","startTime","done","simulateResult","simulateTransaction","logs","line","startsWith","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","encoding","_rpcRequest","res","queryStatus","status","confirmations","reject","onSignature","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener"],"mappings":"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","file":"static/js/main.2197db3b.chunk.js","sourcesContent":["import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react';\nimport { useConnection } from './ConnectionContext';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\nimport { AccountLayout, MintInfo, MintLayout, u64 } from '@solana/spl-token';\nimport { TokenAccount } from '../models';\nimport { chunks } from '../utils/utils';\nimport { EventEmitter } from '../utils/eventEmitter';\nimport { StringPublicKey, WRAPPED_SOL_MINT } from '../utils/ids';\nimport { programIds } from '../utils/programIds';\n\nconst AccountsContext = React.createContext<any>(null);\n\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\nconst genericCache = new Map<string, ParsedAccountBase>();\nconst pendingMintCalls = new Map<string, Promise<MintInfo>>();\nconst mintCache = new Map<string, MintInfo>();\n\nexport interface ParsedAccountBase {\n  pubkey: StringPublicKey;\n  account: AccountInfo<Buffer>;\n  info: any; // TODO: change to unknown\n}\n\nexport type AccountParser = (\n  pubkey: StringPublicKey,\n  data: AccountInfo<Buffer>,\n) => ParsedAccountBase | undefined;\n\nexport interface ParsedAccount<T> extends ParsedAccountBase {\n  info: T;\n}\n\nconst getMintInfo = async (connection: Connection, pubKey: PublicKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n  if (info === null) {\n    throw new Error('Failed to find mint account');\n  }\n\n  const data = Buffer.from(info.data);\n\n  return deserializeMint(data);\n};\n\nexport const MintParser = (pubKey: string, info: AccountInfo<Buffer>) => {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeMint(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const TokenAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  // Sometimes a wrapped sol account gets closed, goes to 0 length,\n  // triggers an update over wss which triggers this guy to get called\n  // since your UI already logged that pubkey as a token account. Check for length.\n  if (info.data.length > 0) {\n    const buffer = Buffer.from(info.data);\n    const data = deserializeAccount(buffer);\n\n    const details = {\n      pubkey: pubKey,\n      account: {\n        ...info,\n      },\n      info: data,\n    } as TokenAccount;\n\n    return details;\n  }\n};\n\nexport const GenericAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  const buffer = Buffer.from(info.data);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: buffer,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const keyToAccountParser = new Map<string, AccountParser>();\n\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (\n    connection: Connection,\n    pubKey: string | PublicKey,\n    parser?: AccountParser,\n  ) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = genericCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    // TODO: refactor to use multiple accounts query with flush like behavior\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error('Account not found');\n      }\n\n      return cache.add(id, data, parser);\n    }) as Promise<TokenAccount>;\n    pendingCalls.set(address, query as any);\n\n    return query;\n  },\n  add: (\n    id: PublicKey | string,\n    obj: AccountInfo<Buffer>,\n    parser?: AccountParser,\n    isActive?: boolean | undefined | ((parsed: any) => boolean),\n  ) => {\n    const address = typeof id === 'string' ? id : id?.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n    if (!deserialize) {\n      throw new Error(\n        'Deserializer needs to be registered or passed as a parameter',\n      );\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(address, obj);\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;\n    else if (isActive instanceof Function) isActive = isActive(account);\n\n    const isNew = !genericCache.has(address);\n\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n    return false;\n  },\n\n  byParser: (parser: AccountParser) => {\n    const result: string[] = [];\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey: PublicKey | string, parser: AccountParser) => {\n    if (pubkey) {\n      const address = typeof pubkey === 'string' ? pubkey : pubkey?.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: async (connection: Connection, pubKey: string | PublicKey) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let mint = mintCache.get(address);\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingMintCalls.delete(address);\n\n      mintCache.set(address, data);\n      return data;\n    }) as Promise<MintInfo>;\n    pendingMintCalls.set(address, query as any);\n\n    return query;\n  },\n  getMint: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\n    const mint = deserializeMint(obj.data);\n    const id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  },\n};\n\nexport const useAccountsContext = () => {\n  const context = useContext(AccountsContext);\n\n  return context;\n};\n\nfunction wrapNativeAccount(\n  pubkey: string,\n  account?: AccountInfo<Buffer>,\n): TokenAccount | undefined {\n  if (!account) {\n    return undefined;\n  }\n\n  const key = new PublicKey(pubkey);\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: key,\n      mint: WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null,\n    },\n  };\n}\n\nexport const getCachedAccount = (\n  predicate: (account: TokenAccount) => boolean,\n) => {\n  for (const account of genericCache.values()) {\n    if (predicate(account)) {\n      return account as TokenAccount;\n    }\n  }\n};\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\n\n  const updateCache = useCallback(\n    account => {\n      if (publicKey) {\n        const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n        if (wrapped !== undefined) {\n          const id = publicKey.toBase58();\n          cache.registerParser(id, TokenAccountParser);\n          genericCache.set(id, wrapped as TokenAccount);\n          cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser, true);\n        }\n      }\n    },\n    [publicKey],\n  );\n\n  useEffect(() => {\n    let subId = 0;\n    const updateAccount = (account: AccountInfo<Buffer> | null) => {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    (async () => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      try {\n        const account = await connection.getAccountInfo(publicKey);\n        updateAccount(account);\n      } catch {\n        return;\n      }\n\n      subId = connection.onAccountChange(publicKey, updateAccount);\n    })();\n\n    return () => {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n\n  return { nativeAccount };\n};\n\nconst PRECACHED_OWNERS = new Set<string>();\nconst precacheUserTokenAccounts = async (\n  connection: Connection,\n  owner?: PublicKey,\n) => {\n  if (!owner) {\n    return;\n  }\n\n  // used for filtering account updates over websocket\n  PRECACHED_OWNERS.add(owner.toBase58());\n\n  // user accounts are updated via ws subscription\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token,\n  });\n\n  accounts.value.forEach(info => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({ children = null as any }) {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\n  const { nativeAccount } = UseNativeAccount();\n  const walletKey = publicKey?.toBase58();\n\n  const selectUserAccounts = useCallback(() => {\n    return cache\n      .byParser(TokenAccountParser)\n      .map(id => cache.get(id))\n      .filter(a => a && a.info.owner.toBase58() === walletKey)\n      .map(a => a as TokenAccount);\n  }, [walletKey]);\n\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(\n      a => a !== undefined,\n    ) as TokenAccount[];\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n\n  useEffect(() => {\n    const subs: number[] = [];\n    cache.emitter.onCache(args => {\n      if (args.isNew && args.isActive) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), info => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      });\n\n      // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n      const tokenSubID = connection.onProgramAccountChange(\n        programIds().token,\n        info => {\n          // TODO: fix type in web3.js\n          const id = info.accountId as unknown as string;\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n          if (info.accountInfo.data.length === AccountLayout.span) {\n            const data = deserializeAccount(info.accountInfo.data);\n\n            if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n              cache.add(id, info.accountInfo, TokenAccountParser);\n              setTokenAccounts(selectUserAccounts());\n            }\n          }\n        },\n        'singleGossip',\n      );\n\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n\n  return (\n    <AccountsContext.Provider\n      value={{\n        userAccounts,\n        nativeAccount,\n      }}\n    >\n      {children}\n    </AccountsContext.Provider>\n  );\n}\n\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount as AccountInfo<Buffer>,\n  };\n}\n\nexport const getMultipleAccounts = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const result = await Promise.all(\n    chunks(keys, 99).map(chunk =>\n      getMultipleAccountsCore(connection, chunk, commitment),\n    ),\n  );\n\n  const array = result\n    .map(\n      a =>\n        a.array.map(acc => {\n          if (!acc) {\n            return undefined;\n          }\n\n          const { data, ...rest } = acc;\n          const obj = {\n            ...rest,\n            data: Buffer.from(data[0], 'base64'),\n          } as AccountInfo<Buffer>;\n          return obj;\n        }) as AccountInfo<Buffer>[],\n    )\n    .flat();\n  return { keys, array };\n};\n\nconst getMultipleAccountsCore = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const args = connection._buildArgs([keys], commitment, 'base64');\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  if (unsafeRes.error) {\n    throw new Error(\n      'failed to get info about account ' + unsafeRes.error.message,\n    );\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\n    return { keys, array };\n  }\n\n  // TODO: fix\n  throw new Error();\n};\n\nexport function useMint(key?: string | PublicKey) {\n  const connection = useConnection();\n  const [mint, setMint] = useState<MintInfo>();\n\n  const id = typeof key === 'string' ? key : key?.toBase58();\n\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache\n      .query(connection, id, MintParser)\n      .then(acc => setMint(acc.info as any))\n      .catch(err => console.log(err));\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === id) {\n        cache\n          .query(connection, id, MintParser)\n          .then(mint => setMint(mint.info as any));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n\n  return mint;\n}\n\nexport function useAccount(pubKey?: PublicKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState<TokenAccount>();\n\n  const key = pubKey?.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache\n          .query(connection, key, TokenAccountParser)\n          .catch(err => console.log(err));\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n\n  return account;\n}\n\n// TODO: expose in spl package\nexport const deserializeAccount = (data: Buffer) => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n\n// TODO: expose in spl package\nexport const deserializeMint = (data: Buffer) => {\n  if (data.length !== MintLayout.span) {\n    throw new Error('Not a valid Mint');\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as MintInfo;\n};\n","import {\n  TOKEN_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  BPF_UPGRADE_LOADER_ID,\n  SYSTEM,\n  MEMO_ID,\n} from './ids';\n\nexport const setProgramIds = async () => {};\n\nexport const programIds = () => {\n  return {\n    token: TOKEN_PROGRAM_ID,\n    associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    bpf_upgrade_loader: BPF_UPGRADE_LOADER_ID,\n    system: SYSTEM,\n    memo: MEMO_ID,\n    // store: STORE,\n  };\n};\n","import React from 'react';\nimport { notification } from 'antd';\n// import Link from '../components/Link';\n\nexport function notify({\n  message = '',\n  description = undefined as any,\n  txid = '',\n  type = 'info',\n  placement = 'bottomLeft',\n}) {\n  if (txid) {\n    //   <Link\n    //     external\n    //     to={'https://explorer.solana.com/tx/' + txid}\n    //     style={{ color: '#0000ff' }}\n    //   >\n    //     View transaction {txid.slice(0, 8)}...{txid.slice(txid.length - 8)}\n    //   </Link>\n\n    description = <></>;\n  }\n  (notification as any)[type]({\n    message: <span style={{ color: 'black' }}>{message}</span>,\n    description: (\n      <span style={{ color: 'black', opacity: 0.5 }}>{description}</span>\n    ),\n    placement,\n    style: {\n      backgroundColor: 'white',\n    },\n  });\n}\n","import React from 'react';\nimport { Typography } from 'antd';\nimport { shortenAddress } from '../../utils/utils';\nimport { PublicKey } from '@solana/web3.js';\n\nexport const ExplorerLink = (props: {\n  address: string | PublicKey;\n  type: string;\n  code?: boolean;\n  style?: React.CSSProperties;\n  length?: number;\n}) => {\n  const { type, code } = props;\n\n  const address =\n    typeof props.address === 'string'\n      ? props.address\n      : props.address?.toBase58();\n\n  if (!address) {\n    return null;\n  }\n\n  const length = props.length ?? 9;\n\n  return (\n    <a\n      href={`https://explorer.solana.com/${type}/${address}`}\n      target=\"_blank\"\n      title={address}\n      style={props.style}\n    >\n      {code ? (\n        <Typography.Text style={props.style} code>\n          {shortenAddress(address, length)}\n        </Typography.Text>\n      ) : (\n        shortenAddress(address, length)\n      )}\n    </a>\n  );\n};\n","import { EventEmitter as Emitter } from 'eventemitter3';\n\nexport class CacheUpdateEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  parser: any;\n  isNew: boolean;\n  isActive: boolean;\n  constructor(id: string, isNew: boolean, parser: any, isActive: boolean) {\n    this.id = id;\n    this.parser = parser;\n    this.isNew = isNew;\n    this.isActive = isActive;\n  }\n}\n\nexport class CacheDeleteEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n\nexport class MarketUpdateEvent {\n  static type = 'MarketUpdate';\n  ids: Set<string>;\n  constructor(ids: Set<string>) {\n    this.ids = ids;\n  }\n}\n\nexport class EventEmitter {\n  private emitter = new Emitter();\n\n  onMarket(callback: (args: MarketUpdateEvent) => void) {\n    this.emitter.on(MarketUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(MarketUpdateEvent.type, callback);\n  }\n\n  onCache(callback: (args: CacheUpdateEvent) => void) {\n    this.emitter.on(CacheUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(CacheUpdateEvent.type, callback);\n  }\n\n  raiseMarketUpdated(ids: Set<string>) {\n    this.emitter.emit(MarketUpdateEvent.type, new MarketUpdateEvent(ids));\n  }\n\n  raiseCacheUpdated(\n    id: string,\n    isNew: boolean,\n    parser: any,\n    isActive: boolean,\n  ) {\n    this.emitter.emit(\n      CacheUpdateEvent.type,\n      new CacheUpdateEvent(id, isNew, parser, isActive),\n    );\n  }\n\n  raiseCacheDeleted(id: string) {\n    this.emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));\n  }\n}\n","import React, { useCallback } from \"react\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { ENDPOINTS, useColorMode, useConnectionConfig } from \"../../contexts\";\nimport { notify, shortenAddress } from \"../../utils\";\nimport { CopyOutlined } from \"@ant-design/icons\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport { Box, flexbox } from \"@mui/system\";\nimport { Button, NativeSelect } from \"@mui/material\";\nimport { useTheme } from \"@mui/material/styles\";\nimport IconButton from \"@mui/material/IconButton\";\nimport Brightness4Icon from \"@mui/icons-material/Brightness4\";\nimport Brightness7Icon from \"@mui/icons-material/Brightness7\";\n\nexport const Settings = ({\n  additionalSettings,\n}: {\n  additionalSettings?: JSX.Element;\n}) => {\n  const { connected, disconnect, publicKey } = useWallet();\n  const { endpoint, setEndpoint, env } = useConnectionConfig();\n  const { setVisible } = useWalletModal();\n  const open = useCallback(() => setVisible(true), [setVisible]);\n  const { setModal } = useModal();\n  const theme = useTheme();\n  const colorModeCtx = useColorMode();\n\n  const handleConnect = useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n\n  return (\n    <>\n      <Box sx={{ display: \"flex\", minWidth: \"100%\" }}>\n        {!connected && (\n          <>\n            <NativeSelect style={{ marginBottom: 5 }} onChange={(e) => setEndpoint(e.target.value)}>\n              {ENDPOINTS.map(({ name, endpoint }) => (\n                <option value={endpoint}>{name}</option>\n              ))}\n            </NativeSelect>\n            <Button\n              variant=\"contained\"\n              onClick={handleConnect}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Connect\n            </Button>\n          </>\n        )}\n        {connected && (\n          <>\n            {publicKey && (\n              <Button\n                variant=\"outlined\"\n                onClick={async () => {\n                  if (publicKey) {\n                    await navigator.clipboard.writeText(publicKey.toBase58());\n                    notify({\n                      message: \"Wallet update\",\n                      description: \"Address copied to clipboard\",\n                    });\n                  }\n                }}\n              >\n                <CopyOutlined />\n                {shortenAddress(publicKey.toBase58())}\n              </Button>\n            )}\n            <Button\n              variant=\"outlined\"\n              onClick={open}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Change Wallet\n            </Button>\n            <Button\n              variant=\"contained\"\n              color=\"error\"\n              onClick={() => disconnect().catch()}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Disconnect ({env})\n            </Button>\n          </>\n        )}\n        <IconButton\n          sx={{ ml: 1 }}\n          onClick={colorModeCtx.toggleColorMode}\n          color=\"inherit\"\n        >\n          {theme.palette.mode === \"dark\" ? (\n            <Brightness7Icon />\n          ) : (\n            <Brightness4Icon />\n          )}\n        </IconButton>\n        {additionalSettings}\n      </Box>\n    </>\n  );\n};\n","import React from \"react\";\nimport { Modal } from \"antd\";\n\nimport \"./index.css\";\n\nexport const DefaultModal = (props: any) => {\n  const { children, closeIcon, bodyStyle, style, ...rest } = props;\n\n  return (\n    <Modal\n      style={{ background: \"transparent\", borderRadius: 16 }}\n      bodyStyle={{\n        background: \"#333333\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        ...bodyStyle,\n      }}\n      footer={null}\n      width={400}\n      {...rest}\n    >\n      {children}\n    </Modal>\n  );\n};\n","import {\n  SystemProgram,\n  TransactionInstruction,\n  PublicKey,\n  Keypair,\n} from \"@solana/web3.js\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\nimport { Connection as Conn } from \"../contexts\";\nimport BN from \"bn.js\";\nimport {\n  notify,\n  createAssociatedTokenAccountInstruction,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from \"../utils\";\nimport { Schema, serialize } from \"borsh\";\nimport { TOKEN_PROGRAM_ID, Token, NATIVE_MINT } from \"@solana/spl-token\";\n\n// Hard-coded devnet key for now\nexport const PROGRAM_ID = new PublicKey(\n  \"SAtnofysr9Uxk7m9YphxwfL5E3wyZJWUzjwA29Gw3tQ\"\n);\n\nexport class AcceptOfferArgs {\n  instruction: number = 0;\n  makerSize: BN;\n  takerSize: BN;\n  bumpSeed: number;\n\n  static schema: Schema = new Map([\n    [\n      AcceptOfferArgs,\n      {\n        kind: \"struct\",\n        fields: [\n          [\"instruction\", \"u8\"],\n          [\"makerSize\", \"u64\"],\n          [\"takerSize\", \"u64\"],\n          [\"bumpSeed\", \"u8\"],\n        ],\n      },\n    ],\n  ]);\n\n  constructor(args: { makerSize: BN; takerSize: BN; bumpSeed: number }) {\n    this.makerSize = args.makerSize;\n    this.takerSize = args.takerSize;\n    this.bumpSeed = args.bumpSeed;\n  }\n}\n\nexport const acceptOfferInstruction = async (\n  makerWallet: PublicKey,\n  takerWallet: PublicKey,\n  makerSrc: PublicKey,\n  makerDst: PublicKey,\n  takerSrc: PublicKey,\n  takerDst: PublicKey,\n  makerSrcMint: PublicKey,\n  takerSrcMint: PublicKey,\n  transferAuthority: PublicKey,\n  makerSize: BN,\n  takerSize: BN,\n  bumpSeed: number\n) => {\n  let settings = new AcceptOfferArgs({ makerSize, takerSize, bumpSeed });\n  const data = Buffer.from(serialize(AcceptOfferArgs.schema, settings));\n  let keys = [\n    {\n      pubkey: makerWallet,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: takerWallet,\n      isSigner: true,\n      isWritable: false,\n    },\n    {\n      pubkey: makerSrc,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: makerDst,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: takerSrc,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: takerDst,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: makerSrcMint,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: takerSrcMint,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: transferAuthority,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n  ]\n  if (takerSrcMint.toBase58() === NATIVE_MINT.toBase58()) {\n    keys.push(\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      }\n    )\n  }\n  return {\n    ix: [\n      new TransactionInstruction({\n        keys,\n        programId: PROGRAM_ID,\n        data,\n      }),\n    ],\n  };\n};\n\nexport const changeOffer = async (\n  connection,\n  mintA: PublicKey,\n  mintB: PublicKey,\n  sizeA: BN,\n  sizeB: BN,\n  wallet: any,\n  approve = true\n) => {\n  if (!wallet.publicKey) {\n    notify({ message: \"Wallet not connected!\" });\n    return false;\n  }\n  let signers: Keypair[] = [];\n  let ataIx: TransactionInstruction[] = [];\n\n  const tokenAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintA.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintA = await connection.getAccountInfo(tokenAccountMintA);\n  if (!hasATAMintA) {\n    notify({ message: \"User must have ATA to create offer\" });\n    return false;\n  }\n\n  let tokenAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintB.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintB = await connection.getAccountInfo(tokenAccountMintB);\n  if (!hasATAMintB) {\n    createAssociatedTokenAccountInstruction(\n      ataIx,\n      tokenAccountMintB,\n      wallet.publicKey,\n      wallet.publicKey,\n      mintB\n    );\n  }\n  tokenAccountMintB = mintB.toBase58() === NATIVE_MINT.toBase58() ? wallet.publicKey : tokenAccountMintB;\n  const [transferAuthority, bump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"stateless_offer\"),\n      wallet.publicKey.toBuffer(),\n      mintA.toBuffer(),\n      mintB.toBuffer(),\n      new Uint8Array(sizeA.toArray(\"le\", 8)),\n      new Uint8Array(sizeB.toArray(\"le\", 8)),\n    ],\n    PROGRAM_ID\n  );\n  let authIx;\n  if (approve) {\n    authIx = Token.createApproveInstruction(\n      TOKEN_PROGRAM_ID,\n      tokenAccountMintA,\n      transferAuthority,\n      wallet.publicKey,\n      [],\n      sizeA.toNumber(),\n    );\n  } else {\n    authIx = Token.createRevokeInstruction(\n      TOKEN_PROGRAM_ID,\n      tokenAccountMintA,\n      wallet.publicKey,\n      []\n    );\n  }\n  const response = await Conn.sendTransactionWithRetry(\n    connection,\n    wallet,\n    [...ataIx, authIx],\n    signers,\n    \"max\"\n  );\n  if (!response) {\n    notify({ message: \"Delegation transaction failed\" });\n    return false;\n  } else {\n    return true;\n  }\n};\n\nexport const trade = async (\n  connection,\n  maker: PublicKey,\n  mintA: PublicKey,\n  mintB: PublicKey,\n  sizeA: BN,\n  sizeB: BN,\n  wallet: any,\n) => {\n  if (!wallet.publicKey) {\n    notify({ message: \"Wallet not connected!\" });\n    return false;\n  }\n  let signers: Keypair[] = [];\n  let ataIx: TransactionInstruction[] = [];\n\n  const makerAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [maker.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintA.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  if (!(await connection.getAccountInfo(makerAccountMintA))) {\n    notify({ message: \"Maker must have ATA for mint A\" });\n    return false;\n  }\n\n  let makerAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [maker.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintB.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  if (!(await connection.getAccountInfo(makerAccountMintB))) {\n    notify({ message: \"Maker must have ATA for mint B\" });\n    return false;\n  }\n\n  const takerAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintA.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintA = await connection.getAccountInfo(takerAccountMintA);\n  if (!hasATAMintA) {\n    createAssociatedTokenAccountInstruction(\n      ataIx,\n      takerAccountMintA,\n      wallet.publicKey,\n      wallet.publicKey,\n      mintA\n    );\n  }\n\n  let takerAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintB.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintB = await connection.getAccountInfo(\n    new PublicKey(takerAccountMintB)\n  );\n  console.log(mintB.toBase58())\n  console.log(NATIVE_MINT)\n  if (!hasATAMintB && mintB.toBase58() != NATIVE_MINT.toBase58()) {\n    notify({ message: \"Taker must have ATA for mint B\" });\n    return false;\n  }\n\n  makerAccountMintB = mintB.toBase58() === NATIVE_MINT.toBase58() ? maker : makerAccountMintB;\n  takerAccountMintB =  mintB.toBase58() === NATIVE_MINT.toBase58() ? wallet.publicKey : takerAccountMintB;\n  const [transferAuthority, bump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"stateless_offer\"),\n      maker.toBuffer(),\n      mintA.toBuffer(),\n      mintB.toBuffer(),\n      new Uint8Array(sizeA.toArray(\"le\", 8)),\n      new Uint8Array(sizeB.toArray(\"le\", 8)),\n    ],\n    PROGRAM_ID\n  );\n\n  let { ix } = await acceptOfferInstruction(\n    maker,\n    wallet.publicKey,\n    makerAccountMintA,\n    makerAccountMintB,\n    takerAccountMintB,\n    takerAccountMintA,\n    mintA,\n    mintB,\n    transferAuthority,\n    sizeA,\n    sizeB,\n    bump\n  );\n  const tradeIx = ix;\n\n  const response = await Conn.sendTransactionWithRetry(\n    connection,\n    wallet,\n    [...ataIx, ...tradeIx],\n    signers,\n    \"max\"\n  );\n  if (!response) {\n    notify({ message: \"Trade transaction failed\" });\n    return false;\n  } else {\n    notify({ message: \"Trade successful\" });\n    return true;\n  }\n};\n","import { AccountLayout, MintLayout, Token } from '@solana/spl-token';\nimport {\n  Account,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport {\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n  WRAPPED_SOL_MINT,\n} from '../utils/ids';\nimport { programIds } from '../utils/programIds';\nimport { TokenAccount } from '../models/account';\nimport { cache, TokenAccountParser } from '../contexts/AccountContext';\n\nexport function ensureSplAccount(\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  toCheck: TokenAccount,\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  if (!toCheck.info.isNative) {\n    return toCheck.pubkey;\n  }\n\n  const account = createUninitializedAccount(\n    instructions,\n    payer,\n    amount,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      WRAPPED_SOL_MINT,\n      account,\n      payer,\n    ),\n  );\n\n  cleanupInstructions.push(\n    Token.createCloseAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      account,\n      payer,\n      payer,\n      [],\n    ),\n  );\n\n  return account;\n}\n\nexport const DEFAULT_TEMP_MEM_SPACE = 65548;\n\nexport function createTempMemoryAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  signers: Keypair[],\n  owner: PublicKey,\n  space = DEFAULT_TEMP_MEM_SPACE,\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      // 0 will evict/close account since it cannot pay rent\n      lamports: 0,\n      space: space,\n      programId: owner,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createUninitializedMint(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: MintLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createUninitializedAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: AccountLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createAssociatedTokenAccountInstruction(\n  instructions: TransactionInstruction[],\n  associatedTokenAddress: PublicKey,\n  payer: PublicKey,\n  walletAddress: PublicKey,\n  splTokenMintAddress: PublicKey,\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  instructions.push(\n    new TransactionInstruction({\n      keys,\n      programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n      data: Buffer.from([]),\n    }),\n  );\n}\n\nexport function createMint(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  mintRentExempt: number,\n  decimals: number,\n  owner: PublicKey,\n  freezeAuthority: PublicKey,\n  signers: Keypair[],\n) {\n  const account = createUninitializedMint(\n    instructions,\n    payer,\n    mintRentExempt,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      account,\n      decimals,\n      owner,\n      freezeAuthority,\n    ),\n  );\n\n  return account;\n}\n\nexport function createMintFromAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  decimals: number,\n  owner: PublicKey,\n  freezeAuthority: PublicKey,\n  account: Keypair,\n) {\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: MintLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n  instructions.push(\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      account.publicKey,\n      decimals,\n      owner,\n      freezeAuthority,\n    ),\n  );\n  return account;\n}\n\nexport function createTokenAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  accountRentExempt: number,\n  mint: PublicKey,\n  owner: PublicKey,\n  signers: Keypair[],\n) {\n  const account = createUninitializedAccount(\n    instructions,\n    payer,\n    accountRentExempt,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, account, owner),\n  );\n\n  return account;\n}\n\nexport function ensureWrappedAccount(\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  toCheck: TokenAccount | undefined,\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  if (toCheck && !toCheck.info.isNative) {\n    return toCheck.pubkey;\n  }\n\n  const TOKEN_PROGRAM_ID = programIds().token;\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: AccountLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      WRAPPED_SOL_MINT,\n      account.publicKey,\n      payer,\n    ),\n  );\n\n  cleanupInstructions.push(\n    Token.createCloseAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      account.publicKey,\n      payer,\n      payer,\n      [],\n    ),\n  );\n\n  signers.push(account);\n\n  return account.publicKey.toBase58();\n}\n\n// TODO: check if one of to accounts needs to be native sol ... if yes unwrap it ...\nexport function findOrCreateAccountByMint(\n  payer: PublicKey,\n  owner: PublicKey,\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  accountRentExempt: number,\n  mint: PublicKey, // use to identify same type\n  signers: Keypair[],\n  excluded?: Set<string>,\n): PublicKey {\n  const accountToFind = mint.toBase58();\n  const ownerKey = owner.toBase58();\n  const account = cache\n    .byParser(TokenAccountParser)\n    .map(id => cache.get(id))\n    .find(\n      acc =>\n        acc !== undefined &&\n        acc.info.mint.toBase58() === accountToFind &&\n        acc.info.owner.toBase58() === ownerKey &&\n        (excluded === undefined || !excluded.has(acc.pubkey)),\n    );\n  const isWrappedSol = accountToFind === WRAPPED_SOL_MINT.toBase58();\n\n  let toAccount: PublicKey;\n  if (account && !isWrappedSol) {\n    toAccount = new PublicKey(account.pubkey);\n  } else {\n    // creating depositor pool account\n    toAccount = createTokenAccount(\n      instructions,\n      payer,\n      accountRentExempt,\n      mint,\n      owner,\n      signers,\n    );\n\n    if (isWrappedSol) {\n      cleanupInstructions.push(\n        Token.createCloseAccountInstruction(\n          TOKEN_PROGRAM_ID,\n          toAccount,\n          payer,\n          payer,\n          [],\n        ),\n      );\n    }\n  }\n\n  return toAccount;\n}","import React, { useEffect, useState } from \"react\";\nimport Box from \"@mui/material/Box\";\nimport Button from \"@mui/material/Button\";\nimport {\n  Select,\n  FormControl,\n  OutlinedInput,\n  InputLabel,\n  MenuItem,\n  Input,\n} from \"@mui/material\";\nimport LoadingButton from '@mui/lab/LoadingButton';\nimport TextField from \"@mui/material/TextField\";\nimport {\n  cache,\n  useConnection,\n  deserializeAccount,\n  deserializeMint,\n  useConnectionConfig,\n} from \"../../contexts\";\nimport { FormControlUnstyled } from \"@mui/material\";\nimport {\n  notify,\n  createAssociatedTokenAccountInstruction,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from \"../../utils\";\nimport { Schema, serialize } from \"borsh\";\nimport { TOKEN_PROGRAM_ID, Token, NATIVE_MINT } from \"@solana/spl-token\";\nimport { changeOffer, trade } from \"../../actions/accept_offer\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport tokenlist, { ENV, TokenInfo, TokenListProvider } from \"@solana/spl-token-registry\";\n\nconst MINTS = [\n  \"None\",\n  \"SOL\",\n  \"USDC\",\n  \"USDT\",\n  \"BTC\",\n  \"ETH\",\n]\n\nconst getSize = (n: any, mint: any, mintCache: any) => {\n  try {\n    const dec = mintCache[mint].decimals;\n    const size = Math.floor(parseFloat(n) * Math.pow(10, dec));\n    return size;\n  } catch {\n    return 0;\n  }\n};\n\nconst getDelegate = async (formState: any, mintCache: any) => {\n  try {\n    const sizeA = getSize(formState.sizeA, formState.mintA, mintCache);\n    const sizeB = getSize(formState.sizeB, formState.mintB, mintCache);\n    return (\n      await PublicKey.findProgramAddress(\n        [\n          Buffer.from(\"stateless_offer\"),\n          new PublicKey(formState.maker).toBuffer(),\n          new PublicKey(formState.mintA).toBuffer(),\n          new PublicKey(formState.mintB).toBuffer(),\n          new Uint8Array(new BN(sizeA).toArray(\"le\", 8)),\n          new Uint8Array(new BN(sizeB).toArray(\"le\", 8)),\n        ],\n        new PublicKey(\"SAtnofysr9Uxk7m9YphxwfL5E3wyZJWUzjwA29Gw3tQ\")\n      )\n    )[0];\n  } catch {\n    return null;\n  }\n};\n\nconst getDefaultFormState = () => {\n  let url = new URL(window.location.href);\n  let params = new URLSearchParams(url.search.slice(1));\n  let defaultState = {\n    mintA: \"\",\n    mintB: \"\",\n    sizeA: \"0\",\n    sizeB: \"0\",\n    maker: \"\",\n  };\n  for (const key of params.keys()) {\n    defaultState[key] = params.get(key);\n  }\n  return defaultState;\n};\n\nconst displayActions = (\n  connection,\n  wallet: any,\n  formState: any,\n  mintCache: any,\n  isSeller,\n  hasDelegate,\n  hasValidDelegate,\n  validAmount\n) => {\n  const mintEntered =\n    formState.mintA in mintCache && formState.mintB in mintCache;\n  const sizeA = getSize(formState.sizeA, formState.mintA, mintCache);\n  const sizeB = getSize(formState.sizeB, formState.mintB, mintCache);\n  if (!mintEntered || sizeA <= 0 || sizeB <= 0) {\n    return <div></div>;\n  }\n  if (isSeller) {\n    return (\n      <div>\n        {validAmount && (\n          <Button\n            variant=\"contained\"\n            onClick={() => {\n              if (formState) {\n                try {\n                  changeOffer(\n                    connection,\n                    new PublicKey(formState.mintA),\n                    new PublicKey(formState.mintB),\n                    new BN(\n                      sizeA\n                    ),\n                    new BN(\n                      sizeB\n                    ),\n                    wallet\n                  );\n                } catch (e) {\n                  return;\n                }\n              }\n            }}\n            sx={{ marginRight: \"4px\" }}\n          >\n            Open Offer\n          </Button>\n        )}\n        {hasDelegate && (\n          <Button\n            variant=\"contained\"\n            color=\"error\"\n            sx={{ marginRight: \"4px\" }}\n            onClick={() => {\n              if (formState) {\n                try {\n                  changeOffer(\n                    connection,\n                    new PublicKey(formState.mintA),\n                    new PublicKey(formState.mintB),\n                    new BN(\n                      getSize(formState.sizeA, formState.mintA, mintCache)\n                    ),\n                    new BN(\n                      getSize(formState.sizeB, formState.mintB, mintCache)\n                    ),\n                    wallet,\n                    false\n                  );\n                } catch (e) {\n                  return;\n                }\n              }\n            }}\n          >\n            Close Offer\n          </Button>\n        )}\n      </div>\n    );\n  } else {\n    if (hasValidDelegate && validAmount) {\n      return (\n        <div>\n          <Button\n            variant=\"contained\"\n            color=\"success\"\n            onClick={() => {\n              if (formState) {\n                try {\n                  trade(\n                    connection,\n                    new PublicKey(formState.maker),\n                    new PublicKey(formState.mintA),\n                    new PublicKey(formState.mintB),\n                    new BN(\n                      getSize(formState.sizeA, formState.mintA, mintCache)\n                    ),\n                    new BN(\n                      getSize(formState.sizeB, formState.mintB, mintCache)\n                    ),\n                    wallet\n                  );\n                } catch (e) {\n                  return;\n                }\n              }\n            }}\n          >\n            Trade\n          </Button>\n        </div>\n      );\n    } else {\n      return <div></div>;\n    }\n  }\n};\n\nexport function TransferBox() {\n  const connection = useConnection();\n  const wallet = useWallet();\n  const { env } = useConnectionConfig();\n  const [formState, setFormState] = useState(getDefaultFormState());\n  const [accountState, setAccountState] = useState({});\n  const [mintCache, setMintCache] = useState({});\n  const [isSeller, setIsSeller] = useState(false);\n  const [validAmount, setValidAmount] = useState(false);\n  const [hasDelegate, setHasDelegate] = useState(false);\n  const [hasValidDelegate, setHasValidDelegate] = useState(false);\n  const [open, setOpen] = useState(false);\n  const [anchor, setAnchor] = useState(null);\n\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n\n  useEffect(() => {\n    new TokenListProvider().resolve().then(tokens => {\n      let tokenList;\n      if (env === \"devnet\") {\n        tokenList = tokens.filterByChainId(ENV.Devnet).getList();\n      }\n      else if (env === \"mainnet-beta\") {\n        tokenList = tokens.filterByChainId(ENV.MainnetBeta).getList();\n      }\n      else if (env === \"testnet\") {\n        tokenList = tokens.filterByChainId(ENV.Testnet).getList();\n      }\n      setTokenMap(tokenList.reduce((map, item) => {\n        map.set(item.symbol, item);\n        return map;\n      }, new Map()));\n    });\n  }, [setTokenMap, env]);\n\n  // useEffect(() => {\n  //   console.log(tokenMap)\n  // }, [tokenMap, env]);\n\n  useEffect(() => {\n    if (!wallet) {\n      return;\n    }\n    setIsSeller(wallet.publicKey?.toBase58() === formState.maker);\n  }, [formState, wallet, setIsSeller]);\n\n  useEffect(() => {\n    const validate = async () => {\n      const tokenAccount: any = accountState;\n      if (!tokenAccount.mint) {\n        return;\n      }\n      const mint = tokenAccount.mint.toBase58();\n      if (mint in mintCache) {\n        const dec = mintCache[mint].decimals;\n        const totalAmount = tokenAccount.amount * Math.pow(10, -dec);\n        try {\n          const size = parseFloat(formState.sizeA);\n          setValidAmount(totalAmount >= size && size > 0);\n        } catch {\n          console.log(\"Not a valid float\");\n        }\n      }\n\n      const delegate = await getDelegate(formState, mintCache);\n      setHasDelegate(tokenAccount.delegateOption != 0);\n      if (\n        tokenAccount.delegate &&\n        delegate &&\n        tokenAccount.delegateOption != 0 &&\n        delegate.toBase58() === tokenAccount.delegate.toBase58()\n      ) {\n        setHasValidDelegate(true);\n      } else {\n        setHasValidDelegate(false);\n      }\n    };\n    validate();\n  }, [\n    accountState,\n    mintCache,\n    formState,\n  ]);\n\n  useEffect(() => {\n    let subId;\n    const fetchAccountState = async () => {\n      let sellerWallet;\n      let sellerMint;\n      try {\n        sellerWallet = new PublicKey(formState.maker);\n        sellerMint = new PublicKey(formState.mintA);\n      } catch {\n        return;\n      }\n      const sellerTokenAccount = (\n        await PublicKey.findProgramAddress(\n          [\n            sellerWallet.toBuffer(),\n            TOKEN_PROGRAM_ID.toBuffer(),\n            sellerMint.toBuffer(),\n          ],\n          SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n        )\n      )[0];\n      const result = await connection.getAccountInfo(sellerTokenAccount);\n      if (result) {\n        const tokenAccount = deserializeAccount(result.data);\n        console.log(formState);\n        console.log(tokenAccount);\n        setAccountState(tokenAccount);\n      }\n      subId = connection.onAccountChange(sellerTokenAccount, async (result) => {\n        if (result) {\n          console.log(\"Received account data\");\n          try {\n            const tokenAccount = deserializeAccount(result.data);\n            setAccountState(tokenAccount);\n          } catch (e) {\n            console.log(\"Failed to deserialize account\", e);\n          }\n        }\n      });\n    };\n    fetchAccountState();\n    return () => {\n      if (subId) connection.removeAccountChangeListener(subId);\n    };\n  }, [formState.maker, formState.mintA, connection, setAccountState]);\n\n  useEffect(() => {\n    const fetchMintState = async () => {\n      let mint;\n      for (const mintString of [formState.mintA, formState.mintB]) {\n        try {\n          mint = new PublicKey(mintString);\n        } catch (e) {\n          console.log(\"Invalid Pubkey\");\n          continue;\n        }\n        if (!(mint.toBase58() in mintCache)) {\n          let result = await connection.getAccountInfo(mint);\n          if (result) {\n            try {\n              const mintData = deserializeMint(result.data);\n              setMintCache({\n                ...mintCache,\n                [mintString]: mintData,\n              });\n            } catch {\n              console.log(\"Invalid Mint\");\n            }\n          }\n        }\n      }\n    };\n    fetchMintState();\n  }, [mintCache, formState.mintA, formState.mintB, connection]);\n\n  const setField = (name: any) => {\n    const setFieldWithName = (e) => {\n      setFormState({ ...formState, [name]: e.target.value });\n      let url = new URL(window.location.href);\n      let params = new URLSearchParams(url.search.slice(1));\n      params.set(name, escape(e.target.value));\n      let newUrl =\n        window.location.protocol +\n        \"//\" +\n        window.location.host +\n        window.location.pathname +\n        \"?\" +\n        params.toString();\n      window.history.pushState({ path: newUrl }, \"\", newUrl);\n    };\n    return setFieldWithName;\n  };\n\n  const getField = (name: any) => {\n    if (name in formState) {\n      return formState[name];\n    }\n  };\n\n  const handleEnter = (e) => {\n    if (e.key === \"Enter\") {\n      setOpen(false);\n      console.log(e.key)\n    }\n  }\n\n  const getTokenKeys = (tokenMap) => {\n    // for (const mint of MINTS) {\n    //   console.log(tokenMap.get(mint))\n    // }\n    let keys: any[] = []\n    keys.push(<Input onKeyPress={handleEnter} sx={{ marginLeft: \"20px\" }} value={getField(\"mintB\")} onChange={setField(\"mintB\")}></Input>)\n    for (const mint of MINTS) {\n      if (!tokenMap.get(mint)) {\n        if (mint === \"None\") {\n          keys.push(<MenuItem value=\"\">{mint}</MenuItem>);\n        }\n        continue\n      }\n      keys.push(<MenuItem value={tokenMap.get(mint).address}>{mint}</MenuItem>\n      )\n    }\n    return keys;\n  }\n\n  return (\n    <div>\n      <div>\n        <Box\n          component=\"form\"\n          sx={{\n            \"& .MuiTextField-root\": { m: 1, width: \"60ch\" },\n            justifyContent: \"center\",\n            marginBottom: \"5px\",\n          }}\n          noValidate\n          autoComplete=\"on\"\n        >\n          <LoadingButton\n            onClick={\n              () => {\n                if (env && formState && formState.mintA) {\n                  let url = `https://explorer.solana.com/address/${formState.mintA}?cluster=${env}`;\n                  const w = window.open(url, '_blank');\n                  if (w) {\n                    w.focus();\n                  }\n                }\n              }\n            } sx={{ width: \"30ch\" }} variant=\"outlined\"\n          >\n            Seller Mint (Explorer)\n          </LoadingButton>\n          <LoadingButton\n            onClick={\n              () => {\n                if (env && formState && formState.mintB) {\n                  let url = `https://explorer.solana.com/address/${formState.mintB}?cluster=${env}`;\n                  const w = window.open(url, '_blank');\n                  if (w) {\n                    w.focus();\n                  }\n                }\n              }\n            } sx={{ width: \"30ch\" }} variant=\"outlined\"\n          >\n            Buyer Mint (Explorer)\n          </LoadingButton>\n        </Box>\n      </div>\n      <div>\n        <Box\n          component=\"form\"\n          sx={{\n            \"& .MuiTextField-root\": { m: 1, width: \"60ch\" },\n          }}\n          noValidate\n          autoComplete=\"on\"\n        >\n          <div>\n            <TextField\n              required\n              id=\"outlined-required\"\n              label=\"Seller Public Key\"\n              value={getField(\"maker\")}\n              onChange={setField(\"maker\")}\n            />\n            <TextField\n              required\n              id=\"outlined-required\"\n              label=\"Seller Mint\"\n              value={getField(\"mintA\")}\n              onChange={setField(\"mintA\")}\n            />\n            {/* <TextField\n          required\n          id=\"outlined-required\"\n          label=\"Buyer Mint\"\n          value={getField(\"mintB\")}\n          onChange={setField(\"mintB\")}\n        /> */}\n            <FormControl>\n              <InputLabel id=\"buyer-mint\">Buyer Mint</InputLabel>\n              <Select\n                sx={{ display: \"inline-block\", textAlign: \"left\", width: \"60ch\" }}\n                labelId=\"buyer-mint\"\n                value={getField(\"mintB\")}\n                input={<OutlinedInput label=\"Buyer Mint\" />}\n                onChange={setField(\"mintB\")}\n                open={open}\n                onClose={(e) => { setOpen(false) }}\n                onOpen={(e) => { console.log(\"opening\"); setOpen(true) }}\n                renderValue={(selected) => { return selected; }}\n              >\n                {getTokenKeys(tokenMap)}\n              </Select>\n            </FormControl>\n            <TextField\n              id=\"outlined-number\"\n              label=\"Seller Size\"\n              type=\"number\"\n              value={getField(\"sizeA\")}\n              onChange={setField(\"sizeA\")}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n            <TextField\n              id=\"outlined-number\"\n              label=\"Buyer Size\"\n              type=\"number\"\n              value={getField(\"sizeB\")}\n              onChange={setField(\"sizeB\")}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n          </div>\n          <div style={{ marginTop: \"10px\" }}>\n            {displayActions(\n              connection,\n              wallet,\n              formState,\n              mintCache,\n              isSeller,\n              hasDelegate,\n              hasValidDelegate,\n              validAmount\n            )}\n          </div>\n        </Box>\n      </div>\n    </div>\n  );\n}\n","export default __webpack_public_path__ + \"static/media/wallet.c746d144.less\";","import { WalletAdapter, WalletError } from \"@solana/wallet-adapter-base\";\nimport {\n  useWallet,\n  WalletProvider as BaseWalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  getLedgerWallet,\n  getMathWallet,\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolongWallet,\n  getTorusWallet,\n  WalletName,\n} from \"@solana/wallet-adapter-wallets\";\nimport { Button } from \"antd\";\nimport React, {\n  createContext,\n  FC,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { notify } from \"../../utils\";\nimport { DefaultModal } from \"../../components\";\n\nimport \"./wallet.less\";\n\nexport interface WalletModalContextState {\n  visible: boolean;\n  setVisible: (open: boolean) => void;\n}\n\nexport const WalletModalContext = createContext<WalletModalContextState>(\n  {} as WalletModalContextState\n);\n\nexport function useWalletModal(): WalletModalContextState {\n  return useContext(WalletModalContext);\n}\n\nexport const WalletModal: FC = () => {\n  const { wallets, connected, wallet: selected, select } = useWallet();\n  const { visible, setVisible } = useWalletModal();\n  const [showWallets, setShowWallets] = useState(false);\n  const close = useCallback(() => {\n    setVisible(false);\n    setShowWallets(false);\n  }, [setVisible, setShowWallets]);\n\n  return (\n    <DefaultModal visible={visible} onCancel={close}>\n      <div\n        style={{\n          background:\n            \"linear-gradient(180deg, #D329FC 0%, #8F6DDE 49.48%, #19E6AD 100%)\",\n          borderRadius: 36,\n          width: 50,\n          height: 50,\n          textAlign: \"center\",\n          verticalAlign: \"middle\",\n          fontWeight: 700,\n          fontSize: \"1.3rem\",\n          lineHeight: 2.4,\n          marginBottom: 10,\n        }}\n      ></div>\n      <h2\n        style={{\n          color: \"white\",\n          fontWeight: \"bold\",\n          fontSize: 20,\n        }}\n      >\n        {selected ? \"Change provider\" : \"\"}\n      </h2>\n      <p style={{ color: \"white\", fontSize: 14 }}>\n        {selected\n          ? \"Choose from the following options:\"\n          : \"Please sign into your wallet\"}\n      </p>\n\n      <br />\n      {wallets.map((wallet) => {\n        return (\n          <Button\n            key={wallet.name}\n            size=\"large\"\n            type={wallet === selected ? \"primary\" : \"ghost\"}\n            onClick={() => {\n              select(wallet.name);\n              close();\n            }}\n            icon={\n              <img\n                alt={`${wallet.name}`}\n                width={20}\n                height={20}\n                src={wallet.icon}\n                style={{ marginRight: 30, float: \"left\" }}\n              />\n            }\n            style={{\n              display: \"block\",\n              width: \"100%\",\n              textAlign: \"left\",\n              marginBottom: 8,\n              color: \"white\",\n            }}\n          >\n            {wallet.name}\n          </Button>\n        );\n      })}\n    </DefaultModal>\n  );\n};\n\nexport const WalletModalProvider: FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const { publicKey } = useWallet();\n  const [connected, setConnected] = useState(!!publicKey);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (publicKey) {\n      const base58 = publicKey.toBase58();\n      const keyToDisplay =\n        base58.length > 20\n          ? `${base58.substring(0, 7)}.....${base58.substring(\n              base58.length - 7,\n              base58.length\n            )}`\n          : base58;\n\n      notify({\n        message: \"Wallet update\",\n        description: \"Connected to wallet \" + keyToDisplay,\n      });\n    }\n  }, [publicKey]);\n\n  useEffect(() => {\n    if (!publicKey && connected) {\n      notify({\n        message: \"Wallet update\",\n        description: \"Disconnected from wallet\",\n      });\n    }\n    setConnected(!!publicKey);\n  }, [publicKey, connected, setConnected]);\n\n  return (\n    <WalletModalContext.Provider\n      value={{\n        visible,\n        setVisible,\n      }}\n    >\n      {children}\n      <WalletModal />\n    </WalletModalContext.Provider>\n  );\n};\n\nexport const WalletProvider: FC<{ children: ReactNode }> = ({ children }) => {\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getTorusWallet({\n        options: {\n          // @FIXME: this should be changed for Default, and by each Default storefront\n          clientId:\n            \"BOM5Cl7PXgE9Ylq1Z1tqzhpydY0RVr8k90QQ85N7AKI5QGSrr9iDC-3rvmy0K_hF0JfpLMiXoDhta68JwcxS1LQ\",\n        },\n      }),\n      getLedgerWallet(),\n      getSolongWallet(),\n      getMathWallet(),\n      getSolletWallet(),\n    ],\n    []\n  );\n\n  const onError = useCallback((error: WalletError) => {\n    console.error(error);\n    notify({\n      message: \"Wallet error\",\n      description: error.message,\n    });\n  }, []);\n\n  return (\n    <BaseWalletProvider wallets={wallets} onError={onError} autoConnect>\n      <WalletModalProvider>{children}</WalletModalProvider>\n    </BaseWalletProvider>\n  );\n};\n\nexport type WalletSigner = Pick<\n  WalletAdapter,\n  \"publicKey\" | \"signTransaction\" | \"signAllTransactions\"\n>;\n","import React, { useState, useContext, useCallback } from 'react';\n\nimport { WalletModal } from './WalletContext/WalletContext';\n\nexport enum ModalEnum {\n  WALLET = 'wallet',\n}\n\ntype ModalContextProps = {\n  setModal: (modal: ModalEnum | undefined) => void;\n  removeModal: () => void;\n};\n\nexport const ModalContext = React.createContext<ModalContextProps>({\n  setModal: () => null,\n  removeModal: () => null,\n});\n\nexport const ModalProvider: React.FC = ({ children }) => {\n  const [modal, setModal] = useState<ModalEnum | undefined>(undefined);\n\n  const removeModal = useCallback(() => {\n    setModal(undefined);\n  }, [setModal]);\n\n  return (\n    <ModalContext.Provider\n      value={{\n        setModal,\n        removeModal,\n      }}\n    >\n      {children}\n      {modal === ModalEnum.WALLET && <WalletModal />}\n    </ModalContext.Provider>\n  );\n};\n\nexport const useModal = (): ModalContextProps => {\n  const context = useContext(ModalContext);\n  if (context === undefined) {\n    throw new Error('useModal must be used within a ModalProvider');\n  }\n  return context;\n};\n","import { createTheme, useTheme } from \"@mui/material\";\nimport React, { useContext, FC } from \"react\";\n\nexport const ColorModeContext = React.createContext({});\n\nexport const ColorModeContextProvider = ({children=null as any }) => {\n  const [mode, setMode] = React.useState<'light' | 'dark'>('dark'); \n  const theme = useTheme();\n  const toggleColorMode = () => {\n    setMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));\n  }\n  return (\n    <ColorModeContext.Provider\n      value={{\n        toggleColorMode,\n        mode,\n        theme,\n      }}\n    >\n      {children}\n    </ColorModeContext.Provider>\n  );\n};\n\nexport const useColorMode = (): any => {\n  const context = useContext(ColorModeContext);\n  return context;\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport { StringPublicKey } from './ids';\n\nexport const extendBorsh = () => {\n  (BinaryReader.prototype as any).readPubkey = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n  };\n\n  (BinaryWriter.prototype as any).writePubkey = function (value: PublicKey) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(value.toBuffer());\n  };\n\n  (BinaryReader.prototype as any).readPubkeyAsString = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array) as StringPublicKey;\n  };\n\n  (BinaryWriter.prototype as any).writePubkeyAsString = function (\n    value: StringPublicKey,\n  ) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(base58.decode(value));\n  };\n};\n\nextendBorsh();\n","import { PublicKey, AccountInfo, Account } from '@solana/web3.js';\n\nexport type StringPublicKey = string;\n\nexport class LazyAccountInfoProxy<T> {\n  executable: boolean = false;\n  owner: StringPublicKey = '';\n  lamports: number = 0;\n\n  get data() {\n    //\n    return undefined as unknown as T;\n  }\n}\n\nexport interface LazyAccountInfo {\n  executable: boolean;\n  owner: StringPublicKey;\n  lamports: number;\n  data: [string, string];\n}\n\nconst PubKeysInternedMap = new Map<string, PublicKey>();\n\nexport const toPublicKey = (key: string | PublicKey) => {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  let result = PubKeysInternedMap.get(key);\n  if (!result) {\n    result = new PublicKey(key);\n    PubKeysInternedMap.set(key, result);\n  }\n\n  return result;\n};\n\nexport interface PublicKeyStringAndAccount<T> {\n  pubkey: string;\n  account: AccountInfo<T>;\n}\n\nexport const WRAPPED_SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const BPF_UPGRADE_LOADER_ID = new PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');\n\nexport const MEMO_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');\n\nexport const SYSTEM = new PublicKey('11111111111111111111111111111111');\n","import { ButtonGroup, ButtonGroupProps } from \"@mui/material\";\nimport { Settings } from \"./Settings\";\n\nexport type ConnectButtonProps = ButtonGroupProps & {\n  isConnected: boolean;\n  onClickConnect: () => void;\n  onClickChange: () => void;\n};\n\nexport const ConnectButton: React.FC<ConnectButtonProps> = ({\n  isConnected,\n  onClickConnect,\n  onClickChange,\n  ...restProps\n}) => {\n  return (\n    <ButtonGroup   {...restProps}>\n      <Settings/>\n    </ButtonGroup>\n  );\n};\n\nexport default ConnectButton;\n","import React, { useCallback } from \"react\";\nimport { Box } from \"@mui/system\";\n\nimport ConnectButton from \"../ConnectButton\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { AppBar } from \"@mui/material\";\n\nexport const Header: React.FC = () => {\n  const { setModal } = useModal();\n  const { setVisible } = useWalletModal();\n  const wallet = useWallet();\n  const connected = wallet.connected;\n\n  const handleChange = useCallback(() => setVisible(true), [setVisible]);\n\n  const handleConnect = useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n  return (\n    <Box\n      sx={{\n        display: \"flex\",\n        bgcolor: \"action.disabledBackground\",\n      }}\n      minWidth=\"100%\"\n    >\n      <Box sx={{flexGrow: 1}}></Box>\n      <Box\n        sx={{\n          display: \"flex\",\n          height: \"62px\",\n          justifyContent: \"flex-end\",\n          alignItems: \"center\",\n        }}\n      >\n        <ConnectButton\n          isConnected={connected}\n          sx={{ marginRight: \"36px\" }}\n          onClickConnect={handleConnect}\n          onClickChange={handleChange}\n        />\n      </Box>\n    </Box>\n  );\n};\n\nexport default Header;\n","import React, { useEffect } from \"react\";\nimport \"./App.css\";\nimport Header from \"./components/Header/Header\";\nimport { TransferBox } from \"./components\";\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\";\nimport CssBaseline from \"@mui/material/CssBaseline\";\nimport { useColorMode } from \"./contexts\";\nimport { Box } from \"@mui/material\";\n\nfunction App() {\n  const colorModeCtx = useColorMode();\n\n  const mode =\n    colorModeCtx.mode === \"dark\" || !colorModeCtx.mode ? \"dark\" : \"light\";\n\n  useEffect(() => {}, [colorModeCtx.mode]);\n\n  const theme = React.useMemo(\n    () =>\n      createTheme({\n        palette: {\n          mode,\n        },\n      }),\n    [colorModeCtx.mode]\n  );\n\n  return (\n    <div className=\"App\" style={{ backgroundColor: \"transparent\" }}>\n      <ThemeProvider theme={theme}>\n        <CssBaseline />\n        <Header />\n        <Box\n          sx={{\n            width: 600,\n            py: \"10%\",\n            px: \"50%\",\n            display: \"flex\",\n            alignSelf: \"center\",\n            justifyContent: \"center\",\n            alignContent: \"center\",\n          }}\n        >\n          <TransferBox />\n        </Box>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  AccountsProvider,\n  WalletProvider,\n  ConnectionProvider,\n  ColorModeContextProvider,\n} from \"./contexts\";\n\nimport \"antd/dist/antd.css\";\nimport \"@fontsource/open-sans\";\nimport \"@fontsource/roboto\";\nimport \"@fontsource/sora\";\n\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <ConnectionProvider>\n      <WalletProvider>\n        <AccountsProvider>\n          <ColorModeContextProvider>\n            <App />\n          </ColorModeContextProvider>\n        </AccountsProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nreportWebVitals();\n","import BN from 'bn.js';\n\nexport const TEN = new BN(10);\nexport const HALF_WAD = TEN.pow(new BN(18));\nexport const WAD = TEN.pow(new BN(18));\nexport const RAY = TEN.pow(new BN(27));\nexport const ZERO = new BN(0);\n","import { useCallback, useState } from 'react';\nimport { MintInfo } from '@solana/spl-token';\n\nimport { TokenAccount } from './../models';\nimport { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { WAD, ZERO } from '../constants';\nimport { TokenInfo } from '@solana/spl-token-registry';\n\nexport type KnownTokenMap = Map<string, TokenInfo>;\n\nexport const formatPriceNumber = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 8,\n});\n\nexport function useLocalStorageState(key: string, defaultState?: string) {\n  const [state, setState] = useState(() => {\n    // NOTE: Not sure if this is ok\n    const storedState = localStorage.getItem(key);\n    if (storedState) {\n      return JSON.parse(storedState);\n    }\n    return defaultState;\n  });\n\n  const setLocalStorageState = useCallback(\n    newState => {\n      const changed = state !== newState;\n      if (!changed) {\n        return;\n      }\n      setState(newState);\n      if (newState === null) {\n        localStorage.removeItem(key);\n      } else {\n        try {\n          localStorage.setItem(key, JSON.stringify(newState));\n        } catch {\n          // ignore\n        }\n      }\n    },\n    [state, key],\n  );\n\n  return [state, setLocalStorageState];\n}\n\nexport const findProgramAddress = async (\n  seeds: (Buffer | Uint8Array)[],\n  programId: PublicKey,\n) => {\n  const key =\n    'pda-' +\n    seeds.reduce((agg, item) => agg + item.toString('hex'), '') +\n    programId.toString();\n  let cached = localStorage.getItem(key);\n  if (cached) {\n    const value = JSON.parse(cached);\n\n    return [value.key, parseInt(value.nonce)] as [string, number];\n  }\n\n  const result = await PublicKey.findProgramAddress(seeds, programId);\n\n  try {\n    localStorage.setItem(\n      key,\n      JSON.stringify({\n        key: result[0].toBase58(),\n        nonce: result[1],\n      }),\n    );\n  } catch {\n    // ignore\n  }\n\n  return [result[0].toBase58(), result[1]] as [string, number];\n};\n\n// shorten the checksummed version of the input address to have 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\n\nexport function getTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownSymbol = map.get(mintAddress)?.symbol;\n  if (knownSymbol) {\n    return knownSymbol;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\nexport function getVerboseTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownName = map.get(mintAddress)?.name;\n  if (knownName) {\n    return knownName;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\n\nexport function getTokenByName(tokenMap: KnownTokenMap, name: string) {\n  let token: TokenInfo | null = null;\n  for (const val of tokenMap.values()) {\n    if (val.symbol === name) {\n      token = val;\n      break;\n    }\n  }\n  return token;\n}\n\nexport function getTokenIcon(\n  map: KnownTokenMap,\n  mintAddress?: string | PublicKey,\n): string | undefined {\n  const address =\n    typeof mintAddress === 'string' ? mintAddress : mintAddress?.toBase58();\n  if (!address) {\n    return;\n  }\n\n  return map.get(address)?.logoURI;\n}\n\nexport function isKnownMint(map: KnownTokenMap, mintAddress: string) {\n  return !!map.get(mintAddress);\n}\n\nexport const STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);\n\nexport function chunks<T>(array: T[], size: number): T[][] {\n  return Array.apply<number, T[], T[][]>(\n    0,\n    new Array(Math.ceil(array.length / size)),\n  ).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n\nexport function toLamports(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  return Math.floor(amount * precision);\n}\n\nexport function wadToLamports(amount?: BN): BN {\n  return amount?.div(WAD) || ZERO;\n}\n\nexport function fromLamports(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount = Math.floor(\n    typeof account === 'number'\n      ? account\n      : BN.isBN(account)\n      ? account.toNumber()\n      : account.info.amount.toNumber(),\n  );\n\n  const precision = Math.pow(10, mint?.decimals || 9);\n  return (amount / precision) * rate;\n}\n\nexport const tryParseKey = (key: string): PublicKey | null => {\n  try {\n    return new PublicKey(key);\n  } catch (error) {\n    return null;\n  }\n};\n\nvar SI_SYMBOL = ['', 'k', 'M', 'G', 'T', 'P', 'E'];\n\nconst abbreviateNumber = (number: number, precision: number) => {\n  let tier = (Math.log10(number) / 3) | 0;\n  let scaled = number;\n  let suffix = SI_SYMBOL[tier];\n  if (tier !== 0) {\n    let scale = Math.pow(10, tier * 3);\n    scaled = number / scale;\n  }\n\n  return scaled.toFixed(precision) + suffix;\n};\n\nexport const formatAmount = (\n  val: number,\n  precision: number = 2,\n  abbr: boolean = true,\n) => (abbr ? abbreviateNumber(val, precision) : val.toFixed(precision));\n\nexport function formatTokenAmount(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n  prefix = '',\n  suffix = '',\n  precision = 2,\n  abbr = false,\n): string {\n  if (!account) {\n    return '';\n  }\n\n  return `${[prefix]}${formatAmount(\n    fromLamports(account, mint, rate),\n    precision,\n    abbr,\n  )}${suffix}`;\n}\n\nexport const formatUSD = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n});\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n};\n\nexport const formatPct = new Intl.NumberFormat('en-US', {\n  style: 'percent',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport function convert(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  let result = (amount / precision) * rate;\n\n  return result;\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import { sleep, useLocalStorageState } from \"../utils/utils\";\nimport {\n  Keypair,\n  clusterApiUrl,\n  Commitment,\n  Connection,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n  Blockhash,\n  FeeCalculator,\n} from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport { notify } from \"../utils/notifications\";\nimport { ExplorerLink } from \"../components/ExplorerLink\";\nimport {\n  TokenInfo,\n  TokenListProvider,\n  ENV as ChainId,\n} from \"@solana/spl-token-registry\";\nimport { WalletSigner } from \"./WalletContext/WalletContext\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport type ENV = \"mainnet-beta\" | \"testnet\" | \"devnet\" | \"localnet\";\n\nexport const ENDPOINTS = [\n  {\n    name: \"devnet\" as ENV,\n    endpoint: \"https://api.devnet.solana.com\",\n    ChainId: ChainId.Devnet,\n  },\n  {\n    name: \"mainnet-beta\" as ENV,\n    endpoint: \"https://api.mainnet-beta.solana.com\",\n    ChainId: ChainId.MainnetBeta,\n  },\n];\n\nconst DEFAULT = ENDPOINTS[0].endpoint;\n\ninterface ConnectionConfig {\n  connection: Connection;\n  endpoint: string;\n  env: ENV;\n  setEndpoint: (val: string) => void;\n  tokens: TokenInfo[];\n  tokenMap: Map<string, TokenInfo>;\n}\n\nconst ConnectionContext = React.createContext<ConnectionConfig>({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map<string, TokenInfo>(),\n});\n\nexport function ConnectionProvider({ children = undefined as any }) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\n    \"connectionEndpoint\",\n    ENDPOINTS[0].endpoint\n  );\n\n  const connection = useMemo(\n    () => new Connection(endpoint, \"recent\"),\n    [endpoint]\n  );\n\n  const env =\n    ENDPOINTS.find((end) => end.endpoint === endpoint)?.name ||\n    ENDPOINTS[0].name;\n\n  const [tokens, setTokens] = useState<TokenInfo[]>([]);\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n  useEffect(() => {\n    // fetch token files\n    new TokenListProvider().resolve().then((container) => {\n      const list = container\n        .excludeByTag(\"nft\")\n        .filterByChainId(\n          ENDPOINTS.find((end) => end.endpoint === endpoint)?.ChainId ||\n            ChainId.MainnetBeta\n        )\n        .getList();\n\n      const knownMints = [...list].reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map<string, TokenInfo>());\n\n      setTokenMap(knownMints);\n      setTokens(list);\n    });\n  }, [env]);\n\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n  useEffect(() => {\n    const id = connection.onAccountChange(\n      Keypair.generate().publicKey,\n      () => {}\n    );\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n\n  return (\n    <ConnectionContext.Provider\n      value={{\n        endpoint,\n        setEndpoint,\n        connection,\n        tokens,\n        tokenMap,\n        env,\n      }}\n    >\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection() {\n  return useContext(ConnectionContext).connection as Connection;\n}\n\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap,\n  };\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach((log) => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[][],\n  signers: Keypair[][]\n) {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength: any = null;\n  let toRemoveSigners: Record<number, boolean> = {};\n\n \n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          \"single\"\n        );\n        stopPoint = 1;\n      } else {\n        stopPoint = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          SequenceType.StopOnFailure,\n          \"single\"\n        );\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      \"Died on \",\n      stopPoint,\n      \"retrying from instruction\",\n      instructions[stopPoint],\n      \"instructions length is\",\n      instructions.length\n    );\n    lastInstructionsLength = instructions.length;\n  }\n}\n\nexport const sendTransactions = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructionSet: TransactionInstruction[][],\n  signersSet: Keypair[][],\n  sequenceType: SequenceType = SequenceType.Parallel,\n  commitment: Commitment = \"singleGossip\",\n  successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n  failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n  block?: BlockhashAndFeeCalculator\n): Promise<number> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns: Transaction[] = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach((instruction) => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n  let breakEarlyObject = { breakEarly: false, i: 0 };\n  console.log(\n    \"Signed txns length\",\n    signedTxns.length,\n    \"vs handed in length\",\n    instructionSet.length\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    signedTxnPromise\n      .then(({ txid, slot }) => {\n        successCallback(txid, i);\n      })\n      .catch((reason) => {\n        // @ts-ignore\n        failCallback(signedTxns[i], i);\n        if (sequenceType === SequenceType.StopOnFailure) {\n          breakEarlyObject.breakEarly = true;\n          breakEarlyObject.i = i;\n        }\n      });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log(\"Caught failure\", e);\n        if (breakEarlyObject.breakEarly) {\n          console.log(\"Died on \", breakEarlyObject.i);\n          return breakEarlyObject.i; // Return the txn we failed on by index\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    await Promise.all(pendingTxns);\n  }\n\n  return signedTxns.length;\n};\n\nexport const sendTransaction = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  awaitConfirmation = true,\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment\n    );\n\n    if (!confirmation)\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n      notify({\n        message: \"Transaction failed...\",\n        description: (\n          <>\n            {errors.map((err) => (\n              <div>{err}</div>\n            ))}\n            <ExplorerLink address={txid} type=\"transaction\" />\n          </>\n        ),\n        type: \"error\",\n      });\n\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    try {\n      transaction = await wallet.signTransaction(transaction);\n    } catch {\n      return false;\n    }\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n  console.log(\"About to send\");\n  try {\n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n\n    return { txid, slot };\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    }\n  );\n\n  console.log(\"Started awaiting confirmation for\", txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      \"recent\",\n      true\n    );\n\n    if (!confirmation)\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error(\"Transaction failed: Custom instruction error\");\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    console.error(\"Timeout Error caught\", err);\n    if ((err as any).timeout) {\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, \"single\")\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith(\"Program log: \")) {\n            throw new Error(\n              \"Transaction failed: \" + line.slice(\"Program log: \".length)\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log(\"Latency\", txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString(\"base64\");\n  const config: any = { encoding: \"base64\", commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"simulateTransaction\", args);\n  if (res.error) {\n    throw new Error(\"failed to simulate transaction: \" + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = \"recent\",\n  queryStatus = false\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log(\"Rejecting for timeout...\");\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log(\"Rejected via websocket\", result.err);\n            reject(status);\n          } else {\n            console.log(\"Resolved via websocket\", result);\n            resolve(status);\n          }\n        },\n        commitment\n      );\n    } catch (e) {\n      done = true;\n      console.error(\"WS error in setup\", txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          console.log(`https://explorer.solana.com/tx/${txid}?cluster=devnet`); // TODO\n          if (!done) {\n            if (!status) {\n              console.log(\"REST null result for\", txid, status);\n            } else if (status.err) {\n              console.log(\"REST error for\", txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log(\"REST no confirmations for\", txid, status);\n            } else {\n              console.log(\"REST confirmation for\", txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log(\"REST connection error: txid\", txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log(\"Returning status\", status);\n  return status;\n}\n"],"sourceRoot":""}