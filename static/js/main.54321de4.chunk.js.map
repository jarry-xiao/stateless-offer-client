{"version":3,"sources":["contexts/AccountContext.tsx","utils/programIds.ts","utils/notifications.tsx","components/ExplorerLink/index.tsx","utils/eventEmitter.ts","components/Settings/index.tsx","components/DefaultModal/index.tsx","actions/accept_offer.ts","utils/account.ts","components/TransferBox/index.tsx","contexts/WalletContext/wallet.less","contexts/WalletContext/WalletContext.tsx","contexts/ModalContext.tsx","contexts/ColorModeContext.tsx","utils/borsh.ts","utils/ids.ts","components/ConnectButton.tsx","components/Header/Header.tsx","App.tsx","reportWebVitals.ts","index.tsx","constants/math.ts","utils/utils.ts","contexts/ConnectionContext.tsx"],"names":["AccountsContext","React","createContext","pendingCalls","Map","genericCache","pendingMintCalls","mintCache","getMintInfo","connection","pubKey","a","getAccountInfo","info","Error","data","Buffer","from","deserializeMint","TokenAccountParser","length","buffer","deserializeAccount","pubkey","account","keyToAccountParser","cache","emitter","EventEmitter","query","parser","id","PublicKey","address","toBase58","get","then","add","set","obj","isActive","deserialize","registerParser","delete","undefined","Function","isNew","has","raiseCacheUpdated","key","raiseCacheDeleted","byParser","result","keys","push","queryMint","mint","getMint","addMint","UseNativeAccount","useConnection","publicKey","useWallet","useState","nativeAccount","setNativeAccount","updateCache","useCallback","wrapped","WRAPPED_SOL_MINT","owner","amount","u64","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","wrapNativeAccount","useEffect","subId","updateAccount","onAccountChange","removeAccountChangeListener","PRECACHED_OWNERS","Set","precacheUserTokenAccounts","getTokenAccountsByOwner","programId","programIds","token","value","forEach","AccountsProvider","children","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","walletKey","selectUserAccounts","map","filter","accounts","subs","onCache","args","tokenSubID","onProgramAccountChange","accountId","accountInfo","AccountLayout","span","removeProgramAccountChangeListener","Provider","decode","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","MintLayout","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority","TOKEN_PROGRAM_ID","associatedToken","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","bpf_upgrade_loader","BPF_UPGRADE_LOADER_ID","system","SYSTEM","memo","MEMO_ID","notify","message","description","txid","type","placement","notification","style","color","opacity","backgroundColor","ExplorerLink","props","code","href","target","title","Text","shortenAddress","CacheUpdateEvent","this","CacheDeleteEvent","MarketUpdateEvent","ids","Emitter","callback","on","removeListener","emit","Settings","additionalSettings","connected","disconnect","useConnectionConfig","env","endpoint","setEndpoint","setVisible","useWalletModal","open","setModal","useModal","theme","useTheme","colorModeCtx","useColorMode","handleConnect","ModalEnum","WALLET","sx","display","minWidth","marginBottom","ENDPOINTS","name","variant","onClick","marginLeft","navigator","clipboard","writeText","catch","ml","toggleColorMode","palette","mode","DefaultModal","bodyStyle","closeIcon","rest","background","borderRadius","flexDirection","alignItems","footer","width","PROGRAM_ID","AcceptOfferArgs","instruction","makerSize","takerSize","bumpSeed","schema","kind","fields","acceptOfferInstruction","makerWallet","takerWallet","makerSrc","makerDst","takerSrc","takerDst","makerSrcMint","takerSrcMint","transferAuthority","settings","serialize","isSigner","isWritable","NATIVE_MINT","SystemProgram","ix","TransactionInstruction","changeOffer","mintA","mintB","sizeA","sizeB","wallet","approve","signers","ataIx","findProgramAddress","toBuffer","tokenAccountMintA","tokenAccountMintB","createAssociatedTokenAccountInstruction","Uint8Array","toArray","authIx","Token","createApproveInstruction","toNumber","createRevokeInstruction","Conn","sendTransactionWithRetry","trade","maker","makerAccountMintA","makerAccountMintB","takerAccountMintA","takerAccountMintB","hasATAMintB","console","log","bump","tradeIx","instructions","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","SYSVAR_RENT_PUBKEY","getSize","n","dec","decimals","Math","floor","parseFloat","pow","getDelegate","formState","BN","TransferBox","url","URL","window","location","params","URLSearchParams","search","slice","defaultState","getDefaultFormState","setFormState","accountState","setAccountState","setMintCache","isSeller","setIsSeller","validAmount","setValidAmount","hasDelegate","setHasDelegate","fetchAccountState","sellerWallet","sellerMint","sellerTokenAccount","tokenAccount","totalAmount","size","fetchMintState","mintString","mintData","setField","e","escape","newUrl","protocol","host","pathname","toString","history","pushState","path","getField","component","m","noValidate","autoComplete","required","label","onChange","InputLabelProps","shrink","marginTop","marginRight","WalletModalContext","useContext","WalletModal","wallets","selected","select","visible","setShowWallets","close","onCancel","height","textAlign","verticalAlign","fontWeight","fontSize","lineHeight","icon","alt","src","float","WalletModalProvider","setConnected","base58","keyToDisplay","substring","WalletProvider","useMemo","getPhantomWallet","getSolflareWallet","getTorusWallet","options","clientId","getLedgerWallet","getSolongWallet","getMathWallet","getSolletWallet","onError","error","autoConnect","ModalContext","removeModal","context","ColorModeContext","ColorModeContextProvider","setMode","prevMode","BinaryReader","prototype","readPubkey","array","readFixedArray","BinaryWriter","writePubkey","writeFixedArray","readPubkeyAsString","encode","writePubkeyAsString","ConnectButton","isConnected","onClickConnect","onClickChange","restProps","ButtonGroup","Header","handleChange","Box","bgcolor","flexGrow","justifyContent","App","createTheme","className","ThemeProvider","CssBaseline","px","alignSelf","alignContent","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","TEN","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","useLocalStorageState","storedState","localStorage","getItem","JSON","parse","setState","setLocalStorageState","newState","removeItem","setItem","stringify","chars","chunks","Array","apply","ceil","_","index","currency","sleep","ms","Promise","resolve","setTimeout","ChainId","Devnet","MainnetBeta","DEFAULT","ConnectionContext","Connection","tokens","tokenMap","ConnectionProvider","find","end","setTokens","setTokenMap","TokenListProvider","container","list","excludeByTag","filterByChainId","getList","knownMints","reduce","item","Keypair","generate","onSlotChange","removeSlotChangeListener","SequenceType","getErrorForTransaction","confirmTransaction","getParsedConfirmedTransaction","tx","errors","meta","logMessages","regex","exec","lastIndex","sendTransactionsWithManualRetry","stopPoint","tries","lastInstructionsLength","toRemoveSigners","instr","i","filteredSigners","sendTransactions","StopOnFailure","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","transaction","Transaction","recentBlockhash","blockhash","setSigners","s","partialSign","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","signedTxnPromise","sendSignedTransaction","signedTransaction","slot","reason","all","sendTransaction","awaitConfirmation","includesFeePayer","signTransaction","rawTransaction","skipPreflight","sendRawTransaction","awaitTransactionSignatureConfirmation","DEFAULT_TIMEOUT","confirmation","err","beforeSend","getUnixTs","Date","getTime","timeout","startTime","done","simulateResult","simulateTransaction","logs","line","startsWith","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","encoding","_rpcRequest","res","queryStatus","status","confirmations","reject","onSignature","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener"],"mappings":"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","file":"static/js/main.54321de4.chunk.js","sourcesContent":["import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react';\nimport { useConnection } from './ConnectionContext';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\nimport { AccountLayout, MintInfo, MintLayout, u64 } from '@solana/spl-token';\nimport { TokenAccount } from '../models';\nimport { chunks } from '../utils/utils';\nimport { EventEmitter } from '../utils/eventEmitter';\nimport { StringPublicKey, WRAPPED_SOL_MINT } from '../utils/ids';\nimport { programIds } from '../utils/programIds';\n\nconst AccountsContext = React.createContext<any>(null);\n\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\nconst genericCache = new Map<string, ParsedAccountBase>();\nconst pendingMintCalls = new Map<string, Promise<MintInfo>>();\nconst mintCache = new Map<string, MintInfo>();\n\nexport interface ParsedAccountBase {\n  pubkey: StringPublicKey;\n  account: AccountInfo<Buffer>;\n  info: any; // TODO: change to unknown\n}\n\nexport type AccountParser = (\n  pubkey: StringPublicKey,\n  data: AccountInfo<Buffer>,\n) => ParsedAccountBase | undefined;\n\nexport interface ParsedAccount<T> extends ParsedAccountBase {\n  info: T;\n}\n\nconst getMintInfo = async (connection: Connection, pubKey: PublicKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n  if (info === null) {\n    throw new Error('Failed to find mint account');\n  }\n\n  const data = Buffer.from(info.data);\n\n  return deserializeMint(data);\n};\n\nexport const MintParser = (pubKey: string, info: AccountInfo<Buffer>) => {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeMint(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const TokenAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  // Sometimes a wrapped sol account gets closed, goes to 0 length,\n  // triggers an update over wss which triggers this guy to get called\n  // since your UI already logged that pubkey as a token account. Check for length.\n  if (info.data.length > 0) {\n    const buffer = Buffer.from(info.data);\n    const data = deserializeAccount(buffer);\n\n    const details = {\n      pubkey: pubKey,\n      account: {\n        ...info,\n      },\n      info: data,\n    } as TokenAccount;\n\n    return details;\n  }\n};\n\nexport const GenericAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  const buffer = Buffer.from(info.data);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: buffer,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const keyToAccountParser = new Map<string, AccountParser>();\n\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (\n    connection: Connection,\n    pubKey: string | PublicKey,\n    parser?: AccountParser,\n  ) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = genericCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    // TODO: refactor to use multiple accounts query with flush like behavior\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error('Account not found');\n      }\n\n      return cache.add(id, data, parser);\n    }) as Promise<TokenAccount>;\n    pendingCalls.set(address, query as any);\n\n    return query;\n  },\n  add: (\n    id: PublicKey | string,\n    obj: AccountInfo<Buffer>,\n    parser?: AccountParser,\n    isActive?: boolean | undefined | ((parsed: any) => boolean),\n  ) => {\n    const address = typeof id === 'string' ? id : id?.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n    if (!deserialize) {\n      throw new Error(\n        'Deserializer needs to be registered or passed as a parameter',\n      );\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(address, obj);\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;\n    else if (isActive instanceof Function) isActive = isActive(account);\n\n    const isNew = !genericCache.has(address);\n\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n    return false;\n  },\n\n  byParser: (parser: AccountParser) => {\n    const result: string[] = [];\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey: PublicKey | string, parser: AccountParser) => {\n    if (pubkey) {\n      const address = typeof pubkey === 'string' ? pubkey : pubkey?.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: async (connection: Connection, pubKey: string | PublicKey) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let mint = mintCache.get(address);\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingMintCalls.delete(address);\n\n      mintCache.set(address, data);\n      return data;\n    }) as Promise<MintInfo>;\n    pendingMintCalls.set(address, query as any);\n\n    return query;\n  },\n  getMint: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\n    const mint = deserializeMint(obj.data);\n    const id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  },\n};\n\nexport const useAccountsContext = () => {\n  const context = useContext(AccountsContext);\n\n  return context;\n};\n\nfunction wrapNativeAccount(\n  pubkey: string,\n  account?: AccountInfo<Buffer>,\n): TokenAccount | undefined {\n  if (!account) {\n    return undefined;\n  }\n\n  const key = new PublicKey(pubkey);\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: key,\n      mint: WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null,\n    },\n  };\n}\n\nexport const getCachedAccount = (\n  predicate: (account: TokenAccount) => boolean,\n) => {\n  for (const account of genericCache.values()) {\n    if (predicate(account)) {\n      return account as TokenAccount;\n    }\n  }\n};\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\n\n  const updateCache = useCallback(\n    account => {\n      if (publicKey) {\n        const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n        if (wrapped !== undefined) {\n          const id = publicKey.toBase58();\n          cache.registerParser(id, TokenAccountParser);\n          genericCache.set(id, wrapped as TokenAccount);\n          cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser, true);\n        }\n      }\n    },\n    [publicKey],\n  );\n\n  useEffect(() => {\n    let subId = 0;\n    const updateAccount = (account: AccountInfo<Buffer> | null) => {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    (async () => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      try {\n        const account = await connection.getAccountInfo(publicKey);\n        updateAccount(account);\n      } catch {\n        return;\n      }\n\n      subId = connection.onAccountChange(publicKey, updateAccount);\n    })();\n\n    return () => {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n\n  return { nativeAccount };\n};\n\nconst PRECACHED_OWNERS = new Set<string>();\nconst precacheUserTokenAccounts = async (\n  connection: Connection,\n  owner?: PublicKey,\n) => {\n  if (!owner) {\n    return;\n  }\n\n  // used for filtering account updates over websocket\n  PRECACHED_OWNERS.add(owner.toBase58());\n\n  // user accounts are updated via ws subscription\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token,\n  });\n\n  accounts.value.forEach(info => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({ children = null as any }) {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\n  const { nativeAccount } = UseNativeAccount();\n  const walletKey = publicKey?.toBase58();\n\n  const selectUserAccounts = useCallback(() => {\n    return cache\n      .byParser(TokenAccountParser)\n      .map(id => cache.get(id))\n      .filter(a => a && a.info.owner.toBase58() === walletKey)\n      .map(a => a as TokenAccount);\n  }, [walletKey]);\n\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(\n      a => a !== undefined,\n    ) as TokenAccount[];\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n\n  useEffect(() => {\n    const subs: number[] = [];\n    cache.emitter.onCache(args => {\n      if (args.isNew && args.isActive) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), info => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      });\n\n      // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n      const tokenSubID = connection.onProgramAccountChange(\n        programIds().token,\n        info => {\n          // TODO: fix type in web3.js\n          const id = info.accountId as unknown as string;\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n          if (info.accountInfo.data.length === AccountLayout.span) {\n            const data = deserializeAccount(info.accountInfo.data);\n\n            if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n              cache.add(id, info.accountInfo, TokenAccountParser);\n              setTokenAccounts(selectUserAccounts());\n            }\n          }\n        },\n        'singleGossip',\n      );\n\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n\n  return (\n    <AccountsContext.Provider\n      value={{\n        userAccounts,\n        nativeAccount,\n      }}\n    >\n      {children}\n    </AccountsContext.Provider>\n  );\n}\n\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount as AccountInfo<Buffer>,\n  };\n}\n\nexport const getMultipleAccounts = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const result = await Promise.all(\n    chunks(keys, 99).map(chunk =>\n      getMultipleAccountsCore(connection, chunk, commitment),\n    ),\n  );\n\n  const array = result\n    .map(\n      a =>\n        a.array.map(acc => {\n          if (!acc) {\n            return undefined;\n          }\n\n          const { data, ...rest } = acc;\n          const obj = {\n            ...rest,\n            data: Buffer.from(data[0], 'base64'),\n          } as AccountInfo<Buffer>;\n          return obj;\n        }) as AccountInfo<Buffer>[],\n    )\n    .flat();\n  return { keys, array };\n};\n\nconst getMultipleAccountsCore = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const args = connection._buildArgs([keys], commitment, 'base64');\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  if (unsafeRes.error) {\n    throw new Error(\n      'failed to get info about account ' + unsafeRes.error.message,\n    );\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\n    return { keys, array };\n  }\n\n  // TODO: fix\n  throw new Error();\n};\n\nexport function useMint(key?: string | PublicKey) {\n  const connection = useConnection();\n  const [mint, setMint] = useState<MintInfo>();\n\n  const id = typeof key === 'string' ? key : key?.toBase58();\n\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache\n      .query(connection, id, MintParser)\n      .then(acc => setMint(acc.info as any))\n      .catch(err => console.log(err));\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === id) {\n        cache\n          .query(connection, id, MintParser)\n          .then(mint => setMint(mint.info as any));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n\n  return mint;\n}\n\nexport function useAccount(pubKey?: PublicKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState<TokenAccount>();\n\n  const key = pubKey?.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache\n          .query(connection, key, TokenAccountParser)\n          .catch(err => console.log(err));\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n\n  return account;\n}\n\n// TODO: expose in spl package\nexport const deserializeAccount = (data: Buffer) => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n\n// TODO: expose in spl package\nexport const deserializeMint = (data: Buffer) => {\n  if (data.length !== MintLayout.span) {\n    throw new Error('Not a valid Mint');\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as MintInfo;\n};\n","import {\n  TOKEN_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  BPF_UPGRADE_LOADER_ID,\n  SYSTEM,\n  MEMO_ID,\n} from './ids';\n\nexport const setProgramIds = async () => {};\n\nexport const programIds = () => {\n  return {\n    token: TOKEN_PROGRAM_ID,\n    associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    bpf_upgrade_loader: BPF_UPGRADE_LOADER_ID,\n    system: SYSTEM,\n    memo: MEMO_ID,\n    // store: STORE,\n  };\n};\n","import React from 'react';\nimport { notification } from 'antd';\n// import Link from '../components/Link';\n\nexport function notify({\n  message = '',\n  description = undefined as any,\n  txid = '',\n  type = 'info',\n  placement = 'bottomLeft',\n}) {\n  if (txid) {\n    //   <Link\n    //     external\n    //     to={'https://explorer.solana.com/tx/' + txid}\n    //     style={{ color: '#0000ff' }}\n    //   >\n    //     View transaction {txid.slice(0, 8)}...{txid.slice(txid.length - 8)}\n    //   </Link>\n\n    description = <></>;\n  }\n  (notification as any)[type]({\n    message: <span style={{ color: 'black' }}>{message}</span>,\n    description: (\n      <span style={{ color: 'black', opacity: 0.5 }}>{description}</span>\n    ),\n    placement,\n    style: {\n      backgroundColor: 'white',\n    },\n  });\n}\n","import React from 'react';\nimport { Typography } from 'antd';\nimport { shortenAddress } from '../../utils/utils';\nimport { PublicKey } from '@solana/web3.js';\n\nexport const ExplorerLink = (props: {\n  address: string | PublicKey;\n  type: string;\n  code?: boolean;\n  style?: React.CSSProperties;\n  length?: number;\n}) => {\n  const { type, code } = props;\n\n  const address =\n    typeof props.address === 'string'\n      ? props.address\n      : props.address?.toBase58();\n\n  if (!address) {\n    return null;\n  }\n\n  const length = props.length ?? 9;\n\n  return (\n    <a\n      href={`https://explorer.solana.com/${type}/${address}`}\n      target=\"_blank\"\n      title={address}\n      style={props.style}\n    >\n      {code ? (\n        <Typography.Text style={props.style} code>\n          {shortenAddress(address, length)}\n        </Typography.Text>\n      ) : (\n        shortenAddress(address, length)\n      )}\n    </a>\n  );\n};\n","import { EventEmitter as Emitter } from 'eventemitter3';\n\nexport class CacheUpdateEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  parser: any;\n  isNew: boolean;\n  isActive: boolean;\n  constructor(id: string, isNew: boolean, parser: any, isActive: boolean) {\n    this.id = id;\n    this.parser = parser;\n    this.isNew = isNew;\n    this.isActive = isActive;\n  }\n}\n\nexport class CacheDeleteEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n\nexport class MarketUpdateEvent {\n  static type = 'MarketUpdate';\n  ids: Set<string>;\n  constructor(ids: Set<string>) {\n    this.ids = ids;\n  }\n}\n\nexport class EventEmitter {\n  private emitter = new Emitter();\n\n  onMarket(callback: (args: MarketUpdateEvent) => void) {\n    this.emitter.on(MarketUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(MarketUpdateEvent.type, callback);\n  }\n\n  onCache(callback: (args: CacheUpdateEvent) => void) {\n    this.emitter.on(CacheUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(CacheUpdateEvent.type, callback);\n  }\n\n  raiseMarketUpdated(ids: Set<string>) {\n    this.emitter.emit(MarketUpdateEvent.type, new MarketUpdateEvent(ids));\n  }\n\n  raiseCacheUpdated(\n    id: string,\n    isNew: boolean,\n    parser: any,\n    isActive: boolean,\n  ) {\n    this.emitter.emit(\n      CacheUpdateEvent.type,\n      new CacheUpdateEvent(id, isNew, parser, isActive),\n    );\n  }\n\n  raiseCacheDeleted(id: string) {\n    this.emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));\n  }\n}\n","import React, { useCallback } from \"react\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { ENDPOINTS, useColorMode, useConnectionConfig } from \"../../contexts\";\nimport { notify, shortenAddress } from \"../../utils\";\nimport { CopyOutlined } from \"@ant-design/icons\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport { Box, flexbox } from \"@mui/system\";\nimport { Button, NativeSelect } from \"@mui/material\";\nimport { useTheme } from \"@mui/material/styles\";\nimport IconButton from \"@mui/material/IconButton\";\nimport Brightness4Icon from \"@mui/icons-material/Brightness4\";\nimport Brightness7Icon from \"@mui/icons-material/Brightness7\";\n\nexport const Settings = ({\n  additionalSettings,\n}: {\n  additionalSettings?: JSX.Element;\n}) => {\n  const { connected, disconnect, publicKey } = useWallet();\n  const { endpoint, setEndpoint, env } = useConnectionConfig();\n  const { setVisible } = useWalletModal();\n  const open = useCallback(() => setVisible(true), [setVisible]);\n  const { setModal } = useModal();\n  const theme = useTheme();\n  const colorModeCtx = useColorMode();\n\n  const handleConnect = useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n\n  return (\n    <>\n      <Box sx={{ display: \"flex\", minWidth: \"100%\" }}>\n        {!connected && (\n          <>\n            <NativeSelect style={{ marginBottom: 5 }}>\n              {ENDPOINTS.map(({ name, endpoint }) => (\n                <option value={endpoint}>{name}</option>\n              ))}\n            </NativeSelect>\n            <Button\n              variant=\"contained\"\n              onClick={handleConnect}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Connect\n            </Button>\n          </>\n        )}\n        {connected && (\n          <>\n            {publicKey && (\n              <Button\n                variant=\"outlined\"\n                onClick={async () => {\n                  if (publicKey) {\n                    await navigator.clipboard.writeText(publicKey.toBase58());\n                    notify({\n                      message: \"Wallet update\",\n                      description: \"Address copied to clipboard\",\n                    });\n                  }\n                }}\n              >\n                <CopyOutlined />\n                {shortenAddress(publicKey.toBase58())}\n              </Button>\n            )}\n            <Button\n              variant=\"outlined\"\n              onClick={open}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Change Wallet\n            </Button>\n            <Button\n              variant=\"contained\"\n              color=\"error\"\n              onClick={() => disconnect().catch()}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Disconnect ({env})\n            </Button>\n          </>\n        )}\n        <IconButton\n          sx={{ ml: 1 }}\n          onClick={colorModeCtx.toggleColorMode}\n          color=\"inherit\"\n        >\n          {theme.palette.mode === \"dark\" ? (\n            <Brightness7Icon />\n          ) : (\n            <Brightness4Icon />\n          )}\n        </IconButton>\n        {additionalSettings}\n      </Box>\n    </>\n  );\n};\n","import React from \"react\";\nimport { Modal } from \"antd\";\n\nimport \"./index.css\";\n\nexport const DefaultModal = (props: any) => {\n  const { children, closeIcon, bodyStyle, style, ...rest } = props;\n\n  return (\n    <Modal\n      style={{ background: \"transparent\", borderRadius: 16 }}\n      bodyStyle={{\n        background: \"#333333\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        ...bodyStyle,\n      }}\n      footer={null}\n      width={400}\n      {...rest}\n    >\n      {children}\n    </Modal>\n  );\n};\n","import {\n  SystemProgram,\n  TransactionInstruction,\n  PublicKey,\n  Keypair,\n} from \"@solana/web3.js\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\nimport { Connection as Conn } from \"../contexts\";\nimport BN from \"bn.js\";\nimport {\n  notify,\n  createAssociatedTokenAccountInstruction,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from \"../utils\";\nimport { Schema, serialize } from \"borsh\";\nimport { TOKEN_PROGRAM_ID, Token, NATIVE_MINT } from \"@solana/spl-token\";\n\n// Hard-coded devnet key for now\nexport const PROGRAM_ID = new PublicKey(\n  \"SAtnofysr9Uxk7m9YphxwfL5E3wyZJWUzjwA29Gw3tQ\"\n);\n\nexport class AcceptOfferArgs {\n  instruction: number = 0;\n  makerSize: BN;\n  takerSize: BN;\n  bumpSeed: number;\n\n  static schema: Schema = new Map([\n    [\n      AcceptOfferArgs,\n      {\n        kind: \"struct\",\n        fields: [\n          [\"instruction\", \"u8\"],\n          [\"makerSize\", \"u64\"],\n          [\"takerSize\", \"u64\"],\n          [\"bumpSeed\", \"u8\"],\n        ],\n      },\n    ],\n  ]);\n\n  constructor(args: { makerSize: BN; takerSize: BN; bumpSeed: number }) {\n    this.makerSize = args.makerSize;\n    this.takerSize = args.takerSize;\n    this.bumpSeed = args.bumpSeed;\n  }\n}\n\nexport const acceptOfferInstruction = async (\n  makerWallet: PublicKey,\n  takerWallet: PublicKey,\n  makerSrc: PublicKey,\n  makerDst: PublicKey,\n  takerSrc: PublicKey,\n  takerDst: PublicKey,\n  makerSrcMint: PublicKey,\n  takerSrcMint: PublicKey,\n  transferAuthority: PublicKey,\n  makerSize: BN,\n  takerSize: BN,\n  bumpSeed: number\n) => {\n  let settings = new AcceptOfferArgs({ makerSize, takerSize, bumpSeed });\n  const data = Buffer.from(serialize(AcceptOfferArgs.schema, settings));\n  let keys = [\n    {\n      pubkey: makerWallet,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: takerWallet,\n      isSigner: true,\n      isWritable: false,\n    },\n    {\n      pubkey: makerSrc,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: makerDst,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: takerSrc,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: takerDst,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: makerSrcMint,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: takerSrcMint,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: transferAuthority,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n  ]\n  if (takerSrcMint.toBase58() === NATIVE_MINT.toBase58()) {\n    keys.push(\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      }\n    )\n  }\n  return {\n    ix: [\n      new TransactionInstruction({\n        keys,\n        programId: PROGRAM_ID,\n        data,\n      }),\n    ],\n  };\n};\n\nexport const changeOffer = async (\n  connection,\n  mintA: PublicKey,\n  mintB: PublicKey,\n  sizeA: BN,\n  sizeB: BN,\n  wallet: any,\n  approve = true\n) => {\n  if (!wallet.publicKey) {\n    notify({ message: \"Wallet not connected!\" });\n    return false;\n  }\n  let signers: Keypair[] = [];\n  let ataIx: TransactionInstruction[] = [];\n\n  const tokenAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintA.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintA = await connection.getAccountInfo(tokenAccountMintA);\n  if (!hasATAMintA) {\n    notify({ message: \"User must have ATA to create offer\" });\n    return false;\n  }\n\n  let tokenAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintB.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintB = await connection.getAccountInfo(tokenAccountMintB);\n  if (!hasATAMintB) {\n    createAssociatedTokenAccountInstruction(\n      ataIx,\n      tokenAccountMintB,\n      wallet.publicKey,\n      wallet.publicKey,\n      mintB\n    );\n  }\n  tokenAccountMintB = mintB.toBase58() === NATIVE_MINT.toBase58() ? wallet.publicKey : tokenAccountMintB;\n  const [transferAuthority, bump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"stateless_offer\"),\n      wallet.publicKey.toBuffer(),\n      mintA.toBuffer(),\n      mintB.toBuffer(),\n      new Uint8Array(sizeA.toArray(\"le\", 8)),\n      new Uint8Array(sizeB.toArray(\"le\", 8)),\n    ],\n    PROGRAM_ID\n  );\n  let authIx;\n  if (approve) {\n    authIx = Token.createApproveInstruction(\n      TOKEN_PROGRAM_ID,\n      tokenAccountMintA,\n      transferAuthority,\n      wallet.publicKey,\n      [],\n      sizeA.toNumber(),\n    );\n  } else {\n    authIx = Token.createRevokeInstruction(\n      TOKEN_PROGRAM_ID,\n      tokenAccountMintA,\n      wallet.publicKey,\n      []\n    );\n  }\n  const response = await Conn.sendTransactionWithRetry(\n    connection,\n    wallet,\n    [...ataIx, authIx],\n    signers,\n    \"max\"\n  );\n  if (!response) {\n    notify({ message: \"Delegation transaction failed\" });\n    return false;\n  } else {\n    return true;\n  }\n};\n\nexport const trade = async (\n  connection,\n  maker: PublicKey,\n  mintA: PublicKey,\n  mintB: PublicKey,\n  sizeA: BN,\n  sizeB: BN,\n  wallet: any,\n) => {\n  if (!wallet.publicKey) {\n    notify({ message: \"Wallet not connected!\" });\n    return false;\n  }\n  let signers: Keypair[] = [];\n  let ataIx: TransactionInstruction[] = [];\n\n  const makerAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [maker.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintA.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  if (!(await connection.getAccountInfo(makerAccountMintA))) {\n    notify({ message: \"Maker must have ATA for mint A\" });\n    return false;\n  }\n\n  let makerAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [maker.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintB.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  if (!(await connection.getAccountInfo(makerAccountMintB))) {\n    notify({ message: \"Maker must have ATA for mint B\" });\n    return false;\n  }\n\n  const takerAccountMintA = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintA.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintA = await connection.getAccountInfo(takerAccountMintA);\n  if (!hasATAMintA) {\n    createAssociatedTokenAccountInstruction(\n      ataIx,\n      takerAccountMintA,\n      wallet.publicKey,\n      wallet.publicKey,\n      mintA\n    );\n  }\n\n  let takerAccountMintB = (\n    await PublicKey.findProgramAddress(\n      [\n        wallet.publicKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        mintB.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n\n  const hasATAMintB = await connection.getAccountInfo(\n    new PublicKey(takerAccountMintB)\n  );\n  console.log(mintB.toBase58())\n  console.log(NATIVE_MINT)\n  if (!hasATAMintB && mintB.toBase58() != NATIVE_MINT.toBase58()) {\n    notify({ message: \"Taker must have ATA for mint B\" });\n    return false;\n  }\n\n  makerAccountMintB = mintB.toBase58() === NATIVE_MINT.toBase58() ? maker : makerAccountMintB;\n  takerAccountMintB =  mintB.toBase58() === NATIVE_MINT.toBase58() ? wallet.publicKey : takerAccountMintB;\n  const [transferAuthority, bump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"stateless_offer\"),\n      maker.toBuffer(),\n      mintA.toBuffer(),\n      mintB.toBuffer(),\n      new Uint8Array(sizeA.toArray(\"le\", 8)),\n      new Uint8Array(sizeB.toArray(\"le\", 8)),\n    ],\n    PROGRAM_ID\n  );\n\n  let { ix } = await acceptOfferInstruction(\n    maker,\n    wallet.publicKey,\n    makerAccountMintA,\n    makerAccountMintB,\n    takerAccountMintB,\n    takerAccountMintA,\n    mintA,\n    mintB,\n    transferAuthority,\n    sizeA,\n    sizeB,\n    bump\n  );\n  const tradeIx = ix;\n\n  const response = await Conn.sendTransactionWithRetry(\n    connection,\n    wallet,\n    [...ataIx, ...tradeIx],\n    signers,\n    \"max\"\n  );\n  if (!response) {\n    notify({ message: \"Trade transaction failed\" });\n    return false;\n  } else {\n    return true;\n  }\n};\n","import { AccountLayout, MintLayout, Token } from '@solana/spl-token';\nimport {\n  Account,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport {\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n  WRAPPED_SOL_MINT,\n} from '../utils/ids';\nimport { programIds } from '../utils/programIds';\nimport { TokenAccount } from '../models/account';\nimport { cache, TokenAccountParser } from '../contexts/AccountContext';\n\nexport function ensureSplAccount(\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  toCheck: TokenAccount,\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  if (!toCheck.info.isNative) {\n    return toCheck.pubkey;\n  }\n\n  const account = createUninitializedAccount(\n    instructions,\n    payer,\n    amount,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      WRAPPED_SOL_MINT,\n      account,\n      payer,\n    ),\n  );\n\n  cleanupInstructions.push(\n    Token.createCloseAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      account,\n      payer,\n      payer,\n      [],\n    ),\n  );\n\n  return account;\n}\n\nexport const DEFAULT_TEMP_MEM_SPACE = 65548;\n\nexport function createTempMemoryAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  signers: Keypair[],\n  owner: PublicKey,\n  space = DEFAULT_TEMP_MEM_SPACE,\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      // 0 will evict/close account since it cannot pay rent\n      lamports: 0,\n      space: space,\n      programId: owner,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createUninitializedMint(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: MintLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createUninitializedAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: AccountLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport function createAssociatedTokenAccountInstruction(\n  instructions: TransactionInstruction[],\n  associatedTokenAddress: PublicKey,\n  payer: PublicKey,\n  walletAddress: PublicKey,\n  splTokenMintAddress: PublicKey,\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  instructions.push(\n    new TransactionInstruction({\n      keys,\n      programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n      data: Buffer.from([]),\n    }),\n  );\n}\n\nexport function createMint(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  mintRentExempt: number,\n  decimals: number,\n  owner: PublicKey,\n  freezeAuthority: PublicKey,\n  signers: Keypair[],\n) {\n  const account = createUninitializedMint(\n    instructions,\n    payer,\n    mintRentExempt,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      account,\n      decimals,\n      owner,\n      freezeAuthority,\n    ),\n  );\n\n  return account;\n}\n\nexport function createMintFromAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  amount: number,\n  decimals: number,\n  owner: PublicKey,\n  freezeAuthority: PublicKey,\n  account: Keypair,\n) {\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: MintLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n  instructions.push(\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      account.publicKey,\n      decimals,\n      owner,\n      freezeAuthority,\n    ),\n  );\n  return account;\n}\n\nexport function createTokenAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  accountRentExempt: number,\n  mint: PublicKey,\n  owner: PublicKey,\n  signers: Keypair[],\n) {\n  const account = createUninitializedAccount(\n    instructions,\n    payer,\n    accountRentExempt,\n    signers,\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, account, owner),\n  );\n\n  return account;\n}\n\nexport function ensureWrappedAccount(\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  toCheck: TokenAccount | undefined,\n  payer: PublicKey,\n  amount: number,\n  signers: Keypair[],\n) {\n  if (toCheck && !toCheck.info.isNative) {\n    return toCheck.pubkey;\n  }\n\n  const TOKEN_PROGRAM_ID = programIds().token;\n  const account = Keypair.generate();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: AccountLayout.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      WRAPPED_SOL_MINT,\n      account.publicKey,\n      payer,\n    ),\n  );\n\n  cleanupInstructions.push(\n    Token.createCloseAccountInstruction(\n      TOKEN_PROGRAM_ID,\n      account.publicKey,\n      payer,\n      payer,\n      [],\n    ),\n  );\n\n  signers.push(account);\n\n  return account.publicKey.toBase58();\n}\n\n// TODO: check if one of to accounts needs to be native sol ... if yes unwrap it ...\nexport function findOrCreateAccountByMint(\n  payer: PublicKey,\n  owner: PublicKey,\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  accountRentExempt: number,\n  mint: PublicKey, // use to identify same type\n  signers: Keypair[],\n  excluded?: Set<string>,\n): PublicKey {\n  const accountToFind = mint.toBase58();\n  const ownerKey = owner.toBase58();\n  const account = cache\n    .byParser(TokenAccountParser)\n    .map(id => cache.get(id))\n    .find(\n      acc =>\n        acc !== undefined &&\n        acc.info.mint.toBase58() === accountToFind &&\n        acc.info.owner.toBase58() === ownerKey &&\n        (excluded === undefined || !excluded.has(acc.pubkey)),\n    );\n  const isWrappedSol = accountToFind === WRAPPED_SOL_MINT.toBase58();\n\n  let toAccount: PublicKey;\n  if (account && !isWrappedSol) {\n    toAccount = new PublicKey(account.pubkey);\n  } else {\n    // creating depositor pool account\n    toAccount = createTokenAccount(\n      instructions,\n      payer,\n      accountRentExempt,\n      mint,\n      owner,\n      signers,\n    );\n\n    if (isWrappedSol) {\n      cleanupInstructions.push(\n        Token.createCloseAccountInstruction(\n          TOKEN_PROGRAM_ID,\n          toAccount,\n          payer,\n          payer,\n          [],\n        ),\n      );\n    }\n  }\n\n  return toAccount;\n}","import React, { useMemo, useEffect, useState } from \"react\";\nimport Box from \"@mui/material/Box\";\nimport Button from \"@mui/material/Button\";\nimport TextField from \"@mui/material/TextField\";\nimport {\n  cache,\n  useConnection,\n  deserializeAccount,\n  deserializeMint,\n} from \"../../contexts\";\nimport { FormControlUnstyled } from \"@mui/material\";\nimport {\n  notify,\n  createAssociatedTokenAccountInstruction,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from \"../../utils\";\nimport { Schema, serialize } from \"borsh\";\nimport { TOKEN_PROGRAM_ID, Token, NATIVE_MINT } from \"@solana/spl-token\";\nimport { changeOffer, trade } from \"../../actions/accept_offer\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\n\nconst displayMakerButton = () => { };\n\nconst getSize = (n : any, mint: any, mintCache: any) => {\n  const dec = mintCache[mint].decimals;\n  const size = Math.floor(parseFloat(n) * Math.pow(10, dec));\n  return size;\n}\n\nconst getDelegate = async (formState: any, mintCache: any) => {\n  try {\n    const sizeA = getSize(formState.sizeA, formState.mintA, mintCache);\n    const sizeB = getSize(formState.sizeB, formState.mintB, mintCache);\n    return (await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"stateless_offer\"),\n        (new PublicKey(formState.maker)).toBuffer(),\n        (new PublicKey(formState.mintA)).toBuffer(),\n        (new PublicKey(formState.mintB)).toBuffer(),\n        new Uint8Array((new BN(sizeA)).toArray(\"le\", 8)),\n        new Uint8Array((new BN(sizeB)).toArray(\"le\", 8)),\n      ],\n      new PublicKey(\"SAtnofysr9Uxk7m9YphxwfL5E3wyZJWUzjwA29Gw3tQ\")\n    ))[0];\n  }\n  catch {\n    return null;\n  }\n}\n\nconst getDefaultFormState = () => {\n  let url = new URL(window.location.href);\n  let params = new URLSearchParams(url.search.slice(1));\n  let defaultState = {\n    mintA: \"\",\n    mintB: \"\",\n    sizeA: \"0\",\n    sizeB: \"0\",\n    maker: \"\",\n  };\n  for(const key of params.keys()) {\n    defaultState[key] = params.get(key);\n  }\n  return defaultState;\n}\n\nexport function TransferBox() {\n  const connection = useConnection();\n  const wallet = useWallet();\n  const [formState, setFormState] = useState(getDefaultFormState());\n  const [accountState, setAccountState] = useState({});\n  const [mintCache, setMintCache] = useState({});\n  const [isSeller, setIsSeller] = useState(false);\n  const [validAmount, setValidAmount] = useState(false);\n  const [hasDelegate, setHasDelegate] = useState(false);\n\n  useEffect(() => {\n    if (!wallet) {\n      return;\n    }\n    setIsSeller(wallet.publicKey?.toBase58() === formState.maker);\n  }, [formState, wallet, setIsSeller]);\n\n  useEffect(() => {\n    let subId;\n    const fetchAccountState = async () => {\n      let sellerWallet;\n      let sellerMint;\n      try {\n        sellerWallet = new PublicKey(formState.maker);\n        sellerMint = new PublicKey(formState.mintA);\n      } catch {\n        return;\n      }\n      const sellerTokenAccount = (\n        await PublicKey.findProgramAddress(\n          [\n            sellerWallet.toBuffer(),\n            TOKEN_PROGRAM_ID.toBuffer(),\n            sellerMint.toBuffer(),\n          ],\n          SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n        )\n      )[0];\n      const result = await connection.getAccountInfo(sellerTokenAccount);\n      if (result) {\n        console.log(\"Received account data\");\n        const tokenAccount = deserializeAccount(result.data);\n        console.log(tokenAccount);\n        setAccountState(tokenAccount);\n        const mint = tokenAccount.mint.toBase58();\n        if (mint in mintCache) {\n          const dec = mintCache[mint].decimals;\n          const totalAmount = tokenAccount.amount * Math.pow(10, -dec);\n          try {\n            const size = parseFloat(formState.sizeA);\n            setValidAmount(totalAmount >= size && size > 0);\n          }\n          catch {\n            console.log(\"Not a valid float\");\n          }\n        }\n\n        const delegate = await getDelegate(formState, mintCache);\n        if (tokenAccount.delegate && delegate && tokenAccount.delegateOption != 0 && delegate.toBase58() === tokenAccount.delegate.toBase58()) {\n          setHasDelegate(true);\n        }\n        else{\n          setHasDelegate(false);\n        }\n      }\n      subId = connection.onAccountChange(sellerTokenAccount, async (result) => {\n        if (result) {\n          console.log(\"Received account data\");\n          try {\n            const tokenAccount = deserializeAccount(result.data);\n            setAccountState(tokenAccount);\n            console.log(accountState);\n            const mint = tokenAccount.mint.toBase58();\n            if (mint in mintCache) {\n              const dec = mintCache[mint].decimals;\n              const totalAmount = tokenAccount.amount;\n              try {\n                const size = parseFloat(formState.sizeA);\n                setValidAmount(totalAmount >= size && size > 0);\n              }\n              catch {\n                console.log(\"Not a valid float\");\n              }\n            }\n\n            const delegate = await getDelegate(formState, mintCache);\n            if (tokenAccount.delegate && delegate && tokenAccount.delegateOption != 0 && delegate.toBase58() === tokenAccount.delegate.toBase58()) {\n              setHasDelegate(true);\n            }\n            else{\n              setHasDelegate(false);\n            }\n          } catch (e) {\n            console.log(\"Failed to deserialize account\", e);\n          }\n        }\n      });\n    };\n    const fetchMintState = async () => {\n      let mint;\n      for (const mintString of [formState.mintA, formState.mintB]) {\n        try {\n          mint = new PublicKey(mintString);\n        } catch (e) {\n          console.log(\"Invalid Pubkey\");\n          continue;\n        }\n        if (!(mint.toBase58() in mintCache)) {\n          let result = await connection.getAccountInfo(mint);\n          if (result) {\n            try {\n              const mintData = deserializeMint(result.data)\n              setMintCache({\n                ...mintCache,\n                [mintString]: mintData,\n              });\n              console.log(mintCache);\n            } catch {\n              console.log(\"Invalid Mint\");\n            }\n          }\n        }\n      }\n    };\n    fetchAccountState();\n    fetchMintState();\n    return () => {\n      if (subId) connection.removeAccountChangeListener(subId);\n    };\n  }, [formState, mintCache, wallet, setAccountState, setMintCache]);\n\n  useEffect(() => console.log(mintCache), [mintCache]);\n\n  useEffect(() => { }, [formState]);\n\n  const setField = (name: any) => {\n    const setFieldWithName = (e) => {\n      setFormState({ ...formState, [name]: e.target.value });\n      let url = new URL(window.location.href);\n      let params = new URLSearchParams(url.search.slice(1));\n      params.set(name, escape(e.target.value));  \n      let newUrl = window.location.protocol + \"//\" + window.location.host + window.location.pathname + \"?\" + params.toString();   \n      window.history.pushState({path: newUrl}, '', newUrl);\n    };\n    return setFieldWithName;\n  };\n\n  const getField = (name: any) => {\n    if (name in formState) {\n      return formState[name];\n    }\n  };\n\n  return (\n    <Box\n      component=\"form\"\n      sx={{\n        \"& .MuiTextField-root\": { m: 1, width: \"50ch\" },\n      }}\n      noValidate\n      autoComplete=\"on\"\n    >\n      <div>\n        <TextField\n          required\n          id=\"outlined-required\"\n          label=\"Seller Public Key\"\n          value={getField(\"maker\")}\n          onChange={setField(\"maker\")}\n        />\n        <TextField\n          required\n          id=\"outlined-required\"\n          label=\"Seller Mint\"\n          value={getField(\"mintA\")}\n          onChange={setField(\"mintA\")}\n        />\n        <TextField\n          required\n          id=\"outlined-required\"\n          label=\"Buyer Mint\"\n          value={getField(\"mintB\")}\n          onChange={setField(\"mintB\")}\n        />\n        <TextField\n          id=\"outlined-number\"\n          label=\"Seller Size\"\n          type=\"number\"\n          value={getField(\"sizeA\")}\n          onChange={setField(\"sizeA\")}\n          InputLabelProps={{\n            shrink: true,\n          }}\n        />\n        <TextField\n          id=\"outlined-number\"\n          label=\"Buyer Size\"\n          type=\"number\"\n          value={getField(\"sizeB\")}\n          onChange={setField(\"sizeB\")}\n          InputLabelProps={{\n            shrink: true,\n          }}\n        />\n      </div>\n      <div style={{ marginTop: \"10px\" }}>\n        {isSeller ? (\n          <div>\n            <Button\n              variant=\"contained\"\n              onClick={() => {\n                if (formState) {\n                  try {\n                    changeOffer(\n                      connection,\n                      new PublicKey(formState.mintA),\n                      new PublicKey(formState.mintB),\n                      new BN(getSize(formState.sizeA, formState.mintA, mintCache)),\n                      new BN(getSize(formState.sizeB, formState.mintB, mintCache)),\n                      wallet\n                    );\n                  } catch (e) {\n                    return;\n                  }\n                }\n              }}\n              sx={{ marginRight: \"4px\" }}\n            >\n              Open Offer\n            </Button>\n            <Button\n              variant=\"contained\"\n              color=\"error\"\n              sx={{ marginRight: \"4px\" }}\n              onClick={() => {\n                if (formState) {\n                  try {\n                    changeOffer(\n                      connection,\n                      new PublicKey(formState.mintA),\n                      new PublicKey(formState.mintB),\n                      new BN(getSize(formState.sizeA, formState.mintA, mintCache)),\n                      new BN(getSize(formState.sizeB, formState.mintB, mintCache)),\n                      wallet,\n                      false\n                    );\n                  } catch (e) {\n                    return;\n                  }\n                }\n              }}\n            >\n              Close Offer\n            </Button>\n          </div>\n        ) : ( \n          (hasDelegate && validAmount) ? \n          <div>\n            <Button\n              variant=\"contained\"\n              color=\"success\"\n              onClick={() => {\n                if (formState) {\n                  try {\n                    trade(\n                      connection,\n                      new PublicKey(formState.maker),\n                      new PublicKey(formState.mintA),\n                      new PublicKey(formState.mintB),\n                      new BN(getSize(formState.sizeA, formState.mintA, mintCache)),\n                      new BN(getSize(formState.sizeB, formState.mintB, mintCache)),\n                      wallet\n                    );\n                  } catch (e) {\n                    return;\n                  }\n                }\n              }}\n            >\n              Trade\n            </Button>\n            </div>\n            : <div> </div>\n        )}\n      </div>\n    </Box>\n  );\n}\n","export default __webpack_public_path__ + \"static/media/wallet.c746d144.less\";","import { WalletAdapter, WalletError } from \"@solana/wallet-adapter-base\";\nimport {\n  useWallet,\n  WalletProvider as BaseWalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  getLedgerWallet,\n  getMathWallet,\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolongWallet,\n  getTorusWallet,\n  WalletName,\n} from \"@solana/wallet-adapter-wallets\";\nimport { Button } from \"antd\";\nimport React, {\n  createContext,\n  FC,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { notify } from \"../../utils\";\nimport { DefaultModal } from \"../../components\";\n\nimport \"./wallet.less\";\n\nexport interface WalletModalContextState {\n  visible: boolean;\n  setVisible: (open: boolean) => void;\n}\n\nexport const WalletModalContext = createContext<WalletModalContextState>(\n  {} as WalletModalContextState\n);\n\nexport function useWalletModal(): WalletModalContextState {\n  return useContext(WalletModalContext);\n}\n\nexport const WalletModal: FC = () => {\n  const { wallets, connected, wallet: selected, select } = useWallet();\n  const { visible, setVisible } = useWalletModal();\n  const [showWallets, setShowWallets] = useState(false);\n  const close = useCallback(() => {\n    setVisible(false);\n    setShowWallets(false);\n  }, [setVisible, setShowWallets]);\n\n  return (\n    <DefaultModal visible={visible} onCancel={close}>\n      <div\n        style={{\n          background:\n            \"linear-gradient(180deg, #D329FC 0%, #8F6DDE 49.48%, #19E6AD 100%)\",\n          borderRadius: 36,\n          width: 50,\n          height: 50,\n          textAlign: \"center\",\n          verticalAlign: \"middle\",\n          fontWeight: 700,\n          fontSize: \"1.3rem\",\n          lineHeight: 2.4,\n          marginBottom: 10,\n        }}\n      ></div>\n      <h2\n        style={{\n          color: \"white\",\n          fontWeight: \"bold\",\n          fontSize: 20,\n        }}\n      >\n        {selected ? \"Change provider\" : \"\"}\n      </h2>\n      <p style={{ color: \"white\", fontSize: 14 }}>\n        {selected\n          ? \"Choose from the following options:\"\n          : \"Please sign into your wallet\"}\n      </p>\n\n      <br />\n      {wallets.map((wallet) => {\n        return (\n          <Button\n            key={wallet.name}\n            size=\"large\"\n            type={wallet === selected ? \"primary\" : \"ghost\"}\n            onClick={() => {\n              select(wallet.name);\n              close();\n            }}\n            icon={\n              <img\n                alt={`${wallet.name}`}\n                width={20}\n                height={20}\n                src={wallet.icon}\n                style={{ marginRight: 30, float: \"left\" }}\n              />\n            }\n            style={{\n              display: \"block\",\n              width: \"100%\",\n              textAlign: \"left\",\n              marginBottom: 8,\n              color: \"white\",\n            }}\n          >\n            {wallet.name}\n          </Button>\n        );\n      })}\n    </DefaultModal>\n  );\n};\n\nexport const WalletModalProvider: FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const { publicKey } = useWallet();\n  const [connected, setConnected] = useState(!!publicKey);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (publicKey) {\n      const base58 = publicKey.toBase58();\n      const keyToDisplay =\n        base58.length > 20\n          ? `${base58.substring(0, 7)}.....${base58.substring(\n              base58.length - 7,\n              base58.length\n            )}`\n          : base58;\n\n      notify({\n        message: \"Wallet update\",\n        description: \"Connected to wallet \" + keyToDisplay,\n      });\n    }\n  }, [publicKey]);\n\n  useEffect(() => {\n    if (!publicKey && connected) {\n      notify({\n        message: \"Wallet update\",\n        description: \"Disconnected from wallet\",\n      });\n    }\n    setConnected(!!publicKey);\n  }, [publicKey, connected, setConnected]);\n\n  return (\n    <WalletModalContext.Provider\n      value={{\n        visible,\n        setVisible,\n      }}\n    >\n      {children}\n      <WalletModal />\n    </WalletModalContext.Provider>\n  );\n};\n\nexport const WalletProvider: FC<{ children: ReactNode }> = ({ children }) => {\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getTorusWallet({\n        options: {\n          // @FIXME: this should be changed for Default, and by each Default storefront\n          clientId:\n            \"BOM5Cl7PXgE9Ylq1Z1tqzhpydY0RVr8k90QQ85N7AKI5QGSrr9iDC-3rvmy0K_hF0JfpLMiXoDhta68JwcxS1LQ\",\n        },\n      }),\n      getLedgerWallet(),\n      getSolongWallet(),\n      getMathWallet(),\n      getSolletWallet(),\n    ],\n    []\n  );\n\n  const onError = useCallback((error: WalletError) => {\n    console.error(error);\n    notify({\n      message: \"Wallet error\",\n      description: error.message,\n    });\n  }, []);\n\n  return (\n    <BaseWalletProvider wallets={wallets} onError={onError} autoConnect>\n      <WalletModalProvider>{children}</WalletModalProvider>\n    </BaseWalletProvider>\n  );\n};\n\nexport type WalletSigner = Pick<\n  WalletAdapter,\n  \"publicKey\" | \"signTransaction\" | \"signAllTransactions\"\n>;\n","import React, { useState, useContext, useCallback } from 'react';\n\nimport { WalletModal } from './WalletContext/WalletContext';\n\nexport enum ModalEnum {\n  WALLET = 'wallet',\n}\n\ntype ModalContextProps = {\n  setModal: (modal: ModalEnum | undefined) => void;\n  removeModal: () => void;\n};\n\nexport const ModalContext = React.createContext<ModalContextProps>({\n  setModal: () => null,\n  removeModal: () => null,\n});\n\nexport const ModalProvider: React.FC = ({ children }) => {\n  const [modal, setModal] = useState<ModalEnum | undefined>(undefined);\n\n  const removeModal = useCallback(() => {\n    setModal(undefined);\n  }, [setModal]);\n\n  return (\n    <ModalContext.Provider\n      value={{\n        setModal,\n        removeModal,\n      }}\n    >\n      {children}\n      {modal === ModalEnum.WALLET && <WalletModal />}\n    </ModalContext.Provider>\n  );\n};\n\nexport const useModal = (): ModalContextProps => {\n  const context = useContext(ModalContext);\n  if (context === undefined) {\n    throw new Error('useModal must be used within a ModalProvider');\n  }\n  return context;\n};\n","import { createTheme, useTheme } from \"@mui/material\";\nimport React, { useContext, FC } from \"react\";\n\nexport const ColorModeContext = React.createContext({});\n\nexport const ColorModeContextProvider = ({children=null as any }) => {\n  const [mode, setMode] = React.useState<'light' | 'dark'>('dark'); \n  const theme = useTheme();\n  const toggleColorMode = () => {\n    setMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));\n  }\n  return (\n    <ColorModeContext.Provider\n      value={{\n        toggleColorMode,\n        mode,\n        theme,\n      }}\n    >\n      {children}\n    </ColorModeContext.Provider>\n  );\n};\n\nexport const useColorMode = (): any => {\n  const context = useContext(ColorModeContext);\n  return context;\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport { StringPublicKey } from './ids';\n\nexport const extendBorsh = () => {\n  (BinaryReader.prototype as any).readPubkey = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n  };\n\n  (BinaryWriter.prototype as any).writePubkey = function (value: PublicKey) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(value.toBuffer());\n  };\n\n  (BinaryReader.prototype as any).readPubkeyAsString = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array) as StringPublicKey;\n  };\n\n  (BinaryWriter.prototype as any).writePubkeyAsString = function (\n    value: StringPublicKey,\n  ) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(base58.decode(value));\n  };\n};\n\nextendBorsh();\n","import { PublicKey, AccountInfo, Account } from '@solana/web3.js';\n\nexport type StringPublicKey = string;\n\nexport class LazyAccountInfoProxy<T> {\n  executable: boolean = false;\n  owner: StringPublicKey = '';\n  lamports: number = 0;\n\n  get data() {\n    //\n    return undefined as unknown as T;\n  }\n}\n\nexport interface LazyAccountInfo {\n  executable: boolean;\n  owner: StringPublicKey;\n  lamports: number;\n  data: [string, string];\n}\n\nconst PubKeysInternedMap = new Map<string, PublicKey>();\n\nexport const toPublicKey = (key: string | PublicKey) => {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  let result = PubKeysInternedMap.get(key);\n  if (!result) {\n    result = new PublicKey(key);\n    PubKeysInternedMap.set(key, result);\n  }\n\n  return result;\n};\n\nexport interface PublicKeyStringAndAccount<T> {\n  pubkey: string;\n  account: AccountInfo<T>;\n}\n\nexport const WRAPPED_SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const BPF_UPGRADE_LOADER_ID = new PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');\n\nexport const MEMO_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');\n\nexport const SYSTEM = new PublicKey('11111111111111111111111111111111');\n","import { ButtonGroup, ButtonGroupProps } from \"@mui/material\";\nimport { Settings } from \"./Settings\";\n\nexport type ConnectButtonProps = ButtonGroupProps & {\n  isConnected: boolean;\n  onClickConnect: () => void;\n  onClickChange: () => void;\n};\n\nexport const ConnectButton: React.FC<ConnectButtonProps> = ({\n  isConnected,\n  onClickConnect,\n  onClickChange,\n  ...restProps\n}) => {\n  return (\n    <ButtonGroup   {...restProps}>\n      <Settings/>\n    </ButtonGroup>\n  );\n};\n\nexport default ConnectButton;\n","import React, { useCallback } from \"react\";\nimport { Box } from \"@mui/system\";\n\nimport ConnectButton from \"../ConnectButton\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { AppBar } from \"@mui/material\";\n\nexport const Header: React.FC = () => {\n  const { setModal } = useModal();\n  const { setVisible } = useWalletModal();\n  const wallet = useWallet();\n  const connected = wallet.connected;\n\n  const handleChange = useCallback(() => setVisible(true), [setVisible]);\n\n  const handleConnect = useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n  return (\n    <Box\n      sx={{\n        display: \"flex\",\n        bgcolor: \"action.disabledBackground\",\n      }}\n      minWidth=\"100%\"\n    >\n      <Box sx={{flexGrow: 1}}></Box>\n      <Box\n        sx={{\n          display: \"flex\",\n          height: \"62px\",\n          justifyContent: \"flex-end\",\n          alignItems: \"center\",\n        }}\n      >\n        <ConnectButton\n          isConnected={connected}\n          sx={{ marginRight: \"36px\" }}\n          onClickConnect={handleConnect}\n          onClickChange={handleChange}\n        />\n      </Box>\n    </Box>\n  );\n};\n\nexport default Header;\n","import React, { useEffect } from \"react\";\nimport \"./App.css\";\nimport Header from \"./components/Header/Header\";\nimport { TransferBox } from \"./components\";\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\";\nimport CssBaseline from \"@mui/material/CssBaseline\";\nimport { useColorMode } from \"./contexts\";\nimport { Box } from \"@mui/material\";\n\nfunction App() {\n  const colorModeCtx = useColorMode();\n\n  const mode =\n    colorModeCtx.mode === \"dark\" || !colorModeCtx.mode ? \"dark\" : \"light\";\n\n  useEffect(() => {}, [colorModeCtx.mode]);\n\n  const theme = React.useMemo(\n    () =>\n      createTheme({\n        palette: {\n          mode,\n        },\n      }),\n    [colorModeCtx.mode]\n  );\n\n  return (\n    <div className=\"App\" style={{ backgroundColor: \"transparent\" }}>\n      <ThemeProvider theme={theme}>\n        <CssBaseline />\n        <Header />\n        <Box\n          sx={{\n            marginTop: \"15%\",\n            width: 600,\n            px: \"50%\",\n            display: \"flex\",\n            alignSelf: \"center\",\n            justifyContent: \"center\",\n            alignContent: \"center\",\n          }}\n        >\n          <TransferBox />\n        </Box>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  AccountsProvider,\n  WalletProvider,\n  ConnectionProvider,\n  ColorModeContextProvider,\n} from \"./contexts\";\n\nimport \"antd/dist/antd.css\";\nimport \"@fontsource/open-sans\";\nimport \"@fontsource/roboto\";\nimport \"@fontsource/sora\";\n\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <ConnectionProvider>\n      <WalletProvider>\n        <AccountsProvider>\n          <ColorModeContextProvider>\n            <App />\n          </ColorModeContextProvider>\n        </AccountsProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nreportWebVitals();\n","import BN from 'bn.js';\n\nexport const TEN = new BN(10);\nexport const HALF_WAD = TEN.pow(new BN(18));\nexport const WAD = TEN.pow(new BN(18));\nexport const RAY = TEN.pow(new BN(27));\nexport const ZERO = new BN(0);\n","import { useCallback, useState } from 'react';\nimport { MintInfo } from '@solana/spl-token';\n\nimport { TokenAccount } from './../models';\nimport { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { WAD, ZERO } from '../constants';\nimport { TokenInfo } from '@solana/spl-token-registry';\n\nexport type KnownTokenMap = Map<string, TokenInfo>;\n\nexport const formatPriceNumber = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 8,\n});\n\nexport function useLocalStorageState(key: string, defaultState?: string) {\n  const [state, setState] = useState(() => {\n    // NOTE: Not sure if this is ok\n    const storedState = localStorage.getItem(key);\n    if (storedState) {\n      return JSON.parse(storedState);\n    }\n    return defaultState;\n  });\n\n  const setLocalStorageState = useCallback(\n    newState => {\n      const changed = state !== newState;\n      if (!changed) {\n        return;\n      }\n      setState(newState);\n      if (newState === null) {\n        localStorage.removeItem(key);\n      } else {\n        try {\n          localStorage.setItem(key, JSON.stringify(newState));\n        } catch {\n          // ignore\n        }\n      }\n    },\n    [state, key],\n  );\n\n  return [state, setLocalStorageState];\n}\n\nexport const findProgramAddress = async (\n  seeds: (Buffer | Uint8Array)[],\n  programId: PublicKey,\n) => {\n  const key =\n    'pda-' +\n    seeds.reduce((agg, item) => agg + item.toString('hex'), '') +\n    programId.toString();\n  let cached = localStorage.getItem(key);\n  if (cached) {\n    const value = JSON.parse(cached);\n\n    return [value.key, parseInt(value.nonce)] as [string, number];\n  }\n\n  const result = await PublicKey.findProgramAddress(seeds, programId);\n\n  try {\n    localStorage.setItem(\n      key,\n      JSON.stringify({\n        key: result[0].toBase58(),\n        nonce: result[1],\n      }),\n    );\n  } catch {\n    // ignore\n  }\n\n  return [result[0].toBase58(), result[1]] as [string, number];\n};\n\n// shorten the checksummed version of the input address to have 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\n\nexport function getTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownSymbol = map.get(mintAddress)?.symbol;\n  if (knownSymbol) {\n    return knownSymbol;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\nexport function getVerboseTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownName = map.get(mintAddress)?.name;\n  if (knownName) {\n    return knownName;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\n\nexport function getTokenByName(tokenMap: KnownTokenMap, name: string) {\n  let token: TokenInfo | null = null;\n  for (const val of tokenMap.values()) {\n    if (val.symbol === name) {\n      token = val;\n      break;\n    }\n  }\n  return token;\n}\n\nexport function getTokenIcon(\n  map: KnownTokenMap,\n  mintAddress?: string | PublicKey,\n): string | undefined {\n  const address =\n    typeof mintAddress === 'string' ? mintAddress : mintAddress?.toBase58();\n  if (!address) {\n    return;\n  }\n\n  return map.get(address)?.logoURI;\n}\n\nexport function isKnownMint(map: KnownTokenMap, mintAddress: string) {\n  return !!map.get(mintAddress);\n}\n\nexport const STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);\n\nexport function chunks<T>(array: T[], size: number): T[][] {\n  return Array.apply<number, T[], T[][]>(\n    0,\n    new Array(Math.ceil(array.length / size)),\n  ).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n\nexport function toLamports(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  return Math.floor(amount * precision);\n}\n\nexport function wadToLamports(amount?: BN): BN {\n  return amount?.div(WAD) || ZERO;\n}\n\nexport function fromLamports(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount = Math.floor(\n    typeof account === 'number'\n      ? account\n      : BN.isBN(account)\n      ? account.toNumber()\n      : account.info.amount.toNumber(),\n  );\n\n  const precision = Math.pow(10, mint?.decimals || 9);\n  return (amount / precision) * rate;\n}\n\nexport const tryParseKey = (key: string): PublicKey | null => {\n  try {\n    return new PublicKey(key);\n  } catch (error) {\n    return null;\n  }\n};\n\nvar SI_SYMBOL = ['', 'k', 'M', 'G', 'T', 'P', 'E'];\n\nconst abbreviateNumber = (number: number, precision: number) => {\n  let tier = (Math.log10(number) / 3) | 0;\n  let scaled = number;\n  let suffix = SI_SYMBOL[tier];\n  if (tier !== 0) {\n    let scale = Math.pow(10, tier * 3);\n    scaled = number / scale;\n  }\n\n  return scaled.toFixed(precision) + suffix;\n};\n\nexport const formatAmount = (\n  val: number,\n  precision: number = 2,\n  abbr: boolean = true,\n) => (abbr ? abbreviateNumber(val, precision) : val.toFixed(precision));\n\nexport function formatTokenAmount(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n  prefix = '',\n  suffix = '',\n  precision = 2,\n  abbr = false,\n): string {\n  if (!account) {\n    return '';\n  }\n\n  return `${[prefix]}${formatAmount(\n    fromLamports(account, mint, rate),\n    precision,\n    abbr,\n  )}${suffix}`;\n}\n\nexport const formatUSD = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n});\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n};\n\nexport const formatPct = new Intl.NumberFormat('en-US', {\n  style: 'percent',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport function convert(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  let result = (amount / precision) * rate;\n\n  return result;\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import { sleep, useLocalStorageState } from \"../utils/utils\";\nimport {\n  Keypair,\n  clusterApiUrl,\n  Commitment,\n  Connection,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n  Blockhash,\n  FeeCalculator,\n} from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport { notify } from \"../utils/notifications\";\nimport { ExplorerLink } from \"../components/ExplorerLink\";\nimport {\n  TokenInfo,\n  TokenListProvider,\n  ENV as ChainId,\n} from \"@solana/spl-token-registry\";\nimport { WalletSigner } from \"./WalletContext/WalletContext\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport type ENV = \"mainnet-beta\" | \"testnet\" | \"devnet\" | \"localnet\";\n\nexport const ENDPOINTS = [\n  {\n    name: \"devnet\" as ENV,\n    endpoint: \"https://api.devnet.solana.com\",\n    ChainId: ChainId.Devnet,\n  },\n  {\n    name: \"mainnet-beta\" as ENV,\n    endpoint: \"https://api.mainnet-beta.solana.com\",\n    ChainId: ChainId.MainnetBeta,\n  },\n];\n\nconst DEFAULT = ENDPOINTS[0].endpoint;\n\ninterface ConnectionConfig {\n  connection: Connection;\n  endpoint: string;\n  env: ENV;\n  setEndpoint: (val: string) => void;\n  tokens: TokenInfo[];\n  tokenMap: Map<string, TokenInfo>;\n}\n\nconst ConnectionContext = React.createContext<ConnectionConfig>({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map<string, TokenInfo>(),\n});\n\nexport function ConnectionProvider({ children = undefined as any }) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\n    \"connectionEndpoint\",\n    ENDPOINTS[0].endpoint\n  );\n\n  const connection = useMemo(\n    () => new Connection(endpoint, \"recent\"),\n    [endpoint]\n  );\n\n  const env =\n    ENDPOINTS.find((end) => end.endpoint === endpoint)?.name ||\n    ENDPOINTS[0].name;\n\n  const [tokens, setTokens] = useState<TokenInfo[]>([]);\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n  useEffect(() => {\n    // fetch token files\n    new TokenListProvider().resolve().then((container) => {\n      const list = container\n        .excludeByTag(\"nft\")\n        .filterByChainId(\n          ENDPOINTS.find((end) => end.endpoint === endpoint)?.ChainId ||\n            ChainId.MainnetBeta\n        )\n        .getList();\n\n      const knownMints = [...list].reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map<string, TokenInfo>());\n\n      setTokenMap(knownMints);\n      setTokens(list);\n    });\n  }, [env]);\n\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n  useEffect(() => {\n    const id = connection.onAccountChange(\n      Keypair.generate().publicKey,\n      () => {}\n    );\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n\n  return (\n    <ConnectionContext.Provider\n      value={{\n        endpoint,\n        setEndpoint,\n        connection,\n        tokens,\n        tokenMap,\n        env,\n      }}\n    >\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection() {\n  return useContext(ConnectionContext).connection as Connection;\n}\n\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap,\n  };\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach((log) => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[][],\n  signers: Keypair[][]\n) {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength: any = null;\n  let toRemoveSigners: Record<number, boolean> = {};\n\n \n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          \"single\"\n        );\n        stopPoint = 1;\n      } else {\n        stopPoint = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          SequenceType.StopOnFailure,\n          \"single\"\n        );\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      \"Died on \",\n      stopPoint,\n      \"retrying from instruction\",\n      instructions[stopPoint],\n      \"instructions length is\",\n      instructions.length\n    );\n    lastInstructionsLength = instructions.length;\n  }\n}\n\nexport const sendTransactions = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructionSet: TransactionInstruction[][],\n  signersSet: Keypair[][],\n  sequenceType: SequenceType = SequenceType.Parallel,\n  commitment: Commitment = \"singleGossip\",\n  successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n  failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n  block?: BlockhashAndFeeCalculator\n): Promise<number> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns: Transaction[] = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach((instruction) => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n  let breakEarlyObject = { breakEarly: false, i: 0 };\n  console.log(\n    \"Signed txns length\",\n    signedTxns.length,\n    \"vs handed in length\",\n    instructionSet.length\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    signedTxnPromise\n      .then(({ txid, slot }) => {\n        successCallback(txid, i);\n      })\n      .catch((reason) => {\n        // @ts-ignore\n        failCallback(signedTxns[i], i);\n        if (sequenceType === SequenceType.StopOnFailure) {\n          breakEarlyObject.breakEarly = true;\n          breakEarlyObject.i = i;\n        }\n      });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log(\"Caught failure\", e);\n        if (breakEarlyObject.breakEarly) {\n          console.log(\"Died on \", breakEarlyObject.i);\n          return breakEarlyObject.i; // Return the txn we failed on by index\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    await Promise.all(pendingTxns);\n  }\n\n  return signedTxns.length;\n};\n\nexport const sendTransaction = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  awaitConfirmation = true,\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment\n    );\n\n    if (!confirmation)\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n      notify({\n        message: \"Transaction failed...\",\n        description: (\n          <>\n            {errors.map((err) => (\n              <div>{err}</div>\n            ))}\n            <ExplorerLink address={txid} type=\"transaction\" />\n          </>\n        ),\n        type: \"error\",\n      });\n\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    try {\n      transaction = await wallet.signTransaction(transaction);\n    } catch {\n      return false;\n    }\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n  console.log(\"About to send\");\n  try {\n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n\n    return { txid, slot };\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    }\n  );\n\n  console.log(\"Started awaiting confirmation for\", txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      \"recent\",\n      true\n    );\n\n    if (!confirmation)\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error(\"Transaction failed: Custom instruction error\");\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    console.error(\"Timeout Error caught\", err);\n    if ((err as any).timeout) {\n      throw new Error(\"Timed out awaiting confirmation on transaction\");\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, \"single\")\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith(\"Program log: \")) {\n            throw new Error(\n              \"Transaction failed: \" + line.slice(\"Program log: \".length)\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log(\"Latency\", txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString(\"base64\");\n  const config: any = { encoding: \"base64\", commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"simulateTransaction\", args);\n  if (res.error) {\n    throw new Error(\"failed to simulate transaction: \" + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = \"recent\",\n  queryStatus = false\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log(\"Rejecting for timeout...\");\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log(\"Rejected via websocket\", result.err);\n            reject(status);\n          } else {\n            console.log(\"Resolved via websocket\", result);\n            resolve(status);\n          }\n        },\n        commitment\n      );\n    } catch (e) {\n      done = true;\n      console.error(\"WS error in setup\", txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          console.log(`https://explorer.solana.com/tx/${txid}?cluster=devnet`); // TODO\n          if (!done) {\n            if (!status) {\n              console.log(\"REST null result for\", txid, status);\n            } else if (status.err) {\n              console.log(\"REST error for\", txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log(\"REST no confirmations for\", txid, status);\n            } else {\n              console.log(\"REST confirmation for\", txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log(\"REST connection error: txid\", txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log(\"Returning status\", status);\n  return status;\n}\n"],"sourceRoot":""}